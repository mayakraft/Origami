
<!doctype html>
<html lang="en">

<head>
    <title>Code coverage report for rabbit-ear.js</title>
    <meta charset="utf-8" />
    <link rel="stylesheet" href="prettify.css" />
    <link rel="stylesheet" href="base.css" />
    <link rel="shortcut icon" type="image/x-icon" href="favicon.png" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style type='text/css'>
        .coverage-summary .sorter {
            background-image: url(sort-arrow-sprite.png);
        }
    </style>
</head>
    
<body>
<div class='wrapper'>
    <div class='pad1'>
        <h1><a href="index.html">All files</a> rabbit-ear.js</h1>
        <div class='clearfix'>
            
            <div class='fl pad1y space-right2'>
                <span class="strong">64.59% </span>
                <span class="quiet">Statements</span>
                <span class='fraction'>2800/4335</span>
            </div>
        
            
            <div class='fl pad1y space-right2'>
                <span class="strong">49.24% </span>
                <span class="quiet">Branches</span>
                <span class='fraction'>1160/2356</span>
            </div>
        
            
            <div class='fl pad1y space-right2'>
                <span class="strong">58.26% </span>
                <span class="quiet">Functions</span>
                <span class='fraction'>987/1694</span>
            </div>
        
            
            <div class='fl pad1y space-right2'>
                <span class="strong">100% </span>
                <span class="quiet">Lines</span>
                <span class='fraction'>1/1</span>
            </div>
        
            
        </div>
        <p class="quiet">
            Press <em>n</em> or <em>j</em> to go to the next uncovered block, <em>b</em>, <em>p</em> or <em>k</em> for the previous block.
        </p>
    </div>
    <div class='status-line medium'></div>
    <pre><table class="coverage">
<tr><td class="line-count quiet"><a name='L1'></a><a href='#L1'>1</a>
<a name='L2'></a><a href='#L2'>2</a>
<a name='L3'></a><a href='#L3'>3</a></td><td class="line-coverage quiet"><span class="cline-any cline-neutral">&nbsp;</span>
<span class="cline-any cline-yes">26373x</span>
<span class="cline-any cline-neutral">&nbsp;</span></td><td class="text"><pre class="prettyprint lang-js">/* Rabbit Ear alpha 2 2020-12-30 (c) Robby Kraft, MIT License */
!function(e,t){"object"==typeof exports&amp;&amp;"undefined"!=typeof module?module.exports=t():<span class="branch-1 cbranch-no" title="branch not covered" >"function"==typeof define&amp;&amp;define.amd?define(t):(e="undefined"!=typeof globalThis?globalThis:e||self).ear=t()}</span>(this,(function(){"use strict";function _typeof(e){return(_typeof="function"==typeof Symbol&amp;&amp;"symbol"==typeof Symbol.iterator?function(e){return typeof e}:<span class="fstat-no" title="function not covered" ><span class="branch-1 cbranch-no" title="branch not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return e&amp;&amp;"function"==typeof Symbol&amp;&amp;e.constructor===Symbol&amp;&amp;e!==Symbol.prototype?"symbol":typeof e}</span>)</span>(e)}function _defineProperty(e,t,n){return t in e?<span class="branch-0 cbranch-no" title="branch not covered" >Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):</span>e[t]=n,e}function ownKeys(e,t){var n=Object.keys(e);<span class="missing-if-branch" title="else path not taken" >E</span>if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&amp;&amp;(r=r.filter((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return Object.getOwnPropertyDescriptor(e,t).enumerable}</span>))),n.push.apply(n,r)}return n}function _objectSpread2(e){for(var t=1;t&lt;arguments.length;t++){var n=null!=arguments[t]?arguments[t]:<span class="branch-1 cbranch-no" title="branch not covered" >{};</span>t%2?ownKeys(Object(n),!0).forEach((function(t){_defineProperty(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):<span class="branch-1 cbranch-no" title="branch not covered" >ownKeys(Object(n)).forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}</span>))}</span>return e}function _slicedToArray(e,t){return function _arrayWithHoles(e){<span class="missing-if-branch" title="else path not taken" >E</span>if(Array.isArray(e))return e}(e)||<span class="branch-1 cbranch-no" title="branch not covered" >function <span class="fstat-no" title="function not covered" >_iterableToArrayLimit(</span>e,t){<span class="cstat-no" title="statement not covered" >if("undefined"==typeof Symbol||!(Symbol.iterator in Object(e)))<span class="cstat-no" title="statement not covered" >return;v</span></span>ar n=<span class="cstat-no" title="statement not covered" >[],</span>r=<span class="cstat-no" title="statement not covered" >!0,</span>o=<span class="cstat-no" title="statement not covered" >!1,</span>i=<span class="cstat-no" title="statement not covered" >void 0;<span class="cstat-no" title="statement not covered" ></span>try{<span class="cstat-no" title="statement not covered" >for(var c,a=<span class="cstat-no" title="statement not covered" >e[Symbol.iterator]();</span>!(r=(c=a.next()).done)&amp;&amp;(n.push(c.value),!t||n.length!==t);r=!0);}</span>catch(e){<span class="cstat-no" title="statement not covered" >o=!0,i=e}</span>finally{<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >r||null==a.return||a.return()}</span>finally{<span class="cstat-no" title="statement not covered" >if(o)<span class="cstat-no" title="statement not covered" >throw i}</span></span>}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn n}</span>(e,t)|</span>|<span class="branch-2 cbranch-no" title="branch not covered" >_unsupportedIterableToArray(e,t)|</span>|<span class="branch-3 cbranch-no" title="branch not covered" >function <span class="fstat-no" title="function not covered" >_nonIterableRest(</span>){<span class="cstat-no" title="statement not covered" >throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}</span>()}</span>function _toConsumableArray(e){return function _arrayWithoutHoles(e){if(Array.isArray(e))return _arrayLikeToArray(e)}(e)||function _iterableToArray(e){<span class="missing-if-branch" title="else path not taken" >E</span>if("undefined"!=typeof Symbol&amp;&amp;Symbol.iterator in Object(e))return Array.from(e)}(e)||<span class="branch-2 cbranch-no" title="branch not covered" >_unsupportedIterableToArray(e)|</span>|<span class="branch-3 cbranch-no" title="branch not covered" >function <span class="fstat-no" title="function not covered" >_nonIterableSpread(</span>){<span class="cstat-no" title="statement not covered" >throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}</span>()}</span>function <span class="fstat-no" title="function not covered" >_unsupportedIterableToArray(</span>e,t){<span class="cstat-no" title="statement not covered" >if(e){<span class="cstat-no" title="statement not covered" >if("string"==typeof e)<span class="cstat-no" title="statement not covered" >return _arrayLikeToArray(e,t);v</span></span>ar n=<span class="cstat-no" title="statement not covered" >Object.prototype.toString.call(e).slice(8,-1);<span class="cstat-no" title="statement not covered" ></span>return"Object"===n&amp;&amp;e.constructor&amp;&amp;(n=e.constructor.name),"Map"===n||"Set"===n?Array.from(e):"Arguments"===n||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)?_arrayLikeToArray(e,t):void 0}</span>}</span>function _arrayLikeToArray(e,t){(null==t||<span class="branch-1 cbranch-no" title="branch not covered" >t&gt;e.length)</span>&amp;&amp;(t=e.length);for(var n=0,r=new Array(t);n&lt;t;n++)r[n]=e[n];return r}var e="undefined"!=typeof window&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >void 0!==window.document,</span>t="undefined"!=typeof process&amp;&amp;null!=process.versions&amp;&amp;null!=process.versions.node,n=("object"===("undefined"==typeof self?"undefined":<span class="branch-1 cbranch-no" title="branch not covered" >_typeof(self))</span>&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >self.constructor&amp;</span>&amp;<span class="branch-2 cbranch-no" title="branch not covered" >self.constructor.name,</span>function type_of(e){switch(e.constructor.name){case"vector":case"matrix":case"segment":case"ray":case"line":case"circle":case"ellipse":case"rect":case"polygon":case"junction":return e.constructor.name}if("object"===_typeof(e)){if(null!=e.radius)return"circle";if(null!=e.width)return"rect";if(null!=e.x||"number"==typeof e[0])return"vector";if(null!=e[0]&amp;&amp;e[0].length&amp;&amp;("number"==typeof e[0].x||"number"==typeof e[0][0]))return"segment";if(null!=e.vector&amp;&amp;null!=e.origin)return"line"}}),r=function resize(e,t){return t.length===e?t:Array(e).fill(0).map((function(e,n){return t[n]?t[n]:e}))},o=function resize_up$1(e,t){var n=e.length&gt;t.length?e.length:t.length;return[e,t].map((function(e){return r(n,e)}))},i=function count_places(e){var t="".concat(e).match(/(?:\.(\d+))?(?:[eE]([+-]?\d+))?$/);return t?Math.max(0,(t[1]?t[1].length:0)-(t[2]?+t[2]:0)):<span class="branch-1 cbranch-no" title="branch not covered" >0}</span>,c=function clean_number(e){var t=arguments.length&gt;1&amp;&amp;void 0!==arguments[1]?arguments[1]:15;if("number"!=typeof e)return e;var n=parseFloat(e.toFixed(t));return i(n)===Math.min(t,i(e))?e:n},a=function is_iterable(e){return null!=e&amp;&amp;"function"==typeof e[Symbol.iterator]},u=function semi_flatten_arrays(){switch(arguments.length){<span class="branch-0 cbranch-no" title="branch not covered" >case void 0:c</span>ase 0:return Array.from(arguments);case 1:return a(arguments[0])&amp;&amp;"string"!=typeof arguments[0]?semi_flatten_arrays.apply(void 0,_toConsumableArray(arguments[0])):[arguments[0]];default:return Array.from(arguments).map((function(e){return a(e)?_toConsumableArray(semi_flatten_arrays(e)):e}))}},s=function flatten_arrays(){switch(arguments.length){<span class="branch-0 cbranch-no" title="branch not covered" >case void 0:c</span>ase 0:return Array.from(arguments);case 1:return a(arguments[0])&amp;&amp;"string"!=typeof arguments[0]?flatten_arrays.apply(void 0,_toConsumableArray(arguments[0])):[arguments[0]];default:return Array.from(arguments).map((function(e){return a(e)?_toConsumableArray(flatten_arrays(e)):e})).reduce((function(e,t){return e.concat(t)}),[])}},l=Object.freeze({__proto__:null,resize:r,resize_up:o,resize_down:function resize_down(e,t){var n=e.length&gt;t.length?t.length:<span class="branch-1 cbranch-no" title="branch not covered" >e.length;</span>return[e,t].map((function(e){return r(n,e)}))},clean_number:c,semi_flatten_arrays:u,flatten_arrays:s}),v=Object.create(null),d=[1,0,0,1],p=d.concat(0,0),h=function determinant2(e){return e[0]*e[3]-e[1]*e[2]},m=function make_matrix2_rotate(e){var t=arguments.length&gt;1&amp;&amp;void 0!==arguments[1]?<span class="branch-0 cbranch-no" title="branch not covered" >arguments[1]:</span>[0,0],n=Math.cos(e),r=Math.sin(e);return[n,r,-r,n,t[0],t[1]]},b=Object.freeze({__proto__:null,identity2x2:d,identity2x3:p,multiply_matrix2_vector2:function <span class="fstat-no" title="function not covered" >multiply_matrix2_vector2(</span>e,t){<span class="cstat-no" title="statement not covered" >return[e[0]*t[0]+e[2]*t[1]+e[4],e[1]*t[0]+e[3]*t[1]+e[5]]}</span>,multiply_matrix2_line2:function <span class="fstat-no" title="function not covered" >multiply_matrix2_line2(</span>e,t,n){<span class="cstat-no" title="statement not covered" >return{vector:[e[0]*t[0]+e[2]*t[1],e[1]*t[0]+e[3]*t[1]],origin:[e[0]*n[0]+e[2]*n[1]+e[4],e[1]*n[0]+e[3]*n[1]+e[5]]}}</span>,multiply_matrices2:function <span class="fstat-no" title="function not covered" >multiply_matrices2(</span>e,t){<span class="cstat-no" title="statement not covered" >return[e[0]*t[0]+e[2]*t[1],e[1]*t[0]+e[3]*t[1],e[0]*t[2]+e[2]*t[3],e[1]*t[2]+e[3]*t[3],e[0]*t[4]+e[2]*t[5]+e[4],e[1]*t[4]+e[3]*t[5]+e[5]]}</span>,determinant2:h,invert_matrix2:function invert_matrix2(e){var t=h(e);if(!(Math.abs(t)&lt;1e-6||isNaN(t))&amp;&amp;isFinite(e[4])&amp;&amp;isFinite(e[5]))return[e[3]/t,-e[1]/t,-e[2]/t,e[0]/t,(e[2]*e[5]-e[3]*e[4])/t,(e[1]*e[4]-e[0]*e[5])/t]},make_matrix2_translate:function make_matrix2_translate(){var e=arguments.length&gt;0&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >void 0!==arguments[0]?<span class="branch-0 cbranch-no" title="branch not covered" ></span>arguments[0]:</span>0,t=arguments.length&gt;1&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >void 0!==arguments[1]?<span class="branch-0 cbranch-no" title="branch not covered" ></span>arguments[1]:</span>0;return d.concat(e,t)},make_matrix2_scale:function make_matrix2_scale(e,t){var n=arguments.length&gt;2&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >void 0!==arguments[2]?<span class="branch-0 cbranch-no" title="branch not covered" ></span>arguments[2]:</span>[0,0];return[e,0,0,t,e*-n[0]+n[0],t*-n[1]+n[1]]},make_matrix2_rotate:m,make_matrix2_reflect:function make_matrix2_reflect(e){var t=arguments.length&gt;1&amp;&amp;void 0!==arguments[1]?arguments[1]:<span class="branch-1 cbranch-no" title="branch not covered" >[0,0],</span>n=Math.atan2(e[1],e[0]),r=Math.cos(n),o=Math.sin(n),i=Math.cos(-n),c=Math.sin(-n),a=r*i+o*c,u=r*-c+o*i,s=o*i+-r*c,l=o*-c+-r*i,v=t[0]+a*-t[0]+-t[1]*s,d=t[1]+u*-t[0]+-t[1]*l;return[a,u,s,l,v,d]}}),k=180/Math.PI,w=Math.PI/180,E=2*Math.PI,M=1e-6,O=Object.freeze({__proto__:null,R2D:k,D2R:w,TWO_PI:E,EPSILON:M}),j=function fn_square(e){return e*e},C=function fn_add(e,t){return e+(t||0)},S=function fn_not_undefined(e){return void 0!==e},P=function magnitude(e){return Math.sqrt(e.map(j).reduce(C,0))},N=function mag_squared(e){return e.map(j).reduce(C,0)},I=function normalize(e){var t=P(e);return 0===t?e:e.map((function(e){return e/t}))},L=function scale(e,t){return e.map((function(e){return e*t}))},q=function add$1(e,t){return e.map((function(e,n){return e+(t[n]||0)}))},T=function subtract(e,t){return e.map((function(e,n){return e-(t[n]||0)}))},F=function dot(e,t){return e.map((function(n,r){return e[r]*t[r]})).reduce(C,0)},V=function midpoint(e,t){return e.map((function(e,n){return(e+t[n])/2}))},G=function average(){var e=arguments;if(0===arguments.length)return[];var t=arguments[0].length&gt;0?arguments[0].length:0,n=Array(t).fill(0);return Array.from(arguments).forEach((function(e){return n.forEach((function(t,r){n[r]+=e[r]||0}))})),n.map((function(t){return t/e.length}))},B=function lerp(e,t,n){var r=1-n;return e.map((function(e,o){return e*r+(t[o]||0)*n}))},D=function cross2(e,t){return e[0]*t[1]-e[1]*t[0]},R=function cross3(e,t){return[e[1]*t[2]-e[2]*t[1],e[2]*t[0]-e[0]*t[2],e[0]*t[1]-e[1]*t[0]]},U=function distance2(e,t){var n=e[0]-t[0],r=e[1]-t[1];return Math.sqrt(n*n+r*r)},Z=function distance(e,t){return Math.sqrt(e.map((function(n,r){return Math.pow(e[r]-t[r],2)})).reduce((function(e,t){return e+t}),0))},X=function flip(e){return e.map((function(e){return-e}))},$=function rotate90(e){return[-e[1],e[0]]},H=function rotate270(e){return[e[1],-e[0]]},Y=function degenerate(e){var t=arguments.length&gt;1&amp;&amp;void 0!==arguments[1]?arguments[1]:<span class="branch-1 cbranch-no" title="branch not covered" >M;</span>return Math.abs(e.reduce(C,0))&lt;t},W=function parallel(e,t){var n=arguments.length&gt;2&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >void 0!==arguments[2]?<span class="branch-0 cbranch-no" title="branch not covered" ></span>arguments[2]:</span>M;return 1-Math.abs(F(I(e),I(t)))&lt;n},J=function alternating_sum(e){return[0,1].map((function(t){return e.filter((function(e,n){return n%2===t})).reduce(C,0)}))},K=Object.freeze({__proto__:null,magnitude:P,mag_squared:N,normalize:I,scale:L,add:q,subtract:T,dot:F,midpoint:V,average:G,lerp:B,cross2:D,cross3:R,distance2:U,distance3:function distance3(e,t){var n=e[0]-t[0],r=e[1]-t[1],o=e[2]-t[2];return Math.sqrt(n*n+r*r+o*o)},distance:Z,flip:X,rotate90:$,rotate270:H,degenerate:Y,parallel:W,alternating_sum:J,alternating_deviation:function alternating_deviation(e){var t=e.reduce(C,0)/2;return J(e).map((function(e){return e-t}))}}),Q=Object.freeze([1,0,0,0,1,0,0,0,1]),ee=Object.freeze(Q.concat(0,0,0)),te=function is_identity3x4(e){return ee.map((function(t,n){return Math.abs(t-e[n])&lt;M})).reduce((function(e,t){return e&amp;&amp;t}),!0)},ne=function multiply_matrix3_vector3(e,t){return[e[0]*t[0]+e[3]*t[1]+e[6]*t[2]+e[9],e[1]*t[0]+e[4]*t[1]+e[7]*t[2]+e[10],e[2]*t[0]+e[5]*t[1]+e[8]*t[2]+e[11]]},re=function multiply_matrix3_line3(e,t,n){return{vector:[e[0]*t[0]+e[3]*t[1]+e[6]*t[2],e[1]*t[0]+e[4]*t[1]+e[7]*t[2],e[2]*t[0]+e[5]*t[1]+e[8]*t[2]],origin:[e[0]*n[0]+e[3]*n[1]+e[6]*n[2]+e[9],e[1]*n[0]+e[4]*n[1]+e[7]*n[2]+e[10],e[2]*n[0]+e[5]*n[1]+e[8]*n[2]+e[11]]}},oe=function multiply_matrices3(e,t){return[e[0]*t[0]+e[3]*t[1]+e[6]*t[2],e[1]*t[0]+e[4]*t[1]+e[7]*t[2],e[2]*t[0]+e[5]*t[1]+e[8]*t[2],e[0]*t[3]+e[3]*t[4]+e[6]*t[5],e[1]*t[3]+e[4]*t[4]+e[7]*t[5],e[2]*t[3]+e[5]*t[4]+e[8]*t[5],e[0]*t[6]+e[3]*t[7]+e[6]*t[8],e[1]*t[6]+e[4]*t[7]+e[7]*t[8],e[2]*t[6]+e[5]*t[7]+e[8]*t[8],e[0]*t[9]+e[3]*t[10]+e[6]*t[11]+e[9],e[1]*t[9]+e[4]*t[10]+e[7]*t[11]+e[10],e[2]*t[9]+e[5]*t[10]+e[8]*t[11]+e[11]]},ie=function determinant3(e){return e[0]*e[4]*e[8]-e[0]*e[7]*e[5]-e[3]*e[1]*e[8]+e[3]*e[7]*e[2]+e[6]*e[1]*e[5]-e[6]*e[4]*e[2]},ce=function invert_matrix3(e){var t=ie(e);if(!(Math.abs(t)&lt;1e-6||isNaN(t))&amp;&amp;isFinite(e[9])&amp;&amp;isFinite(e[10])&amp;&amp;isFinite(e[11])){var n=[e[4]*e[8]-e[7]*e[5],-e[1]*e[8]+e[7]*e[2],e[1]*e[5]-e[4]*e[2],-e[3]*e[8]+e[6]*e[5],e[0]*e[8]-e[6]*e[2],-e[0]*e[5]+e[3]*e[2],e[3]*e[7]-e[6]*e[4],-e[0]*e[7]+e[6]*e[1],e[0]*e[4]-e[3]*e[1],-e[3]*e[7]*e[11]+e[3]*e[8]*e[10]+e[6]*e[4]*e[11]-e[6]*e[5]*e[10]-e[9]*e[4]*e[8]+e[9]*e[5]*e[7],e[0]*e[7]*e[11]-e[0]*e[8]*e[10]-e[6]*e[1]*e[11]+e[6]*e[2]*e[10]+e[9]*e[1]*e[8]-e[9]*e[2]*e[7],-e[0]*e[4]*e[11]+e[0]*e[5]*e[10]+e[3]*e[1]*e[11]-e[3]*e[2]*e[10]-e[9]*e[1]*e[5]+e[9]*e[2]*e[4]],r=1/t;return n.map((function(e){return e*r}))}},ae=function make_matrix3_translate(){var e=arguments.length&gt;0&amp;&amp;void 0!==arguments[0]?arguments[0]:0,t=arguments.length&gt;1&amp;&amp;void 0!==arguments[1]?arguments[1]:0,n=arguments.length&gt;2&amp;&amp;void 0!==arguments[2]?arguments[2]:0;return Q.concat(e,t,n)},ue=function single_axis_rotate(e,t,n,r,o){var i=Q.concat([0,1,2].map((function(e){return t[e]||0}))),c=Math.cos(e),a=Math.sin(e);return i[3*n+n]=c,i[3*n+r]=(o?1:-1)*a,i[3*r+n]=(o?-1:1)*a,i[3*r+r]=c,i},se=function make_matrix3_rotateX(e){var t=arguments.length&gt;1&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >void 0!==arguments[1]?<span class="branch-0 cbranch-no" title="branch not covered" ></span>arguments[1]:</span>[0,0,0];return ue(e,t,1,2,!0)},fe=function make_matrix3_rotateY(e){var t=arguments.length&gt;1&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >void 0!==arguments[1]?<span class="branch-0 cbranch-no" title="branch not covered" ></span>arguments[1]:</span>[0,0,0];return ue(e,t,0,2,!1)},le=function make_matrix3_rotateZ(e){var t=arguments.length&gt;1&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >void 0!==arguments[1]?<span class="branch-0 cbranch-no" title="branch not covered" ></span>arguments[1]:</span>[0,0,0];return ue(e,t,0,1,!0)},ve=function make_matrix3_rotate(e){var t=arguments.length&gt;1&amp;&amp;void 0!==arguments[1]?arguments[1]:<span class="branch-1 cbranch-no" title="branch not covered" >[0,0,1],</span>n=arguments.length&gt;2&amp;&amp;void 0!==arguments[2]?arguments[2]:[0,0,0],o=r(3,I(t)),i=[0,1,2].map((function(e){return n[e]||0})),c=_slicedToArray(o,3),a=c[0],u=c[1],s=c[2],l=Math.cos(e),v=Math.sin(e),d=Math.sqrt(o[1]*o[1]+o[2]*o[2]),p=Math.abs(d)&lt;1e-6?0:u/d,h=Math.abs(d)&lt;1e-6?1:s/d,m=Q.concat(-i[0],-i[1],-i[2]),b=Q.concat(i[0],i[1],i[2]),k=[1,0,0,0,h,p,0,-p,h,0,0,0],w=[1,0,0,0,h,-p,0,p,h,0,0,0],E=[d,0,a,0,1,0,-a,0,d,0,0,0],M=[d,0,-a,0,1,0,a,0,d,0,0,0],O=[l,v,0,-v,l,0,0,0,1,0,0,0];return oe(b,oe(w,oe(M,oe(O,oe(E,oe(k,m))))))},de=function make_matrix3_scale(e){var t=arguments.length&gt;1&amp;&amp;void 0!==arguments[1]?arguments[1]:[0,0,0];return[e,0,0,0,e,0,0,0,e,e*-t[0]+t[0],e*-t[1]+t[1],e*-t[2]+t[2]]},pe=function make_matrix3_reflectZ(e){var t=arguments.length&gt;1&amp;&amp;void 0!==arguments[1]?arguments[1]:<span class="branch-1 cbranch-no" title="branch not covered" >[0,0],</span>n=Math.atan2(e[1],e[0]),r=Math.cos(n),o=Math.sin(n),i=Math.cos(-n),c=Math.sin(-n),a=r*i+o*c,u=r*-c+o*i,s=o*i+-r*c,l=o*-c+-r*i,v=t[0]+a*-t[0]+-t[1]*s,d=t[1]+u*-t[0]+-t[1]*l;return[a,u,0,s,l,0,0,0,1,v,d,0]},_e=Object.freeze({__proto__:null,identity3x3:Q,identity3x4:ee,is_identity3x4:te,multiply_matrix3_vector3:ne,multiply_matrix3_line3:re,multiply_matrices3:oe,determinant3:ie,invert_matrix3:ce,make_matrix3_translate:ae,make_matrix3_rotateX:se,make_matrix3_rotateY:fe,make_matrix3_rotateZ:le,make_matrix3_rotate:ve,make_matrix3_scale:de,make_matrix3_reflectZ:pe}),ge=function vector_origin_form(e,t){return{vector:e||<span class="branch-1 cbranch-no" title="branch not covered" >[],</span>origin:t||[]}},he=function get_vector$1(){if(arguments[0]instanceof v.vector)return arguments[0];var e=s(arguments);return e.length&gt;0&amp;&amp;"object"===_typeof(e[0])&amp;&amp;null!==e[0]&amp;&amp;!isNaN(e[0].x)&amp;&amp;(e=["x","y","z"].map((function(t){return e[0][t]})).filter(S)),e.filter((function(e){return"number"==typeof e}))},me=function get_vector_of_vectors(){return u(arguments).map((function(e){return he(e)}))},ye=function get_segment(){if(arguments[0]instanceof v.segment)return arguments[0];var e=u(arguments);return 4===e.length?[[e[0],e[1]],[e[2],e[3]]]:me(e)},be=function get_line(){var e=u(arguments);return 0===e.length?ge([],[]):e[0]instanceof v.line||e[0]instanceof v.ray||e[0]instanceof v.segment?e[0]:e[0].constructor===Object?ge(e[0].vector||[],e[0].origin||[]):"number"==typeof e[0]?ge(he(e)):ge.apply(void 0,_toConsumableArray(e.map((function(e){return he(e)}))))},xe=be,Ae=function get_rect_params(){var e=arguments.length&gt;0&amp;&amp;void 0!==arguments[0]?arguments[0]:0,t=arguments.length&gt;1&amp;&amp;void 0!==arguments[1]?arguments[1]:0,n=arguments.length&gt;2&amp;&amp;void 0!==arguments[2]?arguments[2]:0,r=arguments.length&gt;3&amp;&amp;void 0!==arguments[3]?arguments[3]:0;return{x:e,y:t,width:n,height:r}},ke=function get_rect(){if(arguments[0]instanceof v.rect)return arguments[0];var e=s(arguments);if(e.length&gt;0&amp;&amp;"object"===_typeof(e[0])&amp;&amp;null!==e[0]&amp;&amp;!isNaN(e[0].width))return Ae.apply(void 0,_toConsumableArray(["x","y","width","height"].map((function(t){return e[0][t]})).filter(S)));var t=e.filter((function(e){return"number"==typeof e})),n=t.length&lt;4?[,,].concat(_toConsumableArray(t)):t;return Ae.apply(void 0,_toConsumableArray(n))},we=[[0,1,3,4,9,10],[0,1,2,3,4,5,6,7,8,9,10,11],[0,1,2,void 0,3,4,5,void 0,6,7,8,void 0,9,10,11]];[11,7,3].forEach((function(e){return delete we[2][e]}));var Ee=function matrix_map_3x4(e){return we[e&lt;8?0:e&lt;13?1:2]},Me=function get_matrix_3x4(){var e=s(arguments),t=_toConsumableArray(ee);return Ee(e.length).forEach((function(n,r){null!=e[r]&amp;&amp;(t[n]=e[r])})),t},Oe=Object.freeze({__proto__:null,get_vector:he,get_vector_of_vectors:me,get_segment:ye,get_line:be,get_ray:xe,get_rect_params:Ae,get_rect:ke,get_matrix_3x4:Me}),je=function fEqual(e,t){return e===t},Ce=function fEpsilonEqual(e,t){return Math.abs(e-t)&lt;M},Se=function array_similarity_test(e,t){return Array.from(Array(e.length-1)).map((function(n,r){return t(e[0],e[r+1])})).reduce((function(e,t){return e&amp;&amp;t}),!0)},Pe=function equivalent_vectors(){var e=Array.from(arguments),t=e.map((function(e){return e.length})).reduce((function(e,t){return e&gt;t?e:t})),n=e.map((function(e){return r(t,e)}));return Array.from(Array(arguments.length-1)).map((function(e,t){return n[0].map((function(e,r){return Math.abs(n[0][r]-n[t+1][r])&lt;M})).reduce((function(e,t){return e&amp;&amp;t}),!0)})).reduce((function(e,t){return e&amp;&amp;t}),!0)},Ne=Object.freeze({__proto__:null,equivalent_vec2:function equivalent_vec2(e,t){return Math.abs(e[0]-t[0])&lt;M&amp;&amp;Math.abs(e[1]-t[1])&lt;M},equivalent_numbers:function equivalent_numbers(){return 0!==arguments.length&amp;&amp;(1===arguments.length&amp;&amp;void 0!==arguments[0]?equivalent_numbers.apply(void 0,_toConsumableArray(arguments[0])):Se(arguments,Ce))},equivalent_vectors:Pe,equivalent:function equivalent(){var e=u.apply(void 0,arguments);if(e.length&lt;1)return!1;var t=_typeof(e[0]);if("undefined"===t)return!1;switch(t){case"number":return Se(e,Ce);case"boolean":case"string":return Se(e,je);case"object":return e[0].constructor===Array?Pe.apply(void 0,_toConsumableArray(e)):Se(e,(function(e,t){return JSON.stringify(e)===JSON.stringify(t)}));default:return}}}),ze=function ray_limiter(e){return e&lt;-M?0:e},Ie=function segment_limiter(e){return e&lt;-M?0:e&gt;1.000001?1:e},Le=function smallest_comparison_search(e,t,n){for(var r,o=t.map((function(t,r){return{o:t,i:r,d:n(e,t)}})),i=1/0,c=0;c&lt;o.length;c+=1)o[c].d&lt;i&amp;&amp;(r=c,i=o[c].d);return r},qe=function nearest_point_on_line(e,t,n,o){var i=arguments.length&gt;4&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >void 0!==arguments[4]?<span class="branch-0 cbranch-no" title="branch not covered" ></span>arguments[4]:</span>M;t=r(e.length,t),n=r(e.length,n);var c=N(e),a=T(n,t),u=F(e,a),s=u/c,l=o(s,i);return q(t,L(e,l))},Te=function nearest_point_on_polygon(e,t){var n=e.map((function(e,t,n){return T(n[(t+1)%n.length],e)}));return e.map((function(e,r){return qe(n[r],e,t,Ie)})).map((function(e,n){return{point:e,i:n,distance:Z(e,t)}})).sort((function(e,t){return e.distance-t.distance})).shift()},Fe=function nearest_point_on_circle(e,t,n){return q(t,L(I(T(n,t)),e))},Ve=Object.freeze({__proto__:null,ray_limiter:ze,segment_limiter:Ie,smallest_comparison_search:Le,nearest_point2:function nearest_point2(e,t){var n=Le(e,t,U);return void 0===n?<span class="branch-0 cbranch-no" title="branch not covered" >void 0:</span>t[n]},nearest_point:function nearest_point(e,t){var n=Le(e,t,Z);return void 0===n?<span class="branch-0 cbranch-no" title="branch not covered" >void 0:</span>t[n]},nearest_point_on_line:qe,nearest_point_on_polygon:Te,nearest_point_on_circle:Fe,nearest_point_on_ellipse:function <span class="fstat-no" title="function not covered" >nearest_point_on_ellipse(</span>){<span class="cstat-no" title="statement not covered" >return!1}</span>}),Ge=function include_l(){return!0},Be=function include_r(e){var t=arguments.length&gt;1&amp;&amp;void 0!==arguments[1]?arguments[1]:<span class="branch-1 cbranch-no" title="branch not covered" >M;</span>return e&gt;-t},De=function include_s(e){var t=arguments.length&gt;1&amp;&amp;void 0!==arguments[1]?arguments[1]:<span class="branch-1 cbranch-no" title="branch not covered" >M;</span>return e&gt;-t&amp;&amp;e&lt;1+t},Re=function exclude_l(){return!0},Ue=function exclude_r(e){var t=arguments.length&gt;1&amp;&amp;void 0!==arguments[1]?arguments[1]:<span class="branch-1 cbranch-no" title="branch not covered" >M;</span>return e&gt;t},Ze=function exclude_s(e){var t=arguments.length&gt;1&amp;&amp;void 0!==arguments[1]?arguments[1]:<span class="branch-1 cbranch-no" title="branch not covered" >M;</span>return e&gt;t&amp;&amp;e&lt;1-t},Xe=function intersect_lines(e,t,n,r,o,i){var c=arguments.length&gt;6&amp;&amp;void 0!==arguments[6]?arguments[6]:M,a=D(e,n),u=-a;if(!(Math.abs(D(I(e),I(n)))&lt;c)){var s=D(T(r,t),n),l=D(T(t,r),e),v=s/a,d=l/u;return o(v,c/P(e))&amp;&amp;i(d,c/P(n))?q(t,L(e,v)):void 0}},$e=Object.freeze({__proto__:null,include_l:Ge,include_r:Be,include_s:De,exclude_l:Re,exclude_r:Ue,exclude_s:Ze,intersect_lines:Xe}),He=function collinear(e,t,n,r){var o=arguments.length&gt;4&amp;&amp;void 0!==arguments[4]?arguments[4]:<span class="branch-1 cbranch-no" title="branch not covered" >M,</span>i=T(e,n),c=N(t);if(Math.sqrt(c)&lt;o)return!1;var a=Math.sqrt(c),u=D(i,t.map((function(e){return e/a}))),s=F(i,t)/c;return Math.abs(u)&lt;o&amp;&amp;r(s,o/a)},Ye=function point_on_line(e,t,n){var r=arguments.length&gt;3&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >void 0!==arguments[3]?<span class="branch-0 cbranch-no" title="branch not covered" ></span>arguments[3]:</span>M;return Math.abs(D(T(e,n),I(t)))&lt;r},We=Object.freeze({__proto__:null,collinear:He,point_on_line:Ye,point_on_ray_inclusive:function point_on_ray_inclusive(e,t,n){var r=arguments.length&gt;3&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >void 0!==arguments[3]?<span class="branch-0 cbranch-no" title="branch not covered" ></span>arguments[3]:</span>M;return He(e,t,n,Be,r)},point_on_ray_exclusive:function point_on_ray_exclusive(e,t,n){var r=arguments.length&gt;3&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >void 0!==arguments[3]?<span class="branch-0 cbranch-no" title="branch not covered" ></span>arguments[3]:</span>M;return He(e,t,n,Ue,r)},point_on_segment_inclusive:function point_on_segment_inclusive(e,t,n){var r=arguments.length&gt;3&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >void 0!==arguments[3]?<span class="branch-0 cbranch-no" title="branch not covered" ></span>arguments[3]:</span>M;return He(e,T(n,t),t,De,r)},point_on_segment_exclusive:function point_on_segment_exclusive(e,t,n){var r=arguments.length&gt;3&amp;&amp;void 0!==arguments[3]?arguments[3]:M;return He(e,T(n,t),t,Ze,r)}}),Je=function overlap_lines(e,t,n,r,o,i){var c=arguments.length&gt;6&amp;&amp;void 0!==arguments[6]?arguments[6]:<span class="branch-1 cbranch-no" title="branch not covered" >M,</span>a=D(e,n),u=-a;if(Math.abs(a)&lt;c)return He(r,e,t,o,c)||He(r,X(e),q(t,e),o,c)||He(t,n,r,i,c)||He(t,X(n),q(r,n),i,c);var s=D(T(r,t),n),l=D(T(t,r),e),v=s/a,d=l/u;return o(v,c/P(e))&amp;&amp;i(d,c/P(n))},Ke=function overlap_segment_segment_inclusive(e,t,n,r){var o=arguments.length&gt;4&amp;&amp;void 0!==arguments[4]?arguments[4]:M;return Je(T(t,e),e,T(r,n),n,De,De,o)},Qe=function overlap_segment_segment_exclusive(e,t,n,r){var o=arguments.length&gt;4&amp;&amp;void 0!==arguments[4]?arguments[4]:M;return Je(T(t,e),e,T(r,n),n,Ze,Ze,o)},et=Object.freeze({__proto__:null,overlap_lines:Je,overlap_line_line_inclusive:function overlap_line_line_inclusive(e,t,n,r){var o=arguments.length&gt;4&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >void 0!==arguments[4]?<span class="branch-0 cbranch-no" title="branch not covered" ></span>arguments[4]:</span>M;return Je(e,t,n,r,Ge,Ge,o)},overlap_line_ray_inclusive:function overlap_line_ray_inclusive(e,t,n,r){var o=arguments.length&gt;4&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >void 0!==arguments[4]?<span class="branch-0 cbranch-no" title="branch not covered" ></span>arguments[4]:</span>M;return Je(e,t,n,r,Ge,Be,o)},overlap_line_segment_inclusive:function overlap_line_segment_inclusive(e,t,n,r){var o=arguments.length&gt;4&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >void 0!==arguments[4]?<span class="branch-0 cbranch-no" title="branch not covered" ></span>arguments[4]:</span>M;return Je(e,t,T(r,n),n,Ge,De,o)},overlap_ray_ray_inclusive:function overlap_ray_ray_inclusive(e,t,n,r){var o=arguments.length&gt;4&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >void 0!==arguments[4]?<span class="branch-0 cbranch-no" title="branch not covered" ></span>arguments[4]:</span>M;return Je(e,t,n,r,Be,Be,o)},overlap_ray_segment_inclusive:function overlap_ray_segment_inclusive(e,t,n,r){var o=arguments.length&gt;4&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >void 0!==arguments[4]?<span class="branch-0 cbranch-no" title="branch not covered" ></span>arguments[4]:</span>M;return Je(e,t,T(r,n),n,Be,De,o)},overlap_segment_segment_inclusive:Ke,overlap_line_line_exclusive:function overlap_line_line_exclusive(e,t,n,r){var o=arguments.length&gt;4&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >void 0!==arguments[4]?<span class="branch-0 cbranch-no" title="branch not covered" ></span>arguments[4]:</span>M;return Je(e,t,n,r,Re,Re,o)},overlap_line_ray_exclusive:function overlap_line_ray_exclusive(e,t,n,r){var o=arguments.length&gt;4&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >void 0!==arguments[4]?<span class="branch-0 cbranch-no" title="branch not covered" ></span>arguments[4]:</span>M;return Je(e,t,n,r,Re,Ue,o)},overlap_line_segment_exclusive:function overlap_line_segment_exclusive(e,t,n,r){var o=arguments.length&gt;4&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >void 0!==arguments[4]?<span class="branch-0 cbranch-no" title="branch not covered" ></span>arguments[4]:</span>M;return Je(e,t,T(r,n),n,Re,Ze,o)},overlap_ray_ray_exclusive:function overlap_ray_ray_exclusive(e,t,n,r){var o=arguments.length&gt;4&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >void 0!==arguments[4]?<span class="branch-0 cbranch-no" title="branch not covered" ></span>arguments[4]:</span>M;return Je(e,t,n,r,Ue,Ue,o)},overlap_ray_segment_exclusive:function overlap_ray_segment_exclusive(e,t,n,r){var o=arguments.length&gt;4&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >void 0!==arguments[4]?<span class="branch-0 cbranch-no" title="branch not covered" ></span>arguments[4]:</span>M;return Je(e,t,T(r,n),n,Ue,Ze,o)},overlap_segment_segment_exclusive:Qe}),tt=function point_in_convex_poly_inclusive(e,t){var n=arguments.length&gt;2&amp;&amp;void 0!==arguments[2]?arguments[2]:M;return t.map((function(e,t,n){return[e,n[(t+1)%n.length]]})).map((function(t){return D(I(T(t[1],t[0])),T(e,t[0]))&gt;-n})).map((function(e,t,n){return e===n[0]})).reduce((function(e,t){return e&amp;&amp;t}),!0)},nt=function point_in_convex_poly_exclusive(e,t){var n=arguments.length&gt;2&amp;&amp;void 0!==arguments[2]?arguments[2]:M;return t.map((function(e,t,n){return[e,n[(t+1)%n.length]]})).map((function(t){return D(I(T(t[1],t[0])),T(e,t[0]))&gt;n})).map((function(e,t,n){return e===n[0]})).reduce((function(e,t){return e&amp;&amp;t}),!0)},rt=function point_in_poly(e,t){for(var n=!1,r=0,o=t.length-1;r&lt;t.length;o=r++)t[r][1]&gt;e[1]!=t[o][1]&gt;e[1]&amp;&amp;e[0]&lt;(t[o][0]-t[r][0])*(e[1]-t[r][1])/(t[o][1]-t[r][1])+t[r][0]&amp;&amp;(n=!n);return n},ot=function overlap_convex_polygons(e,t,n,r,o){for(var i=e.map((function(e,t,n){return[e,n[(t+1)%n.length]]})),c=t.map((function(e,t,n){return[e,n[(t+1)%n.length]]})),a=0;a&lt;i.length;a+=1)for(var u=0;u&lt;c.length;u+=1)if(n(i[a][0],i[a][1],c[u][0],c[u][1],o))return!0;return!!r(t[0],e,o)||!!r(e[0],t,o)},it=function overlap_convex_polygons_exclusive(e,t){var n=arguments.length&gt;2&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >void 0!==arguments[2]?<span class="branch-0 cbranch-no" title="branch not covered" ></span>arguments[2]:</span>M;return ot(e,t,Qe,nt,n)},ct=Object.freeze({__proto__:null,point_in_convex_poly_inclusive:tt,point_in_convex_poly_exclusive:nt,point_in_poly:rt,overlap_convex_polygons_inclusive:function overlap_convex_polygons_inclusive(e,t){var n=arguments.length&gt;2&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >void 0!==arguments[2]?<span class="branch-0 cbranch-no" title="branch not covered" ></span>arguments[2]:</span>M;return ot(e,t,Ke,tt,n)},overlap_convex_polygons_exclusive:it,enclose_convex_polygons_inclusive:function enclose_convex_polygons_inclusive(e,t){var n=e.map((function(e){return tt(e,t)})).reduce((function(e,t){return e||t}),!1),r=t.map((function(e){return tt(e,t)})).reduce((function(e,t){return e&amp;&amp;t}),!0);return!n&amp;&amp;r}}),at=function quick_equivalent_2(e,t){return Math.abs(e[0]-t[0])&lt;M&amp;&amp;Math.abs(e[1]-t[1])&lt;M},ut=function intersect_line_seg_include(e,t,n,r){var o=arguments.length&gt;4&amp;&amp;void 0!==arguments[4]?arguments[4]:<span class="branch-1 cbranch-no" title="branch not covered" >M;</span>return Xe(e,t,T(r,n),n,Ge,De,o)},st=function intersect_line_seg_exclude(e,t,n,r){var o=arguments.length&gt;4&amp;&amp;void 0!==arguments[4]?arguments[4]:M;return Xe(e,t,T(r,n),n,Re,Ze,o)},ft=function intersect_ray_seg_include(e,t,n,r){var o=arguments.length&gt;4&amp;&amp;void 0!==arguments[4]?arguments[4]:<span class="branch-1 cbranch-no" title="branch not covered" >M;</span>return Xe(e,t,T(r,n),n,Be,De,o)},lt=function intersect_ray_seg_exclude(e,t,n,r){var o=arguments.length&gt;4&amp;&amp;void 0!==arguments[4]?arguments[4]:<span class="branch-1 cbranch-no" title="branch not covered" >M;</span>return Xe(e,t,T(r,n),n,Ue,Ze,o)},vt=function intersect_seg_seg_include(e,t,n,r){var o=arguments.length&gt;4&amp;&amp;void 0!==arguments[4]?arguments[4]:<span class="branch-1 cbranch-no" title="branch not covered" >M;</span>return Xe(T(t,e),e,T(r,n),n,De,De,o)},dt=function intersect_seg_seg_exclude(e,t,n,r){var o=arguments.length&gt;4&amp;&amp;void 0!==arguments[4]?arguments[4]:<span class="branch-1 cbranch-no" title="branch not covered" >M;</span>return Xe(T(t,e),e,T(r,n),n,Ze,Ze,o)},pt=function is_counter_clockwise_between(e,t,n){for(;n&lt;t;)n+=E;for(;e&gt;t;)e-=E;for(;e&lt;t;)e+=E;return e&lt;n},_t=function counter_clockwise_angle_radians(e,t){for(;e&lt;0;)e+=E;for(;t&lt;0;)t+=E;for(;e&gt;E;)e-=E;for(;t&gt;E;)t-=E;var n=t-e;return n&gt;=0?n:E-(e-t)},gt=function clockwise_angle2(e,t){var n=t[0]*e[0]+t[1]*e[1],r=t[0]*e[1]-t[1]*e[0],o=Math.atan2(r,n);return o&lt;0&amp;&amp;(o+=E),o},ht=function counter_clockwise_angle2(e,t){var n=e[0]*t[0]+e[1]*t[1],r=e[0]*t[1]-e[1]*t[0],o=Math.atan2(r,n);return o&lt;0&amp;&amp;(o+=E),o},mt=function clockwise_bisect2(e,t){var n=Math.atan2(e[1],e[0])-gt(e,t)/2;return[Math.cos(n),Math.sin(n)]},yt=function counter_clockwise_bisect2(e,t){var n=Math.atan2(e[1],e[0])+ht(e,t)/2;return[Math.cos(n),Math.sin(n)]},bt=function bisect_lines2(e,t,n,r){var o=arguments.length&gt;4&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >void 0!==arguments[4]?<span class="branch-0 cbranch-no" title="branch not covered" ></span>arguments[4]:</span>M,i=D(e,n),c=F(e,n),a=i&gt;-o?[yt(e,n)]:[mt(e,n)];a[1]=i&gt;-o?$(a[0]):H(a[0]);var u=(r[0]-t[0])*n[1]-n[0]*(r[1]-t[1]),s=u/i,l=[e,n].map((function(e){return I(e)})),v=Math.abs(D.apply(void 0,_toConsumableArray(l)))&lt;o,d=v?V(t,r):[t[0]+e[0]*s,t[1]+e[1]*s],p=a.map((function(e){return{vector:e,origin:d}}));return v&amp;&amp;delete p[c&gt;-o?1:<span class="branch-1 cbranch-no" title="branch not covered" >0]</span>,p},xt=function counter_clockwise_radians_order(){for(var e=arguments.length,t=new Array(e),n=0;n&lt;e;n++)t[n]=arguments[n];var r=t.map((function(e,t){return t})).sort((function(e,n){return t[e]-t[n]}));return r.slice(r.indexOf(0),r.length).concat(r.slice(0,r.indexOf(0)))},At=function kawasaki_solutions_radians(e){return e.map((function(e,t,n){return[e,n[(t+1)%n.length]]})).map((function(e){return _t.apply(void 0,_toConsumableArray(e))})).map((function(e,t,n){return n.slice(t+1,n.length).concat(n.slice(0,t))})).map((function(e){return J(e).map((function(e){return Math.PI-e}))})).map((function(t,n){return e[n]+t[0]})).map((function(t,n){return pt(t,e[n],e[(n+1)%e.length])?t:void 0}))},kt=Object.freeze({__proto__:null,is_counter_clockwise_between:pt,clockwise_angle_radians:function clockwise_angle_radians(e,t){for(;e&lt;0;)e+=E;for(;t&lt;0;)t+=E;for(;e&gt;E;)e-=E;for(;t&gt;E;)t-=E;var n=e-t;return n&gt;=0?n:E-(t-e)},counter_clockwise_angle_radians:_t,clockwise_angle2:gt,counter_clockwise_angle2:ht,clockwise_bisect2:mt,counter_clockwise_bisect2:yt,bisect_lines2:bt,counter_clockwise_radians_order:xt,counter_clockwise_vector_order:function counter_clockwise_vector_order(){for(var e=arguments.length,t=new Array(e),n=0;n&lt;e;n++)t[n]=arguments[n];return xt.apply(void 0,_toConsumableArray(t.map((function(e){return Math.atan2(e[1],e[0])}))))},interior_angles:function interior_angles(){for(var e=arguments.length,t=new Array(e),n=0;n&lt;e;n++)t[n]=arguments[n];return t.map((function(e,t,n){return ht(e,n[(t+1)%n.length])}))},kawasaki_solutions_radians:At,kawasaki_solutions:function kawasaki_solutions(e){var t=e.map((function(e){return Math.atan2(e[1],e[0])}));return At(t).map((function(e){return void 0===e?void 0:[Math.cos(e),Math.sin(e)]}))}}),wt=function circumcircle(e,t,n){var r=t[0]-e[0],o=t[1]-e[1],i=n[0]-e[0],c=n[1]-e[1],a=r*(e[0]+t[0])+o*(e[1]+t[1]),u=i*(e[0]+n[0])+c*(e[1]+n[1]),s=2*(r*(n[1]-t[1])-o*(n[0]-t[0]));if(Math.abs(s)&lt;M){var l=Math.min(e[0],t[0],n[0]),v=Math.min(e[1],t[1],n[1]),d=.5*(Math.max(e[0],t[0],n[0])-l),p=.5*(Math.max(e[1],t[1],n[1])-v);return{origin:[l+d,v+p],radius:Math.sqrt(d*d+p*p)}}var h=[(c*a-o*u)/s,(r*u-i*a)/s],m=h[0]-e[0],b=h[1]-e[1];return{origin:h,radius:Math.sqrt(m*m+b*b)}},Et=function signed_area(e){return.5*e.map((function(e,t,n){var r=n[(t+1)%n.length];return e[0]*r[1]-r[0]*e[1]})).reduce(C,0)},Mt=function centroid(e){var t=1/(6*Et(e));return e.map((function(e,t,n){var r=n[(t+1)%n.length],o=e[0]*r[1]-r[0]*e[1];return[(e[0]+r[0])*o,(e[1]+r[1])*o]})).reduce((function(e,t){return[e[0]+t[0],e[1]+t[1]]}),[0,0]).map((function(e){return e*t}))},Ot=function enclosing_rectangle(e){var t=Array(e[0].length).fill(1/0),n=Array(e[0].length).fill(-1/0);e.forEach((function(e){return e.forEach((function(e,r){e&lt;t[r]&amp;&amp;(t[r]=e),e&gt;n[r]&amp;&amp;(n[r]=e)}))}));var r=n.map((function(e,n){return e-t[n]}));return Ae.apply(void 0,_toConsumableArray(t).concat(_toConsumableArray(r)))},jt=function angle_array(e){return Array.from(Array(Math.floor(e))).map((function(t,n){return E*(n/e)}))},Ct=function angles_to_vecs(e,t){return e.map((function(e){return[t*Math.cos(e),t*Math.sin(e)]})).map((function(e){return e.map((function(e){return c(e,14)}))}))},St=function make_regular_polygon(){var e=arguments.length&gt;0&amp;&amp;void 0!==arguments[0]?arguments[0]:3,t=arguments.length&gt;1&amp;&amp;void 0!==arguments[1]?arguments[1]:1;return Ct(jt(e),t)},Pt=function make_regular_polygon_side_aligned(){var e=arguments.length&gt;0&amp;&amp;void 0!==arguments[0]?arguments[0]:<span class="branch-1 cbranch-no" title="branch not covered" >3,</span>t=arguments.length&gt;1&amp;&amp;void 0!==arguments[1]?arguments[1]:1,n=Math.PI/e,r=jt(e).map((function(e){return e+n}));return Ct(r,t)},Nt=function <span class="fstat-no" title="function not covered" >split_polygon(</span>){<span class="cstat-no" title="statement not covered" >return console.warn("split polygon not done")}</span>,zt=function split_convex_polygon(e,t,n){var r=e.map((function(e,r){return{point:Ye(e,t,n)?e:null,at_index:r}})).filter((function(e){return null!=e.point})),o=e.map((function(e,r,o){return{point:st(t,n,e,o[(r+1)%o.length]),at_index:r}})).filter((function(e){return null!=e.point}));if(2==o.length){var i=o.slice().sort((function(e,t){return e.at_index-t.at_index})),c=e.slice(i[1].at_index+1).concat(e.slice(0,i[0].at_index+1));c.push(i[0].point),c.push(i[1].point);var a=e.slice(i[0].at_index+1,i[1].at_index+1);return a.push(i[1].point),a.push(i[0].point),[c,a]}if(1==o.length&amp;&amp;1==r.length){r[0].type="v",o[0].type="e";var u=r.concat(o).sort((function(e,t){return e.at_index-t.at_index})),s=e.slice(u[1].at_index+1).concat(e.slice(0,u[0].at_index+1));"e"===u[0].type&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >s.push(u[0].point),</span>s.push(u[1].point);var l=e.slice(u[0].at_index+1,u[1].at_index+1);return"e"===u[1].type&amp;&amp;l.push(u[1].point),l.push(u[0].point),[s,l]}if(2==r.length){var v=r.slice().sort((function(e,t){return e.at_index-t.at_index}));return[e.slice(v[1].at_index).concat(e.slice(0,v[0].at_index+1)),e.slice(v[0].at_index,v[1].at_index+1)]}return[e.slice()]},It=function convex_hull(e){var t=arguments.length&gt;2&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >void 0!==arguments[2]?<span class="branch-0 cbranch-no" title="branch not covered" ></span>arguments[2]:</span>M,n=1e4,r=e.slice().sort((function(e,n){return Math.abs(e[1]-n[1])&lt;t?e[0]-n[0]:e[1]-n[1]})),o=[];o.push(r[0]);var i=0,c=0,a=function _loop(){c+=1;var e=o.length-1,n=r.filter((function(n){return!(Math.abs(n[0]-o[e][0])&lt;t&amp;&amp;Math.abs(n[1]-o[e][1])&lt;t)})).map((function(t){for(var n=Math.atan2(o[e][1]-t[1],o[e][0]-t[0]);n&lt;i;)n+=2*Math.PI;return{node:t,angle:n,distance:void 0}})).sort((function(e,t){return e.angle&lt;t.angle?-1:e.angle&gt;t.angle?1:0}));<span class="missing-if-branch" title="if path not taken" >I</span>if(0===n.length)<span class="cstat-no" title="statement not covered" >return{v:void 0};v</span>ar a=n[0];if(n=n.filter((function(e){return Math.abs(a.angle-e.angle)&lt;t})).map((function(t){var n=Math.sqrt(Math.pow(o[e][0]-t.node[0],2)+Math.pow(o[e][1]-t.node[1],2));return t.distance=n,t})).sort((function(e,t){return e.distance&lt;t.distance?1:e.distance&gt;t.distance?-1:<span class="branch-1 cbranch-no" title="branch not covered" >0}</span>)),o.filter((function(e){return e===n[0].node})).length&gt;0)return{v:o};o.push(n[0].node),i=Math.atan2(o[e][1]-n[0].node[1],o[e][0]-n[0].node[0])};do{var u=a();if("object"===_typeof(u))return u.v}while(c&lt;n)},Lt=function recurseSkeleton(e,t,n){var r=e.map((function(e,t){return{vector:n[t],origin:e}})).map((function(e,t,n){return Xe(e.vector,e.origin,n[(t+1)%n.length].vector,n[(t+1)%n.length].origin,Ue,Ue)})),o=t.map((function(e,t){return qe(e.vector,e.origin,r[t],(function(e){return e}))}));if(3===e.length)return e.map((function(e){return{type:"skeleton",points:[e,r[0]]}})).concat([{type:"perpendicular",points:[o[0],r[0]]}]);var i=r.map((function(e,t){return Z(e,o[t])})),c=0;i.forEach((function(e,t){e&lt;i[c]&amp;&amp;(c=t)}));var a=[{type:"skeleton",points:[e[c],r[c]]},{type:"skeleton",points:[e[(c+1)%e.length],r[c]]},{type:"perpendicular",points:[o[c],r[c]]}],u=mt(X(t[(c+t.length-1)%t.length].vector),t[(c+1)%t.length].vector),s=c===e.length-1;return e.splice(c,2,r[c]),t.splice(c,1),n.splice(c,2,u),s&amp;&amp;(<span class="branch-1 cbranch-no" title="branch not covered" >e.splice(0,1),n.splice(0,1),t.push(t.shift()))</span>,a.concat(recurseSkeleton(e,t,n))},qt=function straight_skeleton(e){var t=e.map((function(e,t,n){return[e,n[(t+1)%n.length]]})).map((function(e){return{vector:T(e[1],e[0]),origin:e[0]}})),n=e.map((function(e,t,n){return[(t-1+n.length)%n.length,t,(t+1)%n.length].map((function(e){return n[e]}))})).map((function(e){return[T(e[0],e[1]),T(e[2],e[1])]})).map((function(e){return mt.apply(void 0,_toConsumableArray(e))}));return Lt(e,t,n)},Tt=Object.freeze({__proto__:null,circumcircle:wt,signed_area:Et,centroid:Mt,enclosing_rectangle:Ot,make_regular_polygon:St,make_regular_polygon_side_aligned:Pt,make_regular_polygon_inradius:function make_regular_polygon_inradius(){var e=arguments.length&gt;0&amp;&amp;void 0!==arguments[0]?arguments[0]:<span class="branch-1 cbranch-no" title="branch not covered" >3,</span>t=arguments.length&gt;1&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >void 0!==arguments[1]?<span class="branch-0 cbranch-no" title="branch not covered" ></span>arguments[1]:</span>1;return St(e,t/Math.cos(Math.PI/e))},make_regular_polygon_inradius_side_aligned:function make_regular_polygon_inradius_side_aligned(){var e=arguments.length&gt;0&amp;&amp;void 0!==arguments[0]?arguments[0]:<span class="branch-1 cbranch-no" title="branch not covered" >3,</span>t=arguments.length&gt;1&amp;&amp;void 0!==arguments[1]?arguments[1]:1;return Pt(e,t/Math.cos(Math.PI/e))},make_regular_polygon_side_length:function make_regular_polygon_side_length(){var e=arguments.length&gt;0&amp;&amp;void 0!==arguments[0]?arguments[0]:<span class="branch-1 cbranch-no" title="branch not covered" >3,</span>t=arguments.length&gt;1&amp;&amp;void 0!==arguments[1]?arguments[1]:1;return St(e,t/2/Math.sin(Math.PI/e))},make_regular_polygon_side_length_side_aligned:function make_regular_polygon_side_length_side_aligned(){var e=arguments.length&gt;0&amp;&amp;void 0!==arguments[0]?arguments[0]:<span class="branch-1 cbranch-no" title="branch not covered" >3,</span>t=arguments.length&gt;1&amp;&amp;void 0!==arguments[1]?arguments[1]:1;return Pt(e,t/2/Math.sin(Math.PI/e))},split_polygon:Nt,split_convex_polygon:zt,convex_hull:It,straight_skeleton:qt}),Ft=function acossafe(e){return e&gt;=1?<span class="branch-0 cbranch-no" title="branch not covered" >0:</span>e&lt;=-1?<span class="branch-0 cbranch-no" title="branch not covered" >Math.PI:</span>Math.acos(e)},Vt=function rotatePoint(e,t,n){var r=t[0]-e[0],o=t[1]-e[1],i=r*Math.cos(n)+o*Math.sin(n),c=o*Math.cos(n)-r*Math.sin(n);return[e[0]+i,e[1]+c]},Gt=function circle_circle(e,t){var n=arguments.length&gt;2&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >void 0!==arguments[2]?<span class="branch-0 cbranch-no" title="branch not covered" ></span>arguments[2]:</span>M,r=e.radius&lt;t.radius?e.radius:t.radius,o=e.radius&lt;t.radius?t.radius:e.radius,i=e.radius&lt;t.radius?e.origin:t.origin,c=e.radius&lt;t.radius?t.origin:e.origin,a=[i[0]-c[0],i[1]-c[1]],u=Math.sqrt(Math.pow(a[0],2)+Math.pow(a[1],2));if(!(u&lt;n)){var s=a.map((function(e,t){return e/u*o+c[t]}));if(Math.abs(o+r-u)&lt;n||Math.abs(o-(r+u))&lt;n)return[s];if(!(u+r&lt;o||o+r&lt;u)){var l=Ft((r*r-u*u-o*o)/(-2*u*o)),v=Vt(c,s,+l),d=Vt(c,s,-l);return[v,d]}}},Bt=function intersect_circle_line(e,t,n,r,o){var i=arguments.length&gt;5&amp;&amp;void 0!==arguments[5]?arguments[5]:M,c=Math.pow(n[0],2)+Math.pow(n[1],2),a=Math.sqrt(c),u=0===a?<span class="branch-0 cbranch-no" title="branch not covered" >n:</span>n.map((function(e){return e/a})),s=[-u[1],u[0]],l=[r[0]-t[0],r[1]-t[1]],v=l[0]*u[1]-u[0]*l[1];if(!(Math.abs(v)&gt;e+i)){var d=Math.sqrt(Math.pow(e,2)-Math.pow(v,2)),p=function f(e,n){return t[n]-s[n]*v+u[n]*e},h=Math.abs(e-Math.abs(v))&lt;i?[d].map((function(e){return[e,e].map(p)})):[-d,d].map((function(e){return[e,e].map(p)})),m=h.map((function(e){return e.map((function(e,t){return e-r[t]}))})).map((function(e){return e[0]*n[0]+n[1]*e[1]})).map((function(e){return e/c}));return h.filter((function(e,t){return o(m[t],i)}))}},Dt=function line_func(){return!0},Rt=function ray_func(e,t){return e&gt;-t},Ut=function segment_func(e,t){return e&gt;-t&amp;&amp;e&lt;1+t},Zt=function circle_line(e,t){var n=arguments.length&gt;2&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >void 0!==arguments[2]?<span class="branch-0 cbranch-no" title="branch not covered" ></span>arguments[2]:</span>M;return Bt(e.radius,e.origin,t.vector,t.origin,Dt,n)},Xt=function circle_ray(e,t){var n=arguments.length&gt;2&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >void 0!==arguments[2]?<span class="branch-0 cbranch-no" title="branch not covered" ></span>arguments[2]:</span>M;return Bt(e.radius,e.origin,t.vector,t.origin,Rt,n)},$t=function circle_segment(e,t){var n=arguments.length&gt;2&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >void 0!==arguments[2]?<span class="branch-0 cbranch-no" title="branch not covered" ></span>arguments[2]:</span>M;return Bt(e.radius,e.origin,t.vector,t.origin,Ut,n)},Ht=Object.freeze({__proto__:null,circle_circle:Gt,intersect_circle_line:Bt,circle_line:Zt,circle_ray:Xt,circle_segment:$t}),Yt=function <span class="fstat-no" title="function not covered" >cuberoot(</span>e){var t=<span class="cstat-no" title="statement not covered" >Math.pow(Math.abs(e),1/3);<span class="cstat-no" title="statement not covered" ></span>return e&lt;0?-t:t}</span>,Wt=Object.freeze({__proto__:null,axiom1:function axiom1(e,t){return v.line(I(T.apply(void 0,_toConsumableArray(o(t,e)))),e)},axiom2:function axiom2(e,t){return v.line(I($(T.apply(void 0,_toConsumableArray(o(t,e))))),V(e,t))},axiom3:function axiom3(e,t,n,r){return bt(e,t,n,r).map(v.line)},axiom4:function axiom4(e,t){return v.line($(I(e)),t)},axiom5:function axiom5(e,t,n,r){return(Bt(Z(n,r),n,e,t,(function(){return!0}))||<span class="branch-1 cbranch-no" title="branch not covered" >[])</span>.map((function(e){return v.line(I($(T.apply(void 0,_toConsumableArray(o(e,r))))),V(r,e))}))},axiom7:function axiom7(e,t,n,r){var i=Xe(e,t,n,r,Ge,Ge);return void 0===i?<span class="branch-0 cbranch-no" title="branch not covered" >void 0:</span>v.line(I($(T.apply(void 0,_toConsumableArray(o(i,r))))),V(r,i))},axiom6:function axiom6(e,t,n,r,o,i){var c=o[0],a=o[1];if(Math.abs(e[0])&gt;M)var u=e[1]/e[0],s=t[1]-u*t[0];else var l=t[0];var d=i[0],p=i[1];if(Math.abs(n[0])&gt;M)var h=n[1]/n[0],m=r[1]-h*r[0];else var b=r[0];if(void 0!==u&amp;&amp;void 0!==h)var k=u*u+1,w=2*u*s,E=s*s-c*c-a*a,O=h*h+1,j=2*h*m,C=m*m-d*d-p*p,S=h*c+(s-a),P=c*(m-p)-d*(s-a),N=h-u,I=u*d+(m-p),L=u*c+(s-a);else if(void 0===u&amp;&amp;void 0===h)k=1,w=0,E=l*l-c*c-a*a,O=1,j=0,C=b*b-d*d-p*p,P=a*(b-d)-p*(l-c),N=0,I=b-d,L=S=l-c;else{<span class="missing-if-branch" title="else path not taken" >E</span>if(void 0===u){var q=c;c=d,d=q;var T=a;a=p,p=T,u=h,h=void 0,s=m,m=void 0,b=l,l=void 0}k=u*u+1,w=2*u*s,E=s*s-c*c-a*a,O=1,j=0,C=b*b-d*d-p*p,S=c,P=(s-a)*(b-d)-c*p,N=1,I=-u*(b-d)-p,L=u*c+(s-a)}var F=function solveCubic(e,t,n,r){<span class="missing-if-branch" title="if path not taken" >I</span>if(Math.abs(e)&lt;M){<span class="cstat-no" title="statement not covered" >if(e=t,t=n,n=r,Math.abs(e)&lt;M)<span class="cstat-no" title="statement not covered" >return e=t,t=n,Math.abs(e)&lt;M?[]:[-t/e];v</span></span>ar o=<span class="cstat-no" title="statement not covered" >t*t-4*e*n;<span class="cstat-no" title="statement not covered" ></span>return Math.abs(o)&lt;M?[-t/(2*e)]:o&gt;0?[(-t+Math.sqrt(o))/(2*e),(-t-Math.sqrt(o))/(2*e)]:[]}</span>var i,c=(3*e*n-t*t)/(3*e*e),a=(2*t*t*t-9*e*t*n+27*e*e*r)/(27*e*e*e);<span class="missing-if-branch" title="if path not taken" >I</span>if(Math.abs(c)&lt;M)<span class="cstat-no" title="statement not covered" >i=[Yt(-a)];e</span>lse <span class="missing-if-branch" title="if path not taken" >I</span>if(Math.abs(a)&lt;M)<span class="cstat-no" title="statement not covered" >i=[0].concat(c&lt;0?[Math.sqrt(-c),-Math.sqrt(-c)]:[]);e</span>lse{var u=a*a/4+c*c*c/27;<span class="missing-if-branch" title="if path not taken" >I</span>if(Math.abs(u)&lt;M)<span class="cstat-no" title="statement not covered" >i=[-1.5*a/c,3*a/c];e</span>lse <span class="missing-if-branch" title="if path not taken" >I</span>if(u&gt;0){var s=<span class="cstat-no" title="statement not covered" >Yt(-a/2-Math.sqrt(u));<span class="cstat-no" title="statement not covered" ></span>i=[s-c/(3*s)]}</span>else{var l=2*Math.sqrt(-c/3),v=Math.acos(3*a/c/l)/3,d=2*Math.PI/3;i=[l*Math.cos(v),l*Math.cos(v-d),l*Math.cos(v-2*d)]}}for(var p=0;p&lt;i.length;p+=1)i[p]-=t/(3*e);return i}(O*N*L,(O*I+j*N)*L-(k*S*S+w*S*N+E*N*N),(j*I+C*N)*L-(2*k*S*P+w*(S*I+P*N)+2*E*N*I),C*I*L-(k*P*P+w*P*I+E*I*I)),V=[];<span class="missing-if-branch" title="else path not taken" >E</span>if(null!=F&amp;&amp;F.length&gt;0)for(var G=0;G&lt;F.length;++G){if(void 0!==u&amp;&amp;void 0!==h)var B=F[G],D=h*B+m;else D=F[G],B=b;<span class="missing-if-branch" title="else path not taken" >E</span>if(D!=p){var R=-1*(B-d)/(D-p),U=(D*D-p*p+B*B-d*d)/(2*(D-p));V.push(v.line.fromPoints([0,U],[1,R]))}else{var Z=<span class="cstat-no" title="statement not covered" >(B+d)/2;<span class="cstat-no" title="statement not covered" ></span>V.push(v.line.fromPoints([Z,0],[0,1]))}</span>}return V}}),Jt=function get_unique_pair(e){for(var t=1;t&lt;e.length;t+=1)if(!at(e[0],e[t]))return[e[0],e[t]]},Kt=function convex_poly_line_intersect(e,t,n,r){var o=arguments.length&gt;4&amp;&amp;void 0!==arguments[4]?arguments[4]:<span class="branch-1 cbranch-no" title="branch not covered" >M,</span>i=t.map((function(e,t,n){return[e,n[(t+1)%n.length]]})).map((function(t){return e(n,r,t[0],t[1],o)})).filter((function(e){return null!=e}));switch(i.length){case 0:return;case 1:return[i];default:return Jt(i)||[i[0]]}},Qt=function poly_include_exclude_func(e,t,n,r,o){var i,c=Kt(e,t,n,r,o);switch(e){case st:i=ut;break;case lt:i=ft;break;case dt:i=vt;break;case ut:case ft:case vt:default:return c}var a=Kt(i,t,n,r,o);if(void 0!==a){var u=Jt(a);if(void 0===u)switch(e){case st:return;case lt:return nt(r,t,o)?a:void 0;case dt:return nt(n,t,o)||nt(r,t,o)?a:void 0}return nt(V.apply(void 0,_toConsumableArray(u)),t,o)?u:c}},en=function convex_poly_line_exclusive(e,t,n){var r=arguments.length&gt;3&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >void 0!==arguments[3]?<span class="branch-0 cbranch-no" title="branch not covered" ></span>arguments[3]:</span>M;return Qt(st,e,t,n,r)},tn=function convex_poly_ray_exclusive(e,t,n){var r=arguments.length&gt;3&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >void 0!==arguments[3]?<span class="branch-0 cbranch-no" title="branch not covered" ></span>arguments[3]:</span>M;return Qt(lt,e,t,n,r)},nn=function convex_poly_segment_exclusive(e,t,n){var r=arguments.length&gt;3&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >void 0!==arguments[3]?<span class="branch-0 cbranch-no" title="branch not covered" ></span>arguments[3]:</span>M;return Qt(dt,e,t,n,r)},rn=Object.freeze({__proto__:null,convex_poly_line_inclusive:function convex_poly_line_inclusive(e,t,n){var r=arguments.length&gt;3&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >void 0!==arguments[3]?<span class="branch-0 cbranch-no" title="branch not covered" ></span>arguments[3]:</span>M;return Qt(ut,e,t,n,r)},convex_poly_line_exclusive:en,convex_poly_ray_inclusive:function convex_poly_ray_inclusive(e,t,n){var r=arguments.length&gt;3&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >void 0!==arguments[3]?<span class="branch-0 cbranch-no" title="branch not covered" ></span>arguments[3]:</span>M;return Qt(ft,e,t,n,r)},convex_poly_ray_exclusive:tn,convex_poly_segment_inclusive:function convex_poly_segment_inclusive(e,t,n){var r=arguments.length&gt;3&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >void 0!==arguments[3]?<span class="branch-0 cbranch-no" title="branch not covered" ></span>arguments[3]:</span>M;return Qt(vt,e,t,n,r)},convex_poly_segment_exclusive:nn}),on=function convexPolyLine(e,t){return en(e,t.vector,t.origin)},cn=function convexPolyRay(e,t){return tn(e,t.vector,t.origin)},an=function convexPolySegment(e,t){return nn(e,t[0],t[1])},un=function lineFunc(e,t,n,r,o){return Xe(e.vector,e.origin,t.vector,t.origin,n,r,o)},sn={polygon:{line:on,ray:cn,segment:an},circle:{circle:Gt,line:Zt,ray:Xt,segment:$t},line:{polygon:function polygon(e,t){return on(t,e)},circle:function circle(e,t){return Zt(t,e)},line:function line(e,t,n){return un(e,t,Re,Re,n)},ray:function ray(e,t,n){return un(e,t,Re,Ue,n)},segment:function segment(e,t,n){return un(e,t,Re,Ze,n)}},ray:{polygon:function polygon(e,t){return cn(t,e)},circle:function circle(e,t){return Xt(t,e)},line:function line(e,t,n){return un(t,e,Re,Ue,n)},ray:function ray(e,t,n){return un(e,t,Ue,Ue,n)},segment:function segment(e,t,n){return un(e,t,Ue,Ze,n)}},segment:{polygon:function polygon(e,t){return an(t,e)},circle:function circle(e,t){return $t(t,e)},line:function line(e,t,n){return un(t,e,Re,Ze,n)},ray:function ray(e,t,n){return un(t,e,Ue,Ze,n)},segment:function segment(e,t,n){return un(e,t,Ze,Ze,n)}}},fn={polygon:"polygon",rect:"polygon",circle:"circle",line:"line",ray:"ray",segment:"segment"},ln=function intersect(e,t){var r,o=fn[n(e)],i=fn[n(t)];return(r=sn[o])[i].apply(r,arguments)},vn=Object.assign(Object.create(null),et,We,ct),dn=function get_unique_pair$1(e){for(var t=1;t&lt;e.length;t+=1)if(!at(e[0],e[t]))return[e[0],e[t]]},pn=function get_unique_points(e){for(var t=[],n=0;n&lt;e.length;n+=1){for(var r=!1,o=0;o&lt;t.length;o+=1)at(e[n],t[o])&amp;&amp;(r=!0);r||t.push(e[n])}return t},_n=function <span class="fstat-no" title="function not covered" >sortPointsAlongVector(</span>e,t){<span class="cstat-no" title="statement not covered" >return e.map((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return{point:e,d:e[0]*t[0]+e[1]*t[1]}}</span>)).sort((<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){<span class="cstat-no" title="statement not covered" >return e.d-t.d}</span>)).map((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return e.point}</span>))}</span>,gn=function collinear_check(e,t,n){var r=e.map((function(e,t,n){return[e,n[(t+1)%n.length]]})).map((function(e){return T.apply(void 0,_toConsumableArray(e))}));return r.map((function(e,n){return W(e,t)?n:void 0})).filter(S).map((function(t){return Ye(n,r[t],e[t])})).reduce((function(e,t){return e||t}),!1)},hn=function clip_intersections(e,t,n,r){var o=arguments.length&gt;4&amp;&amp;void 0!==arguments[4]?arguments[4]:<span class="branch-1 cbranch-no" title="branch not covered" >M;</span>return t.map((function(e,t,n){return[e,n[(t+1)%n.length]]})).map((function(t){return e(n,r,t[0],t[1],o)})).filter(S)},mn=function clip_line_in_convex_poly_exclusive(e,t,n){var r=arguments.length&gt;3&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >void 0!==arguments[3]?<span class="branch-0 cbranch-no" title="branch not covered" ></span>arguments[3]:</span>M,o=(hn(st,e,t,n,r),hn(ut,e,t,n,r));<span class="missing-if-branch" title="else path not taken" >E</span>if(void 0!==o){var i=dn(o);if(void 0!==i)return nt(V.apply(void 0,_toConsumableArray(i)),e,r)?i:void 0}},yn=function clip_ray_in_convex_poly_exclusive(e,t,n){var r=arguments.length&gt;3&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >void 0!==arguments[3]?<span class="branch-0 cbranch-no" title="branch not covered" ></span>arguments[3]:</span>M,o=(hn(lt,e,t,n,r),hn(ft,e,t,n,r));<span class="missing-if-branch" title="else path not taken" >E</span>if(void 0!==o){var i=dn(o);return void 0===i?nt(n,e,r)?[n,o[0]]:void 0:<span class="branch-1 cbranch-no" title="branch not covered" >nt(V.apply(void 0,_toConsumableArray(i)),e,r)?i:void 0}</span>},bn=function clip_segment_func(e,t,n){var r=arguments.length&gt;3&amp;&amp;void 0!==arguments[3]?arguments[3]:<span class="branch-1 cbranch-no" title="branch not covered" >M,</span>o=[t,n],i=o.map((function(t){return tt(t,e,r)}));if(!0===i[0]&amp;&amp;!0===i[1])return[_toConsumableArray(t),_toConsumableArray(n)];var c=hn(vt,e,t,n,r),a=pn(c);if(2===a.length)return a;<span class="missing-if-branch" title="if path not taken" >I</span>if(a.length&gt;2){var u=<span class="cstat-no" title="statement not covered" >_n(a,T(n,t));<span class="cstat-no" title="statement not covered" ></span>return[u[0],u[u.length-1]]}</span>if(c.length&gt;0){var s=o.map((function(t){return nt(t,e,r)}));if(!0===s[0])return[_toConsumableArray(t),c[0]];<span class="missing-if-branch" title="if path not taken" >I</span>if(!0===s[1])<span class="cstat-no" title="statement not covered" >return[_toConsumableArray(n),c[0]]}</span>},xn=function clip_segment_in_convex_poly_exclusive(e,t,n){var r=arguments.length&gt;3&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >void 0!==arguments[3]?<span class="branch-0 cbranch-no" title="branch not covered" ></span>arguments[3]:</span>M,o=T(n,t);if(!gn(e,o,t))return bn(e,t,n,r)},An=Object.freeze({__proto__:null,clip_line_in_convex_poly_inclusive:function clip_line_in_convex_poly_inclusive(e,t,n){var r=arguments.length&gt;3&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >void 0!==arguments[3]?<span class="branch-0 cbranch-no" title="branch not covered" ></span>arguments[3]:</span>M,o=hn(ut,e,t,n,r);switch(o.length){case 0:case 1:return;default:return dn(o)}},clip_line_in_convex_poly_exclusive:mn,clip_ray_in_convex_poly_inclusive:function clip_ray_in_convex_poly_inclusive(e,t,n){var r=arguments.length&gt;3&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >void 0!==arguments[3]?<span class="branch-0 cbranch-no" title="branch not covered" ></span>arguments[3]:</span>M,o=hn(ft,e,t,n,r);if(0!==o.length){tt(n,e);return dn(o)||[n,o[0]]}},clip_ray_in_convex_poly_exclusive:yn,clip_segment_in_convex_poly_inclusive:function clip_segment_in_convex_poly_inclusive(e,t,n){var r=arguments.length&gt;3&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >void 0!==arguments[3]?<span class="branch-0 cbranch-no" title="branch not covered" ></span>arguments[3]:</span>M;return bn(e,t,n,r)},clip_segment_in_convex_poly_exclusive:xn}),kn={preserve:{magnitude:function magnitude(){return P(this)},isEquivalent:function isEquivalent(){return Pe(this,he(arguments))},isParallel:function isParallel(){return W.apply(void 0,_toConsumableArray(o(this,he(arguments))))},dot:function dot(){return F.apply(void 0,_toConsumableArray(o(this,he(arguments))))},distanceTo:function distanceTo(){return Z.apply(void 0,_toConsumableArray(o(this,he(arguments))))}},vector:{copy:function copy(){return _toConsumableArray(this)},normalize:function normalize(){return I(this)},scale:function scale(){return L(this,arguments[0])},flip:function flip(){return X(this)},rotate90:function rotate90(){return $(this)},rotate270:function rotate270(){return H(this)},cross:function cross(){return R(r(3,this),r(3,he(arguments)))},transform:function transform(){return ne(Me(arguments),r(3,this))},add:function add(){return q(this,r(this.length,he(arguments)))},subtract:function subtract(){return T(this,r(this.length,he(arguments)))},rotateZ:function rotateZ(e,t){return ne(Me(m(e,t)),r(3,this))},lerp:function lerp(e,t){return B(this,r(this.length,he(e)),t)},midpoint:function midpoint(){return V.apply(void 0,_toConsumableArray(o(this,he(arguments))))},bisect:function bisect(){return yt(this,he(arguments))}}},wn={};Object.keys(kn.preserve).forEach((function(e){wn[e]=kn.preserve[e]})),Object.keys(kn.vector).forEach((function(e){wn[e]=function(){return v.vector.apply(v,_toConsumableArray(kn.vector[e].apply(this,arguments)))}}));var En={fromAngle:function fromAngle(e){return v.vector(Math.cos(e),Math.sin(e))},fromAngleDegrees:function fromAngleDegrees(e){return v.vector.fromAngle(e*w)}},Mn={vector:{P:Array.prototype,A:function VectorArgs(){var e=this;he(arguments).forEach((function(t){return e.push(t)}))},G:{x:function x(){return this[0]},y:function y(){return this[1]},z:function z(){return this[2]}},M:wn,S:En}},On={};On.prototype=Object.create(Object.prototype),On.prototype.constructor=On,On.prototype.isParallel=function(){var e=o(this.vector,be.apply(void 0,arguments).vector);return W.apply(void 0,_toConsumableArray(e))},On.prototype.isDegenerate=function(){var e=arguments.length&gt;0&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >void 0!==arguments[0]?<span class="branch-0 cbranch-no" title="branch not covered" ></span>arguments[0]:</span>M;return Y(this.vector,e)},On.prototype.reflectionMatrix=function(){return v.matrix(pe(this.vector,this.origin))},On.prototype.nearestPoint=function(){var e=he(arguments);return v.vector(qe(this.vector,this.origin,e,this.clip_function))},On.prototype.transform=function(){var e=this.dimension,t=re(Me(arguments),r(3,this.vector),r(3,this.origin));return this.constructor(r(e,t.vector),r(e,t.origin))},On.prototype.translate=<span class="fstat-no" title="function not covered" >fu</span>nction(){var e=<span class="cstat-no" title="statement not covered" >q.apply(void 0,_toConsumableArray(o(this.origin,he(arguments))));<span class="cstat-no" title="statement not covered" ></span>return this.constructor(this.vector,e)}</span>,On.prototype.intersect=function(e){return ln(this,e)},On.prototype.bisect=function(){var e=be(arguments);return bt(this.vector,this.origin,e.vector,e.origin)},Object.defineProperty(On.prototype,"dimension",{get:function get(){return[this.vector,this.origin].map((function(e){return e.length})).reduce((function(e,t){return Math.max(e,t)}),0)}});var jn={fromPoints:function fromPoints(){var e=me(arguments);return this.constructor({vector:T(e[1],e[0]),origin:e[0]})},fromAngle:function <span class="fstat-no" title="function not covered" >fromAngle(</span>){var e=<span class="cstat-no" title="statement not covered" >arguments[0]||0;<span class="cstat-no" title="statement not covered" ></span>return this.constructor({vector:[Math.cos(e),Math.sin(e)],origin:[0,0]})}</span>,perpendicularBisector:function perpendicularBisector(){var e=me(arguments);return this.constructor({vector:$(T(e[1],e[0])),origin:G(e[0],e[1])})}},Cn={line:{P:On.prototype,A:function A(){var e=be.apply(void 0,arguments);this.vector=v.vector(e.vector),this.origin=v.vector(r(this.vector.length,e.origin))},G:{length:function length(){return 1/0}},M:{clip_function:function clip_function(e){return e},svgPath:function svgPath(){var e=arguments.length&gt;0&amp;&amp;void 0!==arguments[0]?arguments[0]:2e4,t=this.origin.add(this.vector.scale(-e/2)),n=this.vector.scale(e);return"M".concat(t[0]," ").concat(t[1],"l").concat(n[0]," ").concat(n[1])}},S:jn}},Sn={ray:{P:On.prototype,A:function A(){var e=be.apply(void 0,arguments);this.vector=v.vector(e.vector),this.origin=v.vector(r(this.vector.length,e.origin))},G:{length:function length(){return 1/0}},M:{flip:function flip(){return v.ray(X(this.vector),this.origin)},scale:function scale(e){return v.ray(this.vector.scale(e),this.origin)},normalize:function normalize(){return v.ray(this.vector.normalize(),this.origin)},clip_function:ze,svgPath:function svgPath(){var e=arguments.length&gt;0&amp;&amp;void 0!==arguments[0]?arguments[0]:1e4,t=this.vector.scale(e);return"M".concat(this.origin[0]," ").concat(this.origin[1],"l").concat(t[0]," ").concat(t[1])}},S:jn}},Pn={segment:{P:On.prototype,A:function A(){var e=ye.apply(void 0,arguments);this.points=[v.vector(e[0]),v.vector(e[1])],this.vector=this.points[1].subtract(this.points[0]),this.origin=this.points[0]},G:{0:function _(){return this.points[0]},1:function _(){return this.points[1]},length:function length(){return this.vector.magnitude()}},M:{clip_function:Ie,transform:function transform(){for(var e=this.points[0].length,t=arguments.length,n=new Array(t),o=0;o&lt;t;o++)n[o]=arguments[o];var i=Me(n),c=this.points.map((function(e){return r(3,e)})).map((function(e){return ne(i,e)})).map((function(t){return r(e,t)}));return v.segment(c)},translate:function <span class="fstat-no" title="function not covered" >translate(</span>){var translate=<span class="cstat-no" title="statement not covered" >get_vector(arguments),</span>e=<span class="cstat-no" title="statement not covered" >this.points.map((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return add.apply(void 0,_toConsumableArray(resize_up(e,translate)))}</span>));<span class="cstat-no" title="statement not covered" ></span>return v.segment(e)}</span>,midpoint:function midpoint(){return v.vector(G(this.points[0],this.points[1]))},svgPath:function svgPath(){var e=this.points.map((function(e){return"".concat(e[0]," ").concat(e[1])}));return["M","L"].map((function(t,n){return"".concat(t).concat(e[n])})).join("")}},S:{fromPoints:function fromPoints(){return this.constructor.apply(this,arguments)}}}},Nn=function pointOnEllipse(e,t,n,r,o,i){var c=Math.cos(o),a=Math.sin(o),u=Math.cos(i),s=Math.sin(i);return[e+c*n*u+-a*r*s,t+a*n*u+c*r*s]},zn=function pathInfo(e,t,n,r,o,i,c){var a=i;if(a&lt;0&amp;&amp;!isNaN(a))for(;a&lt;0;)a+=2*Math.PI;var u=c&gt;2*Math.PI?<span class="branch-0 cbranch-no" title="branch not covered" >2*Math.PI:</span>c,s=Nn(e,t,n,r,o,a),l=Nn(e,t,n,r,o,a+u/2),v=Nn(e,t,n,r,o,a+u),d=u/2&gt;Math.PI?<span class="branch-0 cbranch-no" title="branch not covered" >1:</span>0,p=u/2&gt;0?1:<span class="branch-1 cbranch-no" title="branch not covered" >0;</span>return{x1:s[0],y1:s[1],x2:l[0],y2:l[1],x3:v[0],y3:v[1],fa:d,fs:p}},In=function cln(e){return c(e,4)},Ln=function ellipticalArcTo(e,t,n,r,o,i,c){return"A".concat(In(e)," ").concat(In(t)," ").concat(In(n)," ").concat(In(r)," ").concat(In(o)," ").concat(In(i)," ").concat(In(c))},qn={circle:{A:function CircleArgs(){var e=me(arguments),t=s(arguments).filter((function(e){return"number"==typeof e}));if(2===arguments.length)1===e[1].length?(this.radius=e[1][0],this.origin=v.vector.apply(v,_toConsumableArray(e[0]))):1===e[0].length?(this.radius=e[0][0],this.origin=v.vector.apply(v,_toConsumableArray(e[1]))):e[0].length&gt;1&amp;&amp;e[1].length&gt;1&amp;&amp;(this.radius=U.apply(void 0,_toConsumableArray(e)),this.origin=v.vector.apply(v,_toConsumableArray(e[0])));else switch(t.length){case 0:this.radius=1,this.origin=v.vector(0,0,0);break;case 1:this.radius=t[0],this.origin=v.vector(0,0,0);break;default:this.radius=t.pop(),this.origin=v.vector.apply(v,_toConsumableArray(t))}},G:{x:function x(){return this.origin[0]},y:function y(){return this.origin[1]},z:function z(){return this.origin[2]}},M:{nearestPoint:function nearestPoint(){return v.vector(Fe(this.radius,this.origin,he(arguments)))},intersect:function intersect(e){return ln(this,e)},svgPath:function svgPath(){var e=arguments.length&gt;0&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >void 0!==arguments[0]?<span class="branch-0 cbranch-no" title="branch not covered" ></span>arguments[0]:</span>0,t=arguments.length&gt;1&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >void 0!==arguments[1]?<span class="branch-0 cbranch-no" title="branch not covered" ></span>arguments[1]:</span>2*Math.PI,n=zn(this.origin[0],this.origin[1],this.radius,this.radius,0,e,t),r=Ln(this.radius,this.radius,0,n.fa,n.fs,n.x2,n.y2),o=Ln(this.radius,this.radius,0,n.fa,n.fs,n.x3,n.y3);return"M".concat(n.x1," ").concat(n.y1).concat(r).concat(o)},points:function points(){var e=this,t=arguments.length&gt;0&amp;&amp;void 0!==arguments[0]?arguments[0]:128;return Array.from(Array(t)).map((function(e,n){return 2*Math.PI/t*n})).map((function(t){return[e.origin[0]+e.radius*Math.cos(t),e.origin[1]+e.radius*Math.sin(t)]}))},polygon:function polygon(){return v.polygon(this.points(arguments[0]))},segments:function segments(){var e=this.points(arguments[0]);return e.map((function(t,n){var r=(n+1)%e.length;return[t,e[r]]}))}},S:{fromPoints:function fromPoints(){if(3===arguments.length){var e=wt.apply(void 0,arguments);return this.constructor(e.radius,e.origin)}return this.constructor.apply(this,arguments)},fromThreePoints:function fromThreePoints(){var e=wt.apply(void 0,arguments);return this.constructor(e.radius,e.origin)}}}},Tn=function getFoci(e,t,n,r){var o=t&gt;n,i=o?Math.pow(t,2)-Math.pow(n,2):Math.pow(n,2)-Math.pow(t,2),c=Math.sqrt(i),a=o?Math.cos(r):Math.sin(r),u=o?Math.sin(r):Math.cos(r);return[v.vector(e[0]+c*a,e[1]+c*u),v.vector(e[0]-c*a,e[1]-c*u)]},Fn={ellipse:{A:function A(){var e=s(arguments).filter((function(e){return!isNaN(e)})),t=r(5,e);this.rx=t[0],this.ry=t[1],this.origin=v.vector(t[2],t[3]),this.spin=t[4],this.foci=Tn(this.origin,this.rx,this.ry,this.spin)},G:{x:function x(){return this.origin[0]},y:function y(){return this.origin[1]}},M:{svgPath:function svgPath(){var e=arguments.length&gt;0&amp;&amp;void 0!==arguments[0]?arguments[0]:0,t=arguments.length&gt;1&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >void 0!==arguments[1]?<span class="branch-0 cbranch-no" title="branch not covered" ></span>arguments[1]:</span>2*Math.PI,n=zn(this.origin[0],this.origin[1],this.rx,this.ry,this.spin,e,t),r=Ln(this.rx,this.ry,this.spin/Math.PI*180,n.fa,n.fs,n.x2,n.y2),o=Ln(this.rx,this.ry,this.spin/Math.PI*180,n.fa,n.fs,n.x3,n.y3);return"M".concat(n.x1," ").concat(n.y1).concat(r).concat(o)},points:function points(){var e=this,t=arguments.length&gt;0&amp;&amp;void 0!==arguments[0]?arguments[0]:128;return Array.from(Array(t)).map((function(e,n){return 2*Math.PI/t*n})).map((function(t){return Nn(e.origin.x,e.origin.y,e.rx,e.ry,e.spin,t)}))},polygon:function polygon(){return v.polygon(this.points(arguments[0]))},segments:function segments(){var e=this.points(arguments[0]);return e.map((function(t,n){var r=(n+1)%e.length;return[t,e[r]]}))}},S:{}}},Vn=function makeClip(e){return void 0===e?void 0:v.segment(e)},Gn={area:function area(){return Et(this)},centroid:function centroid(){return v.vector(Mt(this))},enclosingRectangle:function enclosingRectangle(){return v.rect(Ot(this))},contains:function contains(){return rt(he(arguments),this)},scale:function scale(e){var t=arguments.length&gt;1&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >void 0!==arguments[1]?<span class="branch-0 cbranch-no" title="branch not covered" ></span>arguments[1]:</span>Mt(this),n=this.map((function(e){return[0,1].map((function(n,r){return e[r]-t[r]}))})).map((function(n){return n.map((function(r,o){return t[o]+n[o]*e}))}));return this.constructor.fromPoints(n)},rotate:function rotate(e){var t=arguments.length&gt;1&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >void 0!==arguments[1]?<span class="branch-0 cbranch-no" title="branch not covered" ></span>arguments[1]:</span>Mt(this),n=this.map((function(n){var r=[n[0]-t[0],n[1]-t[1]],o=Math.sqrt(Math.pow(r[0],2)+Math.pow(r[1],2)),i=Math.atan2(r[1],r[0]);return[t[0]+Math.cos(i+e)*o,t[1]+Math.sin(i+e)*o]}));return v.polygon(n)},translate:function translate(){var e=he.apply(void 0,arguments),t=this.map((function(t){return t.map((function(t,n){return t+e[n]}))}));return this.constructor.fromPoints(t)},transform:function transform(){var e=Me.apply(void 0,arguments),t=this.map((function(t){return ne(e,r(3,t))}));return v.polygon(t)},nearest:function nearest(){var e=he.apply(void 0,arguments),t=Te(this,e);return void 0===t?<span class="branch-0 cbranch-no" title="branch not covered" >void 0:</span>Object.assign(t,{edge:this.sides[t.i]})},overlaps:function overlaps(){var e=u(arguments);return it(this,e)},split:function split(){var e=be.apply(void 0,arguments),t=this.isConvex?zt:<span class="branch-1 cbranch-no" title="branch not covered" >Nt;</span>return t(this,e.vector,e.origin).map((function(e){return v.polygon(e)}))},intersectLine:function intersectLine(){var e=be.apply(void 0,arguments);return en(this,e.vector,e.origin)},intersectRay:function intersectRay(){var e=be.apply(void 0,arguments);return tn(this,e.vector,e.origin)},intersectSegment:function intersectSegment(){var e=ye.apply(void 0,arguments);return nn(this,e[0],e[1])},clipLine:function clipLine(){var e=be.apply(void 0,arguments),t=mn(this,e.vector,e.origin);return Vn(t)},clipRay:function clipRay(){var e=be.apply(void 0,arguments),t=yn(this,e.vector,e.origin);return Vn(t)},clipSegment:function clipSegment(){var e=ye.apply(void 0,arguments),t=xn(this,e[0],e[1]);return Vn(t)},svgPath:function svgPath(){var e=Array(this.length).fill("L");return e[0]="M","".concat(this.map((function(t,n){return"".concat(e[n]).concat(t[0]," ").concat(t[1])})).join(""),"z")},intersect:function intersect(e){return ln(this,e)}},Bn={};Bn.prototype=Object.create(Array.prototype),Bn.prototype.constructor=Bn,Object.keys(Gn).forEach((function(e){Bn.prototype[e]=Gn[e]}));var Dn=function rectToPoints(e){return[[e.x,e.y],[e.x+e.width,e.y],[e.x+e.width,e.y+e.height],[e.x,e.y+e.height]]},Rn={rect:{P:Bn.prototype,A:function A(){var e=ke.apply(void 0,arguments);this.width=e.width,this.height=e.height,this.origin=v.vector(e.x,e.y),this.push.apply(this,_toConsumableArray(Dn(this)))},G:{x:function x(){return this.origin[0]},y:function y(){return this.origin[1]},center:function center(){return v.vector(this.origin[0]+this.width/2,this.origin[1]+this.height/2)}},M:{area:function area(){return this.width*this.height},segments:function segments(){return function rectToSides(e){return[[[e.x,e.y],[e.x+e.width,e.y]],[[e.x+e.width,e.y],[e.x+e.width,e.y+e.height]],[[e.x+e.width,e.y+e.height],[e.x,e.y+e.height]],[[e.x,e.y+e.height],[e.x,e.y]]]}(this)},svgPath:function svgPath(){return"M".concat(this.origin.join(" "),"h").concat(this.width,"v").concat(this.height,"h").concat(-this.width,"Z")}},S:{fromPoints:function fromPoints(){return v.rect(Ot(me(arguments)))}}}},Un={polygon:{P:Bn.prototype,A:function A(){this.push.apply(this,_toConsumableArray(u(arguments))),this.sides=this.map((function(e,t,n){return[e,n[(t+1)%n.length]]})),this.vectors=this.sides.map((function(e){return T(e[1],e[0])}))},G:{isConvex:function isConvex(){return!0},points:function points(){return this}},M:{segments:function segments(){return this.sides},straightSkeleton:function <span class="fstat-no" title="function not covered" >straightSkeleton(</span>){<span class="cstat-no" title="statement not covered" >return qt(this)}</span>},S:{fromPoints:function fromPoints(){return this.constructor.apply(this,arguments)},regularPolygon:function regularPolygon(){return this.constructor(St.apply(void 0,arguments))},convexHull:function convexHull(){return this.constructor(It.apply(void 0,arguments))}}}},Zn=function assign(e,t){for(var n=0;n&lt;12;n+=1)e[n]=t[n];return e},Xn={matrix:{P:Array.prototype,A:function A(){var e=this;Me(arguments).forEach((function(t){return e.push(t)}))},G:{},M:{copy:function copy(){return v.matrix.apply(v,_toConsumableArray(Array.from(this)))},set:function set(){return Zn(this,Me(arguments))},isIdentity:function isIdentity(){return te(this)},multiply:function multiply(e){return Zn(this,oe(this,e))},determinant:function determinant(){return ie(this)},inverse:function inverse(){return Zn(this,ce(this))},translate:function translate(e,t,n){return Zn(this,oe(this,ae(e,t,n)))},rotateX:function rotateX(e){return Zn(this,oe(this,se(e)))},rotateY:function rotateY(e){return Zn(this,oe(this,fe(e)))},rotateZ:function rotateZ(e){return Zn(this,oe(this,le(e)))},rotate:function rotate(e,t,n){var r=ve(e,t,n);return Zn(this,oe(this,r))},scale:function scale(e){return Zn(this,oe(this,de(e)))},reflectZ:function reflectZ(e,t){var n=pe(e,t);return Zn(this,oe(this,n))},transform:function transform(){for(var e=arguments.length,t=new Array(e),n=0;n&lt;e;n++)t[n]=arguments[n];return v.vector(ne(this,r(3,he(t))))},transformVector:function transformVector(e){return v.vector(ne(this,r(3,he(e))))},transformLine:function transformLine(){for(var e=arguments.length,t=new Array(e),n=0;n&lt;e;n++)t[n]=arguments[n];var r=be(t);return v.line(re(this,r.vector,r.origin))}},S:{}}},$n=function invert_order_array(e){var t=[];return e.forEach((function(e,n){return t[e]=n})),t},Hn={junction:{A:function A(){var e=me(arguments).map((function(e){return v.vector(e)})),t=e.map((function(e){return Math.atan2(e[1],e[0])})),n=xt.apply(void 0,_toConsumableArray(t));this.vectors=n.map((function(t){return e[t]})),this.radians=n.map((function(e){return t[e]})),this.order=$n(n)},G:{sectors:function sectors(){return this.radians.map((function(e,t,n){return[e,n[(t+1)%n.length]]})).map((function(e){return _t(e[0],e[1])}))}},M:{alternatingAngleSum:function alternatingAngleSum(){return J(this.sectors)}},S:{fromRadians:function fromRadians(){var e=he(arguments);return this.constructor(e.map((function(e){return[Math.cos(e),Math.sin(e)]})))}}}},Yn=Object.assign({},Mn,Cn,Sn,Pn,qn,Fn,Rn,Un,Xn,Hn),Wn=function create(e,t){var n=Object.create(Yn[e].proto);return Yn[e].A.apply(n,t),n};Object.assign(v,{vector:function vector(){return Wn("vector",arguments)},circle:function circle(){return Wn("circle",arguments)},ellipse:function ellipse(){return Wn("ellipse",arguments)},rect:function rect(){return Wn("rect",arguments)},polygon:function polygon(){return Wn("polygon",arguments)},line:function line(){return Wn("line",arguments)},ray:function ray(){return Wn("ray",arguments)},segment:function segment(){return Wn("segment",arguments)},matrix:function matrix(){return Wn("matrix",arguments)},junction:function junction(){return Wn("junction",arguments)}}),Object.keys(Yn).forEach((function(e){var t={};t.prototype=null!=Yn[e].P?Object.create(Yn[e].P):Object.create(Object.prototype),t.prototype.constructor=t,v[e].prototype=t.prototype,v[e].prototype.constructor=v[e],Object.keys(Yn[e].G).forEach((function(n){return Object.defineProperty(t.prototype,n,{get:Yn[e].G[n]})})),Object.keys(Yn[e].M).forEach((function(n){return Object.defineProperty(t.prototype,n,{value:Yn[e].M[n]})})),Object.keys(Yn[e].S).forEach((function(t){return Object.defineProperty(v[e],t,{value:Yn[e].S[t].bind(v[e].prototype)})})),Yn[e].proto=t.prototype}));var Jn=v;Jn.core=Object.assign(Object.create(null),O,K,Ne,Tt,kt,b,_e,Ve,Wt,vn,Oe,l,Ht,$e,rn,An,{intersect_line_seg_include:ut,intersect_line_seg_exclude:st,intersect_ray_seg_include:ft,intersect_ray_seg_exclude:lt,intersect_seg_seg_include:vt,intersect_seg_seg_exclude:dt}),Jn.typeof=n,Jn.intersect=ln;var Kn=Object.create(null),Qn=1.1,er="Rabbit Ear",tr={file:["file_spec","file_creator","file_author","file_title","file_description","file_classes","file_frames"],frame:["frame_author","frame_title","frame_description","frame_attributes","frame_classes","frame_unit","frame_parent","frame_inherit"],graph:["vertices_coords","vertices_vertices","vertices_faces","edges_vertices","edges_faces","edges_assignment","edges_foldAngle","edges_length","faces_vertices","faces_edges","vertices_edges","edges_edges","faces_faces"],orders:["edgeOrders","faceOrders"]},nr=Object.freeze([].concat(tr.file).concat(tr.frame).concat(tr.graph).concat(tr.orders)),rr="vertices",or="edges",ir="faces",cr="vertices_coords",ar="edges_assignment",ur="edges_foldAngle",sr={vertices:"vertex",edges:"edge",faces:"face"},fr={M:-180,m:-180,V:180,v:180,B:0,b:0,F:0,f:0,U:0,u:0},lr=function edge_assignment_to_foldAngle(e){return fr[e]||0},vr=function edge_foldAngle_to_assignment(e){return e&gt;0?"V":e&lt;0?"M":"U"},dr=function filter_keys_with_suffix(e,t){return Object.keys(e).map((function(e){return e.substring(e.length-t.length,e.length)===t?e:void 0})).filter((function(e){return void 0!==e}))},pr=function filter_keys_with_prefix(e,t){return Object.keys(e).map((function(e){return e.substring(0,t.length)===t?e:void 0})).filter((function(e){return void 0!==e}))},_r=function get_graph_keys_with_prefix(e,t){return pr(e,"".concat(t,"_"))},gr=function get_graph_keys_with_suffix(e,t){return dr(e,"_".concat(t))},hr=function transpose_graph_arrays(e,t){var n=_r(e,t);if(0===n.length)return[];var r=Math.max.apply(Math,_toConsumableArray(n.map((function(t){return e[t].length})))),o=Array.from(Array(r)).map((function(){return{}}));return n.forEach((function(t){return o.forEach((function(n,r){o[r][t]=e[t][r]}))})),o},mr=function transpose_graph_array_at_index(e,t,n){var r=_r(e,t);if(0!==r.length){var o={};return r.forEach((function(t){o[t]=e[t][n]})),o}},yr=function fold_object_certainty(e){return"object"!==_typeof(e)||null===e?<span class="branch-0 cbranch-no" title="branch not covered" >0:</span>nr.filter((function(t){return e[t]})).length},br=Object.freeze({__proto__:null,edges_assignment_degrees:fr,edges_assignment_names:{M:"mountain",m:"mountain",V:"valley",v:"valley",B:"boundary",b:"boundary",F:"mark",f:"mark",U:"unassigned",u:"unassigned"},edge_assignment_to_foldAngle:lr,edge_foldAngle_to_assignment:vr,filter_keys_with_suffix:dr,filter_keys_with_prefix:pr,get_graph_keys_with_prefix:_r,get_graph_keys_with_suffix:gr,transpose_graph_arrays:hr,transpose_graph_array_at_index:mr,fold_object_certainty:yr}),xr=function implied_count(e,t,n){return Math.max(function max_num_in_array_in_arrays(e){var t=-1;return e.filter((function(e){return void 0!==e})).forEach((function(e){return e.forEach((function(e){return e.forEach((function(e){e&gt;t&amp;&amp;(t=e)}))}))})),t}(gr(e,t).map((function(t){return e[t]}))),e[n]?function max_num_in_orders(e){var t=-1;return e.forEach((function(e){e[0]&gt;t&amp;&amp;(t=e[0]),e[1]&gt;t&amp;&amp;(t=e[1])})),t}(e[n]):-1)+1};xr.vertices=function(e){return xr(e,"vertices")},xr.edges=function(e){return xr(e,"edges","edgeOrders")},xr.faces=function(e){return xr(e,"faces","faceOrders")};var Ar=function planar_vertex_walk(e){var t=e.vertices_vertices,n={vertices_vertices:t,vertices_sectors:e.vertices_sectors},r={};return t.map((function(e,t){return e.map((function(e){return function counter_clockwise_walk(e,t,n){for(var r=e.vertices_vertices,o=e.vertices_sectors,i=arguments.length&gt;3&amp;&amp;void 0!==arguments[3]?arguments[3]:<span class="branch-1 cbranch-no" title="branch not covered" >{},</span>c={},a={vertices:[t],edges:[],angles:[]},u=t,s=n;;){var l=r[s],v=(l.indexOf(u)+l.length-1)%l.length,d=l[v],p="".concat(s," ").concat(d);if(c[p])return Object.assign(i,c),a.vertices.pop(),a;if(c[p]=!0,i[p])return;a.vertices.push(s),a.edges.push(p),a.angles.push(o[s][v]),u=s,s=d}}(n,t,e,r)})).filter((function(e){return void 0!==e}))})).reduce((function(e,t){return e.concat(t)}),[])},kr=Object.freeze({__proto__:null,planar_vertex_walk:Ar}),wr=function sort_vertices_counter_clockwise(e,t,n){var r=e.vertices_coords;return t.map((function(e){return r[e]})).map((function(e){return Jn.core.subtract(e,r[n])})).map((function(e){return Math.atan2(e[1],e[0])})).map((function(e){return e&gt;-Jn.core.EPSILON?e:e+2*Math.PI})).map((function(e,t){return{a:e,i:t}})).sort((function(e,t){return e.a-t.a})).map((function(e){return e.i})).map((function(e){return t[e]}))},Er=function sort_vertices_along_vector(e,t,n){var r=e.vertices_coords;return t.map((function(e){return{i:e,d:Jn.core.dot(r[e],n)}})).sort((function(e,t){return e.d-t.d})).map((function(e){return e.i}))},Mr=Object.freeze({__proto__:null,sort_vertices_counter_clockwise:wr,sort_vertices_along_vector:Er}),Or=function make_vertices_edges(e){var t=e.edges_vertices,n=[];return t.forEach((function(e,t){return e.forEach((function(e){void 0===n[e]&amp;&amp;(n[e]=[]),n[e].push(t)}))})),n},jr=function make_vertices_edges_sorted(e){var t=e.edges_vertices,n=e.vertices_vertices,r=Nr({edges_vertices:t});return n.map((function(e,t){return e.map((function(e){return r["".concat(t," ").concat(e)]}))}))},Cr=function make_vertices_vertices(e){var t=e.vertices_coords,n=e.vertices_edges,r=e.edges_vertices;n||(n=Or({edges_vertices:r}));var o=n.map((function(e,t){return e.map((function(e){return r[e].filter((function(e){return e!==t}))})).reduce((function(e,t){return e.concat(t)}),[])}));return void 0===t?<span class="branch-0 cbranch-no" title="branch not covered" >o:</span>o.map((function(e,n){return wr({vertices_coords:t},e,n)}))},Sr=function make_vertices_faces(e){var t=e.faces_vertices,n=Array.from(Array(xr.vertices({faces_vertices:t}))).map((function(){return[]}));return t.forEach((function(e,t){var r=[];e.forEach((function(e){r[e]=t})),r.forEach((function(e,t){return n[t].push(e)}))})),n},Pr=function make_vertices_faces_sorted(e){var t=e.vertices_vertices,n=e.faces_vertices,r=Ir({faces_vertices:n});return t.map((function(e,t){return e.map((function(e,n,r){return[r[(n+1)%r.length],t,e].join(" ")}))})).map((function(e){return e.map((function(e){return r[e]})).filter((function(e){return void 0!==e}))}))},Nr=function make_vertices_to_edge_bidirectional(e){var t=e.edges_vertices,n={};return t.map((function(e){return e.join(" ")})).forEach((function(e,t){n[e]=t})),t.map((function(e){return"".concat(e[1]," ").concat(e[0])})).forEach((function(e,t){n[e]=t})),n},zr=function make_vertices_to_edge(e){var t=e.edges_vertices,n={};return t.map((function(e){return e.join(" ")})).forEach((function(e,t){n[e]=t})),n},Ir=function make_vertices_to_face(e){var t=e.faces_vertices,n={};return t.forEach((function(e,t){return e.map((function(t,n){return[0,1,2].map((function(t){return(n+t)%e.length})).map((function(t){return e[t]})).join(" ")})).forEach((function(e){n[e]=t}))})),n},Lr=function make_vertices_vertices_vector(e){var t=e.vertices_coords,n=e.vertices_vertices,r=e.edges_vertices,o=e.edges_vector;o||(o=Br({vertices_coords:t,edges_vertices:r}));var i=zr({edges_vertices:r});return n.map((function(e,t){return n[t].map((function(e){var n=i["".concat(t," ").concat(e)],r=i["".concat(e," ").concat(t)];return void 0!==n?o[n]:void 0!==r?Jn.core.flip(o[r]):<span class="branch-1 cbranch-no" title="branch not covered" >void 0}</span>))}))},qr=function make_vertices_sectors(e){var t=e.vertices_coords,n=e.vertices_vertices,r=e.edges_vertices,o=e.edges_vector;return Lr({vertices_coords:t,vertices_vertices:n,edges_vertices:r,edges_vector:o}).map((function(e){var t;return 1===e.length?[Jn.core.TWO_PI]:(t=Jn.core).interior_angles.apply(t,_toConsumableArray(e))}))},Tr=function make_vertices_coords_folded(e,t){var n=e.vertices_coords,r=e.vertices_faces,o=e.edges_vertices,i=e.edges_foldAngle,c=e.edges_assignment,a=e.faces_vertices,u=e.faces_faces,s=e.faces_matrix;s&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >void 0===t|</span>|(s=Hr({vertices_coords:n,edges_vertices:o,edges_foldAngle:i,edges_assignment:c,faces_vertices:a,faces_faces:u},t)),r||(r=Sr({faces_vertices:a}));var l=r.map((function(e){return e[0]})).map((function(e){return void 0===e?<span class="branch-0 cbranch-no" title="branch not covered" >Jn.core.identity3x4:</span>s[e]}));return n.map((function(e){return Jn.core.resize(3,e)})).map((function(e,t){return Jn.core.multiply_matrix3_vector3(l[t],e)}))},Fr=function make_edges_faces(e){var t=e.faces_edges,n=Array.from(Array(xr.edges({faces_edges:t}))).map((function(){return[]}));return t.forEach((function(e,t){var r=[];e.forEach((function(e){r[e]=t})),r.forEach((function(e,t){return n[t].push(e)}))})),n},Vr={M:-180,m:-180,V:180,v:180},Gr=function make_edges_foldAngle(e){return e.edges_assignment.map((function(e){return Vr[e]||0}))},Br=function make_edges_vector(e){var t=e.vertices_coords;return e.edges_vertices.map((function(e){return e.map((function(e){return t[e]}))})).map((function(e){return Jn.core.subtract(e[1],e[0])}))},Dr=function make_edges_coords_min_max(e){var t=e.vertices_coords,n=e.edges_vertices,r=e.edges_coords;return r||(r=n.map((function(e){return e.map((function(e){return t[e]}))}))),r.map((function(e){var t=e[0].map((function(){return 1/0})),n=e[0].map((function(){return-1/0}));return e.forEach((function(e){return e.forEach((function(e,r){e&lt;t[r]&amp;&amp;(t[r]=e),e&gt;n[r]&amp;&amp;(n[r]=e)}))})),[t,n]}))},Rr=function make_edges_coords_min_max_inclusive(e){var t=arguments.length&gt;1&amp;&amp;void 0!==arguments[1]?arguments[1]:Jn.core.EPSILON,n=[-t,+t];return Dr(e).map((function(e){return e.map((function(e,t){return e.map((function(e){return e+n[t]}))}))}))},Ur=function make_planar_faces(e){var t=e.vertices_coords,n=e.vertices_vertices,r=e.vertices_edges,o=e.vertices_sectors,i=e.edges_vertices,c=e.edges_vector;n||(n=Cr({vertices_coords:t,edges_vertices:i,vertices_edges:r})),o||(o=qr({vertices_coords:t,vertices_vertices:n,edges_vertices:i,edges_vector:c}));var a=Nr({edges_vertices:i});return Ar({vertices_vertices:n,vertices_sectors:o}).map((function(e){return _objectSpread2(_objectSpread2({},e),{},{edges:e.edges.map((function(e){return a[e]}))})})).filter((function(e){return e.angles.map((function(e){return Math.PI-e})).reduce((function(e,t){return e+t}),0)&gt;0}))},Zr=function make_faces_faces(e){var t=e.faces_vertices,n=t.map((function(){return[]})),r={};return t.forEach((function(e,t){var o=e.length;e.forEach((function(e,i,c){var a=c[(i+1)%o];if(a&lt;e){var u=[a,e];e=u[0],a=u[1]}var s="".concat(e," ").concat(a);if(s in r){var l=r[s];n[t].push(l),n[l].push(t)}else r[s]=t}))})),n},Xr=function get_face_face_shared_vertices(e,t){var n={};t.forEach((function(e){n[e]=!0}));for(var r=e.map((function(e){return!!n[e]})),o=[],i=r.indexOf(!1),c=i+1;c&lt;r.length;c+=1)r[c]&amp;&amp;o.push(e[c]);for(var a=0;a&lt;i;a+=1)r[a]&amp;&amp;o.push(e[a]);return o},$r=function make_face_spanning_tree(e){var t=e.faces_vertices,n=e.faces_faces,r=arguments.length&gt;1&amp;&amp;void 0!==arguments[1]?arguments[1]:0;if(n||(n=Zr({faces_vertices:t})),0===n.length)return[];var o=[[{face:r}]],i={};i[r]=!0;var c=function _loop(){var e=o[o.length-1].map((function(e){return n[e.face].map((function(t){return{face:t,parent:e.face}}))})).reduce((function(e,t){return e.concat(t)}),[]),r={};e.forEach((function(e,t){i[e.face]&amp;&amp;(r[t]=!0),i[e.face]=!0}));var c=e.filter((function(e,t){return!r[t]}));c.map((function(e){return Xr(t[e.face],t[e.parent])})).forEach((function(e,t){c[t].edge_vertices=e.slice(0,2)})),o[o.length]=c};do{c()}while(o[o.length-1].length&gt;0);return o.length&gt;0&amp;&amp;0===o[o.length-1].length&amp;&amp;o.pop(),o},Hr=function make_faces_matrix(e){var t=e.vertices_coords,n=e.edges_vertices,r=e.edges_foldAngle,o=e.edges_assignment,i=e.faces_vertices,c=e.faces_faces,a=arguments.length&gt;1&amp;&amp;void 0!==arguments[1]?arguments[1]:0;r||(r=o?Gr({edges_assignment:o}):<span class="branch-1 cbranch-no" title="branch not covered" >Array(n.length).fill(0))</span>;var u=Nr({edges_vertices:n}),s=i.map((function(){return Jn.core.identity3x4}));return $r({faces_vertices:i,faces_faces:c},a).slice(1).forEach((function(e){return e.forEach((function(e){var n,o=e.edge_vertices.map((function(e){return t[e]})),i=e.edge_vertices.join(" "),c=u[i],a=Jn.core.make_matrix3_rotate(r[c]*Math.PI/180,(n=Jn.core).subtract.apply(n,_toConsumableArray(Jn.core.resize_up(o[1],o[0]))),o[0]);s[e.face]=Jn.core.multiply_matrices3(s[e.parent],a)}))})),s},Yr=function make_faces_coloring_from_matrix(e){return e.faces_matrix.map((function(e){return e[0]*e[4]-e[1]*e[3]})).map((function(e){return e&gt;=0}))},Wr=Object.freeze({__proto__:null,make_vertices_edges:Or,make_vertices_edges_sorted:jr,make_vertices_vertices:Cr,make_vertices_faces:Sr,make_vertices_faces_sorted:Pr,make_vertices_to_edge_bidirectional:Nr,make_vertices_to_edge:zr,make_vertices_to_face:Ir,make_vertices_vertices_vector:Lr,make_vertices_sectors:qr,make_vertices_coords_folded:Tr,make_edges_edges:function make_edges_edges(e){var t=e.edges_vertices,n=e.vertices_edges;return t.map((function(e,t){var r=n[e[0]].filter((function(e){return e!==t})),o=n[e[1]].filter((function(e){return e!==t}));return r.concat(o)}))},make_edges_faces:Fr,make_edges_foldAngle:Gr,make_edges_assignment:function make_edges_assignment(e){return e.edges_foldAngle.map((function(e){return 0===e?"F":e&lt;0?"M":"V"}))},make_edges_vector:Br,make_edges_length:function make_edges_length(e){var t=e.vertices_coords,n=e.edges_vertices;return Br({vertices_coords:t,edges_vertices:n}).map((function(e){return Jn.core.magnitude(e)}))},make_edges_coords_min_max:Dr,make_edges_coords_min_max_exclusive:function <span class="fstat-no" title="function not covered" >make_edges_coords_min_max_exclusive(</span>e){var t=<span class="cstat-no" title="statement not covered" >arguments.length&gt;1&amp;&amp;void 0!==arguments[1]?arguments[1]:Jn.core.EPSILON,</span>n=<span class="cstat-no" title="statement not covered" >[+t,-t];<span class="cstat-no" title="statement not covered" ></span>return Dr(e).map((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return e.map((<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){<span class="cstat-no" title="statement not covered" >return e.map((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return e+n[t]}</span>))}</span>))}</span>))}</span>,make_edges_coords_min_max_inclusive:Rr,make_planar_faces:Ur,make_faces_vertices:function make_faces_vertices(e){return Ur(e).map((function(e){return e.vertices}))},make_faces_edges:function make_faces_edges(e){return Ur(e).map((function(e){return e.edges}))},make_faces_faces:Zr,get_face_face_shared_vertices:Xr,make_face_spanning_tree:$r,make_faces_matrix:Hr,make_faces_center:function <span class="fstat-no" title="function not covered" >make_faces_center(</span>e){var t=<span class="cstat-no" title="statement not covered" >e.vertices_coords;<span class="cstat-no" title="statement not covered" ></span>return e.faces_vertices.map((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return e.map((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return t[e]}</span>))}</span>)).map((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return Jn.core.centroid(e)}</span>))}</span>,make_faces_coloring_from_matrix:Yr,make_faces_coloring:function make_faces_coloring(e){var t=e.faces_vertices,n=e.faces_faces,r=arguments.length&gt;1&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >void 0!==arguments[1]?<span class="branch-0 cbranch-no" title="branch not covered" ></span>arguments[1]:</span>0,o=[];return o[r]=!0,$r({faces_vertices:t,faces_faces:n},r).forEach((function(e,t){return e.forEach((function(e){o[e.face]=t%2==0}))})),o}}),Jr=function get_boundary(e){var t=e.vertices_edges,n=e.edges_vertices,r=e.edges_assignment;<span class="missing-if-branch" title="if path not taken" >I</span>if(void 0===r)<span class="cstat-no" title="statement not covered" >return{vertices:[],edges:[]};t</span>||(t=Or({edges_vertices:n}));for(var o=r.map((function(e){return"B"===e||"b"===e})),i=[],c=[],a=-1,u=0;u&lt;o.length;u+=1)<span class="missing-if-branch" title="else path not taken" >E</span>if(o[u]){a=u;break}<span class="missing-if-branch" title="if path not taken" >I</span>if(-1===a)<span class="cstat-no" title="statement not covered" >return{vertices:[],edges:[]};o</span>[a]=!1,i.push(a),c.push(n[a][0]);for(var s=n[a][1];c[0]!==s;){<span class="missing-if-branch" title="if path not taken" >I</span>if(c.push(s),void 0===(a=t[s].filter((function(e){return o[e]})).shift()))<span class="cstat-no" title="statement not covered" >return{vertices:[],edges:[]};<span class="missing-if-branch" title="else path not taken" >E</span>i</span>f(n[a][0]===s)s=_slicedToArray(n[a],2)[1];else <span class="cstat-no" title="statement not covered" >s=_slicedToArray(n[a],1)[0];o</span>[a]=!1,i.push(a)}return{vertices:c,edges:i}},Kr=Object.freeze({__proto__:null,get_boundary:Jr,get_planar_boundary:function <span class="fstat-no" title="function not covered" >get_planar_boundary(</span>e){var t=<span class="cstat-no" title="statement not covered" >e.vertices_coords,</span>n=<span class="cstat-no" title="statement not covered" >e.vertices_edges,</span>r=<span class="cstat-no" title="statement not covered" >e.vertices_vertices,</span>o=<span class="cstat-no" title="statement not covered" >e.edges_vertices;<span class="cstat-no" title="statement not covered" ></span>r||(r=Cr({vertices_coords:t,vertices_edges:n,edges_vertices:o}));v</span>ar i=<span class="cstat-no" title="statement not covered" >Nr({edges_vertices:o}),</span>c=<span class="cstat-no" title="statement not covered" >[],</span>a=<span class="cstat-no" title="statement not covered" >[],</span>u=<span class="cstat-no" title="statement not covered" >{vertices:a,edges:c},</span>s=<span class="cstat-no" title="statement not covered" >-1/0,</span>l=<span class="cstat-no" title="statement not covered" >-1;<span class="cstat-no" title="statement not covered" ></span>if(t.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){<span class="cstat-no" title="statement not covered" >e[0]&gt;s&amp;&amp;(s=e[0],l=t)}</span>)),-1===l)<span class="cstat-no" title="statement not covered" >return u;<span class="cstat-no" title="statement not covered" >a</span></span>.push(l);v</span>ar v=<span class="cstat-no" title="statement not covered" >t[l],</span>d=<span class="cstat-no" title="statement not covered" >r[l],</span>p=<span class="cstat-no" title="statement not covered" >d.map((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return t[e]}</span>)).map((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return[e[0]-v[0],e[1]-v[1]]}</span>)).map((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return Math.atan2(e[1],e[0])}</span>)).map((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return e&lt;0?e+2*Math.PI:e}</span>)).map((<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){<span class="cstat-no" title="statement not covered" >return{a:e,i:t}}</span>)).sort((<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){<span class="cstat-no" title="statement not covered" >return e.a-t.a}</span>)).shift().i,</span>h=<span class="cstat-no" title="statement not covered" >d[p],</span>m=<span class="cstat-no" title="statement not covered" >i[l&lt;h?"".concat(l," ").concat(h):"".concat(h," ").concat(l)];<span class="cstat-no" title="statement not covered" ></span>c.push(m);<span class="cstat-no" title="statement not covered" >f</span>or(var b=<span class="cstat-no" title="statement not covered" >l,</span>k=<span class="cstat-no" title="statement not covered" >h,</span>w=<span class="cstat-no" title="statement not covered" >0;</span>w&lt;1e4;){var E=<span class="cstat-no" title="statement not covered" >r[k],</span>M=<span class="cstat-no" title="statement not covered" >E.indexOf(b),</span>O=<span class="cstat-no" title="statement not covered" >E[(M+1)%E.length],</span>j=<span class="cstat-no" title="statement not covered" >i[k&lt;O?"".concat(k," ").concat(O):"".concat(O," ").concat(k)];<span class="cstat-no" title="statement not covered" ></span>if(j===c[0])<span class="cstat-no" title="statement not covered" >return u;<span class="cstat-no" title="statement not covered" >a</span></span>.push(k),c.push(j),b=k,k=O,w+=1}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn console.warn("calculate boundary potentially entered infinite loop"),u}</span>}),Qr=function clip_line(e,t){var n=e.vertices_coords,r=e.vertices_edges,o=e.edges_vertices,i=e.edges_assignment,c=e.boundaries_vertices,a=Jn.typeof(t),u=Jn.core["clip_".concat(a,"_in_convex_poly_exclusive")];<span class="missing-if-branch" title="else path not taken" >E</span>if(u){c||(c=Jr({vertices_edges:r,edges_vertices:o,edges_assignment:i}).vertices);var s=c.map((function(e){return n[e]}));return u.apply(void 0,[s].concat(_toConsumableArray(function prepare_clip_func_params(e,t){switch(t){case"line":case"ray":return[e.vector,e.origin];<span class="branch-2 cbranch-no" title="branch not covered" >case"segment":<span class="cstat-no" title="statement not covered" >return[e[0],e[1]];<span class="branch-3 cbranch-no" title="branch not covered" >d</span></span>efault:<span class="cstat-no" title="statement not covered" >return[]}</span></span>}(t,a))))}},eo=Object.freeze({__proto__:null,clip_line:Qr}),to=function nearest_vertex(e,t){var n=e.vertices_coords;<span class="missing-if-branch" title="else path not taken" >E</span>if(n){var r=Jn.core.resize(n[0].length,t),o=n.map((function(e,t){return{d:Jn.core.distance(r,e),i:t}})).sort((function(e,t){return e.d-t.d})).shift();return o?o.i:<span class="branch-1 cbranch-no" title="branch not covered" >void 0}</span>},no=function <span class="fstat-no" title="function not covered" >nearest_edge(</span>e,t){var n=<span class="cstat-no" title="statement not covered" >e.vertices_coords,</span>r=<span class="cstat-no" title="statement not covered" >e.edges_vertices;<span class="cstat-no" title="statement not covered" ></span>if(n&amp;&amp;r){var o=<span class="cstat-no" title="statement not covered" >r.map((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return e.map((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return n[e]}</span>))}</span>)).map((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return Jn.core.nearest_point_on_line(Jn.core.subtract(e[1],e[0]),e[0],t,Jn.core.segment_limiter)}</span>));<span class="cstat-no" title="statement not covered" ></span>return Jn.core.smallest_comparison_search(t,o,Jn.core.distance)}</span>}</span>,ro=function <span class="fstat-no" title="function not covered" >face_containing_point(</span>e,t){var n=<span class="cstat-no" title="statement not covered" >e.vertices_coords,</span>r=<span class="cstat-no" title="statement not covered" >e.faces_vertices;<span class="cstat-no" title="statement not covered" ></span>if(n&amp;&amp;r){var o=<span class="cstat-no" title="statement not covered" >r.map((<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){<span class="cstat-no" title="statement not covered" >return{face:e.map((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return n[e]}</span>)),i:t}}</span>)).filter((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return Jn.core.point_in_poly(t,e.face)}</span>)).shift();<span class="cstat-no" title="statement not covered" ></span>return void 0===o?void 0:o.i}</span>}</span>,oo=ro,io=Object.freeze({__proto__:null,nearest_vertex:to,nearest_edge:no,face_containing_point:ro,nearest_face:oo}),co=function get_edges_vertices_span(e){var t=arguments.length&gt;1&amp;&amp;void 0!==arguments[1]?arguments[1]:<span class="branch-1 cbranch-no" title="branch not covered" >Jn.core.EPSILON;</span>return Rr(e).map((function(n,r){return e.vertices_coords.map((function(e,r){return e[0]&gt;n[0][0]-t&amp;&amp;e[1]&gt;n[0][1]-t&amp;&amp;e[0]&lt;n[1][0]+t&amp;&amp;e[1]&lt;n[1][1]+t}))}))},ao=function get_edges_edges_span(e){for(var t=e.vertices_coords,n=e.edges_vertices,r=e.edges_coords,o=arguments.length&gt;1&amp;&amp;void 0!==arguments[1]?arguments[1]:Jn.core.EPSILON,i=Rr({vertices_coords:t,edges_vertices:n,edges_coords:r},o),c=n.map((function(){return[]})),a=0;a&lt;n.length-1;a+=1)for(var u=a+1;u&lt;n.length;u+=1){var s=(i[a][1][0]&lt;i[u][0][0]||i[u][1][0]&lt;i[a][0][0])&amp;&amp;(i[a][1][1]&lt;i[u][0][1]||i[u][1][1]&lt;i[a][0][1]);c[a][u]=!s,c[u][a]=!s}for(var l=0;l&lt;n.length;l+=1)c[l][l]=!0;return c},uo=Object.freeze({__proto__:null,get_edges_vertices_span:co,get_edges_edges_span:ao}),so=function merge_nextmaps(){for(var e=arguments.length,t=new Array(e),n=0;n&lt;e;n++)t[n]=arguments[n];<span class="missing-if-branch" title="else path not taken" >E</span>if(0!==t.length){var r=t[0].map((function(e,t){return[t]}));return t.forEach((function(e){r.forEach((function(t,n){return t.forEach((function(t,o){r[n][o]=e[t]}))})),r.forEach((function(e,t){r[t]=e.reduce((function(e,t){return e.concat(t)}),[]).filter((function(e){return void 0!==e}))}))})),r}},fo=function invert_map(e){var t=[];return e.forEach((function(e,n){null!=e&amp;&amp;("number"==typeof e&amp;&amp;(void 0!==t[e]?"number"==typeof t[e]?t[e]=[t[e],n]:t[e].push(n):t[e]=n),e.constructor===Array&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >e.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >t[e]=n}</span>)))</span>})),t},lo=Object.freeze({__proto__:null,merge_simple_nextmaps:function merge_simple_nextmaps(){for(var e=arguments.length,t=new Array(e),n=0;n&lt;e;n++)t[n]=arguments[n];<span class="missing-if-branch" title="else path not taken" >E</span>if(0!==t.length){var r=t[0].map((function(e,t){return t}));return t.forEach((function(e){return r.forEach((function(t,n){r[n]=e[t]}))})),r}},merge_nextmaps:so,merge_simple_backmaps:function merge_simple_backmaps(){for(var e=arguments.length,t=new Array(e),n=0;n&lt;e;n++)t[n]=arguments[n];<span class="missing-if-branch" title="else path not taken" >E</span>if(0!==t.length){var r=t[0].map((function(e,t){return t}));return t.forEach((function(e,t){var n=e.map((function(e){return r[e]}));r=n})),r}},merge_backmaps:function merge_backmaps(){for(var e=arguments.length,t=new Array(e),n=0;n&lt;e;n++)t[n]=arguments[n];<span class="missing-if-branch" title="else path not taken" >E</span>if(0!==t.length){var r=t[0].reduce((function(e,t){return e.concat(t)}),[]).map((function(e,t){return[t]}));return t.forEach((function(e,t){var n=[];e.forEach((function(e,t){n[t]="number"==typeof e?r[e]:e.map((function(e){return r[e]})).reduce((function(e,t){return e.concat(t)}),[])})),r=n})),r}},invert_map:fo,invert_simple_map:function <span class="fstat-no" title="function not covered" >invert_simple_map(</span>e){var t=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>return e.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(e,n){<span class="cstat-no" title="statement not covered" >t[e]=n}</span>)),t}</span>}),vo=function max_arrays_length(){for(var e=arguments.length,t=new Array(e),n=0;n&lt;e;n++)t[n]=arguments[n];return Math.max.apply(Math,[0].concat(_toConsumableArray(t.filter((function(e){return void 0!==e})).map((function(e){return e.length})))))},po=function count(e,t){return vo.apply(void 0,_toConsumableArray(_r(e,t).map((function(t){return e[t]}))))};po.vertices=function(e){var t=e.vertices_coords,n=e.vertices_faces,r=e.vertices_vertices;return vo(t,n,r)},po.edges=function(e){var t=e.edges_vertices,n=e.edges_edges,r=e.edges_faces;return vo(t,n,r)},po.faces=function(e){var t=e.faces_vertices,n=e.faces_edges,r=e.faces_faces;return vo(t,n,r)};var _o=function unique_sorted_integers(e){var t={};return e.forEach((function(e){t[e]=!0})),Object.keys(t).map((function(e){return parseInt(e)})).sort((function(e,t){return e-t}))},go=function remove_geometry_indices(e,t,n){var r,o,i,c=po(e,t),a=_o(n),u=[];for(r=0,o=0,i=0;r&lt;c;r+=1,o+=1){for(;r===a[i];)u[r]=void 0,r+=1,i+=1;r&lt;c&amp;&amp;(u[r]=o)}return gr(e,t).forEach((function(t){return e[t].forEach((function(n,r){return e[t][r].forEach((function(n,o){e[t][r][o]=u[n]}))}))})),a.reverse(),_r(e,t).forEach((function(t){return a.forEach((function(n){return e[t].splice(n,1)}))})),u},ho=function populate(e){if("object"===_typeof(e)&amp;&amp;e.edges_vertices){<span class="missing-if-branch" title="else path not taken" >E</span>if(e.vertices_edges=Or(e),e.vertices_vertices=Cr(e),e.vertices_edges=jr(e),e.vertices_coords&amp;&amp;(e.edges_vector=Br(e),e.vertices_sectors=qr(e)),function set_edges_angles(e){var t=e.edges_vertices.length;if(e.edges_assignment||(e.edges_assignment=[]),e.edges_foldAngle||(e.edges_foldAngle=[]),e.edges_assignment.length&gt;e.edges_foldAngle.length)for(var n=e.edges_foldAngle.length;n&lt;e.edges_assignment.length;n+=1)e.edges_foldAngle[n]=lr(e.edges_assignment[n]);if(e.edges_foldAngle.length&gt;e.edges_assignment.length)for(var r=e.edges_assignment.length;r&lt;e.edges_foldAngle.length;r+=1)e.edges_assignment[r]=vr(e.edges_foldAngle[r]);for(var o=e.edges_assignment.length;o&lt;t;o+=1)<span class="cstat-no" title="statement not covered" >e.edges_assignment[o]="U",e.edges_foldAngle[o]=0}</span>(e),e.vertices_coords){var t=Ur(e);e.faces_vertices=t.map((function(e){return e.vertices})),e.faces_edges=t.map((function(e){return e.edges})),e.faces_angles=t.map((function(e){return e.angles}))}else <span class="cstat-no" title="statement not covered" >e.faces_vertices=[],e.faces_edges=[];r</span>eturn e.vertices_faces=e.vertices_vertices?Pr(e):<span class="branch-1 cbranch-no" title="branch not covered" >Sr(e),</span>e.edges_faces=Fr(e),e.faces_faces=Zr(e),e.vertices_coords&amp;&amp;(e.faces_matrix=Hr(e)),e}},mo=function add_vertices(e,t){var n,r=arguments.length&gt;2&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >void 0!==arguments[2]?<span class="branch-0 cbranch-no" title="branch not covered" ></span>arguments[2]:</span>Jn.core.EPSILON;e.vertices_coords||(e.vertices_coords=[]),"number"==typeof t[0]&amp;&amp;(<span class="branch-1 cbranch-no" title="branch not covered" >t=[t])</span>;var o=t.map((function(t){return e.vertices_coords.map((function(e){return Jn.core.distance(e,t)&lt;r})).map((function(e,t){return e?t:void 0})).filter((function(e){return void 0!==e})).shift()})),i=e.vertices_coords.length,c=t.filter((function(e,t){return void 0===o[t]}));return(n=e.vertices_coords).push.apply(n,_toConsumableArray(c)),o.map((function(e){return void 0===e?i++:e}))},yo=["vertices","edges","faces"],bo=function <span class="fstat-no" title="function not covered" >make_vertices_map_and_consider_duplicates(</span>e,t){var n=<span class="cstat-no" title="statement not covered" >arguments.length&gt;2&amp;&amp;void 0!==arguments[2]?arguments[2]:Jn.core.EPSILON,</span>r=<span class="cstat-no" title="statement not covered" >e.vertices_coords.length;<span class="cstat-no" title="statement not covered" ></span>return t.vertices_coords.map((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return e.vertices_coords.map((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return Jn.core.distance(e,t)&lt;n}</span>)).map((<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){<span class="cstat-no" title="statement not covered" >return e?t:void 0}</span>)).filter((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return void 0!==e}</span>)).shift()}</span>)).map((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return void 0===e?r++:e}</span>))}</span>,xo=function <span class="fstat-no" title="function not covered" >get_edges_duplicate_from_source_in_target(</span>e,t){<span class="cstat-no" title="statement not covered" >for(var n=<span class="cstat-no" title="statement not covered" >{},</span>r=<span class="cstat-no" title="statement not covered" >{},</span>o=<span class="cstat-no" title="statement not covered" >0;</span>o&lt;e.edges_vertices.length;o+=1)<span class="cstat-no" title="statement not covered" >r["".concat(e.edges_vertices[o][0]," ").concat(e.edges_vertices[o][1])]=o,r["".concat(e.edges_vertices[o][1]," ").concat(e.edges_vertices[o][0])]=o;<span class="cstat-no" title="statement not covered" >f</span></span>or(var i=<span class="cstat-no" title="statement not covered" >0;</span>i&lt;t.edges_vertices.length;i+=1){var c=<span class="cstat-no" title="statement not covered" >r["".concat(t.edges_vertices[i][0]," ").concat(t.edges_vertices[i][1])];<span class="cstat-no" title="statement not covered" ></span>void 0!==c&amp;&amp;(n[i]=c)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn n}</span>,Ao=function <span class="fstat-no" title="function not covered" >update_suffixes(</span>e,t,n,r){<span class="cstat-no" title="statement not covered" >return n.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(n){<span class="cstat-no" title="statement not covered" >return t[n].forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return e[t].forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(o,i){<span class="cstat-no" title="statement not covered" >return o.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(o,c){<span class="cstat-no" title="statement not covered" >e[t][i][c]=r[n][o]}</span>))}</span>))}</span>))}</span>))}</span>,ko=function <span class="fstat-no" title="function not covered" >assign(</span>e,t){var n=<span class="cstat-no" title="statement not covered" >arguments.length&gt;2&amp;&amp;void 0!==arguments[2]?arguments[2]:Jn.core.EPSILON,</span>r=<span class="cstat-no" title="statement not covered" >{},</span>o=<span class="cstat-no" title="statement not covered" >{},</span>i=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" ></span>yo.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >r[e]=_r(t,e),o[e]=gr(t,e)}</span>)),yo.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return r[t].filter((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return!e[t]}</span>)).forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >e[t]=[]}</span>))}</span>)),i.vertices=bo(e,t,n),Ao(t,o,["vertices"],i);v</span>ar c=<span class="cstat-no" title="statement not covered" >po.edges(e);<span class="cstat-no" title="statement not covered" ></span>i.edges=Array.from(Array(po.edges(t))).map((<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){<span class="cstat-no" title="statement not covered" >return c+t}</span>));v</span>ar a=<span class="cstat-no" title="statement not covered" >xo(e,t);<span class="cstat-no" title="statement not covered" ></span>Object.keys(a).forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >i.edges[e]=a[e]}</span>));v</span>ar u=<span class="cstat-no" title="statement not covered" >po.faces(e);<span class="cstat-no" title="statement not covered" ></span>return i.faces=Array.from(Array(po.faces(t))).map((<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){<span class="cstat-no" title="statement not covered" >return u+t}</span>)),Ao(t,o,["edges","faces"],i),yo.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(n){<span class="cstat-no" title="statement not covered" >return r[n].forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(r){<span class="cstat-no" title="statement not covered" >return t[r].forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(t,o){var c=<span class="cstat-no" title="statement not covered" >i[n][o];<span class="cstat-no" title="statement not covered" ></span>e[r][c]=t}</span>))}</span>))}</span>)),i}</span>,wo=function apply_matrix_to_graph(e,t){return dr(e,"coords").forEach((function(n){e[n]=e[n].map((function(e){return Jn.core.resize(3,e)})).map((function(e){return Jn.core.multiply_matrix3_vector3(t,e)}))})),dr(e,"matrix").forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(n){<span class="cstat-no" title="statement not covered" >e[n]=e[n].map((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return Jn.core.multiply_matrices3(e,t)}</span>))}</span>)),e},Eo={scale:function transform_scale(e,t){for(var n,r=arguments.length,o=new Array(r&gt;2?<span class="branch-0 cbranch-no" title="branch not covered" >r-2:</span>0),i=2;i&lt;r;i++)<span class="cstat-no" title="statement not covered" >o[i-2]=arguments[i];v</span>ar c=(n=Jn.core).get_vector.apply(n,o),a=Jn.core.resize(3,c),u=Jn.core.make_matrix3_scale(t,a);return wo(e,u)},translate:function transform_translate(e){for(var t,n,r=arguments.length,o=new Array(r&gt;1?r-1:<span class="branch-1 cbranch-no" title="branch not covered" >0)</span>,i=1;i&lt;r;i++)o[i-1]=arguments[i];var c=(t=Jn.core).get_vector.apply(t,o),a=Jn.core.resize(3,c),u=(n=Jn.core).make_matrix3_translate.apply(n,_toConsumableArray(a));return wo(e,u)},rotateZ:function <span class="fstat-no" title="function not covered" >transform_rotateZ(</span>e,t){<span class="cstat-no" title="statement not covered" >for(var n,r,o=<span class="cstat-no" title="statement not covered" >arguments.length,</span>i=<span class="cstat-no" title="statement not covered" >new Array(o&gt;2?o-2:0),</span>c=<span class="cstat-no" title="statement not covered" >2;</span>c&lt;o;c++)<span class="cstat-no" title="statement not covered" >i[c-2]=arguments[c];v</span></span>ar a=<span class="cstat-no" title="statement not covered" >(n=Jn.core).get_vector.apply(n,i),</span>u=<span class="cstat-no" title="statement not covered" >Jn.core.resize(3,a),</span>s=<span class="cstat-no" title="statement not covered" >(r=Jn.core).make_matrix3_rotateZ.apply(r,[t].concat(_toConsumableArray(u)));<span class="cstat-no" title="statement not covered" ></span>return wo(e,s)}</span>,transform:wo},Mo=function <span class="fstat-no" title="function not covered" >subgraph(</span>e,t){var n=<span class="cstat-no" title="statement not covered" >{},</span>r=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" ></span>return["faces","edges","vertices"].forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(o){<span class="cstat-no" title="statement not covered" >n[o]=Array.from(Array(po[o](e))).map((<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){<span class="cstat-no" title="statement not covered" >return t}</span>)),r[o]=_o(t[o]||[]).reverse()}</span>)),Object.keys(r).forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return r[e].forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return n[e].splice(t,1)}</span>))}</span>)),Object.keys(n).forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return go(e,t,n[t])}</span>)),e}</span>,Oo=function fn_and(e,t){return e&amp;&amp;t},jo=function fn_cat(e,t){return e.concat(t)},Co=function fn_def(e){return void 0!==e},So=function <span class="fstat-no" title="function not covered" >get_isolated_vertices(</span>e){var t=<span class="cstat-no" title="statement not covered" >e.vertices_coords,</span>n=<span class="cstat-no" title="statement not covered" >e.edges_vertices,</span>r=<span class="cstat-no" title="statement not covered" >e.faces_vertices,</span>o=<span class="cstat-no" title="statement not covered" >t.length,</span>i=<span class="cstat-no" title="statement not covered" >Array(o).fill(!1);<span class="cstat-no" title="statement not covered" ></span>return n&amp;&amp;n.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >e.filter((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return!i[e]}</span>)).forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >i[e]=!0,o-=1}</span>))}</span>)),r&amp;&amp;r.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >e.filter((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return!i[e]}</span>)).forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >i[e]=!0,o-=1}</span>))}</span>)),i.map((<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){<span class="cstat-no" title="statement not covered" >return e?void 0:t}</span>)).filter((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return void 0!==e}</span>))}</span>,Po=Object.freeze({__proto__:null,get_edge_isolated_vertices:function <span class="fstat-no" title="function not covered" >get_edge_isolated_vertices(</span>e){var t=<span class="cstat-no" title="statement not covered" >e.vertices_coords,</span>n=<span class="cstat-no" title="statement not covered" >e.edges_vertices,</span>r=<span class="cstat-no" title="statement not covered" >t.length,</span>o=<span class="cstat-no" title="statement not covered" >Array(r).fill(!1);<span class="cstat-no" title="statement not covered" ></span>return n.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >e.filter((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return!o[e]}</span>)).forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >o[e]=!0,r-=1}</span>))}</span>)),o.map((<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){<span class="cstat-no" title="statement not covered" >return e?void 0:t}</span>)).filter((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return void 0!==e}</span>))}</span>,get_face_isolated_vertices:function <span class="fstat-no" title="function not covered" >get_face_isolated_vertices(</span>e){var t=<span class="cstat-no" title="statement not covered" >e.vertices_coords,</span>n=<span class="cstat-no" title="statement not covered" >e.faces_vertices,</span>r=<span class="cstat-no" title="statement not covered" >t.length,</span>o=<span class="cstat-no" title="statement not covered" >Array(r).fill(!1);<span class="cstat-no" title="statement not covered" ></span>return n.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >e.filter((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return!o[e]}</span>)).forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >o[e]=!0,r-=1}</span>))}</span>)),o.map((<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){<span class="cstat-no" title="statement not covered" >return e?void 0:t}</span>)).filter((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return void 0!==e}</span>))}</span>,get_isolated_vertices:So}),No=function get_circular_edges(e){for(var t=e.edges_vertices,n=[],r=0;r&lt;t.length;r+=1)t[r][0]===t[r][1]&amp;&amp;n.push(r);return n},zo=function get_duplicate_edges(e){var t=e.edges_vertices;<span class="missing-if-branch" title="if path not taken" >I</span>if(!t)<span class="cstat-no" title="statement not covered" >return[];f</span>or(var n=[],r={},o=0;o&lt;t.length;o+=1){var i="".concat(t[o][0]," ").concat(t[o][1]),c="".concat(t[o][1]," ").concat(t[o][0]);void 0!==r[i]?n[o]=r[i]:(r[i]=o,r[c]=o)}return n},Io=function are_vertices_equivalent(e,t){for(var n=arguments.length&gt;2&amp;&amp;void 0!==arguments[2]?arguments[2]:<span class="branch-1 cbranch-no" title="branch not covered" >Jn.core.EPSILON,</span>r=e.length,o=0;o&lt;r;o+=1)if(Math.abs(e[o]-t[o])&gt;n)return!1;return!0},Lo=function get_duplicate_vertices(e){for(var t=e.vertices_coords,n=arguments.length&gt;1&amp;&amp;void 0!==arguments[1]?arguments[1]:Jn.core.EPSILON,r=t.map((function(){return[]})),o=0;o&lt;t.length-1;o+=1)for(var i=o+1;i&lt;t.length;i+=1)r[o][i]=Io(t[o],t[i],n);for(var c=r.map((function(e){return e.map((function(e,t){return e?t:void 0})).filter((function(e){return void 0!==e}))})),a=[],u=Array(t.length).fill(!1),s=0,l=function recurse(e,n){if(!u[n]&amp;&amp;s!==t.length)for(u[n]=!0,s+=1,a[e]||(a[e]=[]),a[e].push(n);c[n].length&gt;0;)recurse(e,c[n][0]),c[n].splice(0,1)},v=0;v&lt;t.length&amp;&amp;(l(v,v),s!==t.length);v+=1);return a.filter((function(e){return e.length}))},qo=function <span class="fstat-no" title="function not covered" >remove_isolated_vertices(</span>e){var t=<span class="cstat-no" title="statement not covered" >So(e);<span class="cstat-no" title="statement not covered" ></span>return{map:go(e,rr,t),remove:t}}</span>,To=function remove_circular_edges(e){var t=No(e);if(t.length){var n={};t.forEach((function(e){n[e]=!0})),gr(e,or).forEach((function(t){return e[t].forEach((function(r,o){for(var i=r.length-1;i&gt;=0;i-=1)!0===n[r[i]]&amp;&amp;e[t][o].splice(i,1)}))}))}return{map:go(e,or,t),remove:t}},Fo=function remove_duplicate_edges(e){var t=zo(e),n=Object.keys(t),r=go(e,or,n);return t.forEach((function(e,t){r[t]=e})),{map:r,remove:n}},Vo=function remove_duplicate_vertices(e){var t=arguments.length&gt;1&amp;&amp;void 0!==arguments[1]?arguments[1]:Jn.core.EPSILON,n=Lo(e,t),r=[];n.forEach((function(e,t){return e.forEach((function(e){r[e]=t}))})),e.vertices_coords=n.map((function(t){return t.map((function(t){return e.vertices_coords[t]}))})).map((function(e){var t;return(t=Jn.core).average.apply(t,_toConsumableArray(e))})),gr(e,rr).forEach((function(t){return e[t].forEach((function(n,o){return e[t][o].forEach((function(n,i){e[t][o][i]=r[n]}))}))})),_r(e,rr).filter((function(e){return e!==cr})).forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return delete e[t]}</span>));var o=n.map((function(e){return e.length&gt;1?e.slice(1,e.length):void 0})).filter((function(e){return void 0!==e})).reduce((function(e,t){return e.concat(t)}),[]);return{map:r,remove:o}},Go=Object.freeze({__proto__:null,remove_isolated_vertices:qo,remove_circular_edges:To,remove_duplicate_edges:Fo,remove_duplicate_vertices:Vo}),Bo=function get_collinear_vertices(e){var t=e.vertices_coords,n=e.edges_vertices,r=e.edges_coords,o=arguments.length&gt;1&amp;&amp;void 0!==arguments[1]?arguments[1]:<span class="branch-1 cbranch-no" title="branch not covered" >Jn.core.EPSILON;</span>r||(<span class="branch-1 cbranch-no" title="branch not covered" >r=n.map((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return e.map((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return t[e]}</span>))}</span>)))</span>;for(var i=co({vertices_coords:t,edges_vertices:n,edges_coords:r},o),c=0;c&lt;r.length;c+=1)for(var a=0;a&lt;t.length;a+=1)i[c][a]&amp;&amp;(i[c][a]=Jn.core.point_on_segment_exclusive(t[a],r[c][0],r[c][1],o));return i.map((function(e){return e.map((function(e,t){return e?t:void 0})).filter((function(e){return void 0!==e}))}))},Do=function get_edges_edges_intersections(e){var t=e.vertices_coords,n=e.edges_vertices,r=e.edges_vector,o=e.edges_origin,i=arguments.length&gt;1&amp;&amp;void 0!==arguments[1]?arguments[1]:<span class="branch-1 cbranch-no" title="branch not covered" >Jn.core.EPSILON;</span>r||(<span class="branch-1 cbranch-no" title="branch not covered" >r=Br({vertices_coords:t,edges_vertices:n}))</span>,o||(<span class="branch-1 cbranch-no" title="branch not covered" >o=n.map((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return t[e[0]]}</span>)))</span>;for(var c=r.map((function(){return[]})),a=ao({vertices_coords:t,edges_vertices:n},i),u=0;u&lt;r.length-1;u+=1)for(var s=u+1;s&lt;r.length;s+=1)!0===a[u][s]?(c[u][s]=Jn.core.intersect_lines(r[u],o[u],r[s],o[s],Jn.core.exclude_s,Jn.core.exclude_s,i),c[s][u]=c[u][s]):<span class="branch-1 cbranch-no" title="branch not covered" >c[u][s]=void 0;</span>return c},Ro=function fragment_graph(e){var t=arguments.length&gt;1&amp;&amp;void 0!==arguments[1]?arguments[1]:<span class="branch-1 cbranch-no" title="branch not covered" >Jn.core.EPSILON,</span>n=e.edges_vertices.map((function(t){return t.map((function(t){return e.vertices_coords[t]}))})),r=n.map((function(e){return Jn.core.subtract(e[1],e[0])})),o=n.map((function(e){return e[0]})),i=Do({vertices_coords:e.vertices_coords,edges_vertices:e.edges_vertices,edges_vector:r,edges_origin:o},1e-6),c=Bo({vertices_coords:e.vertices_coords,edges_vertices:e.edges_vertices,edges_coords:n},t);if(0!==i.reduce(jo,[]).filter(Co).length||0!==c.reduce(jo,[]).filter(Co).length){var a={vertices:e.vertices_coords.length};i.forEach((function(t){return t.filter(Co).filter((function(e){return 2===e.length})).forEach((function(t){var n=e.vertices_coords.length;e.vertices_coords.push(_toConsumableArray(t)),t.splice(0,2),t.push(n)}))})),i.forEach((function(e,t){e.forEach((function(e,n){e&amp;&amp;(i[t][n]=e[0])}))}));var u=i.map((function(e){return e.filter(Co)}));e.edges_vertices.forEach((function(e,t){return e.push.apply(e,_toConsumableArray(u[t]).concat(_toConsumableArray(c[t])))})),e.edges_vertices.forEach((function(t,n){e.edges_vertices[n]=Er({vertices_coords:e.vertices_coords},t,r[n])}));var s=e.edges_vertices.map((function(e,t){return Array(e.length-1).fill(t)})).reduce(jo,[]);return e.edges_vertices=e.edges_vertices.map((function(e){return Array.from(Array(e.length-1)).map((function(t,n,r){return[e[n],e[n+1]]}))})).reduce(jo,[]),e.edges_assignment&amp;&amp;(e.edges_assignment=s.map((function(t){return e.edges_assignment[t]||<span class="branch-1 cbranch-no" title="branch not covered" >"U"}</span>))),e.edges_foldAngle&amp;&amp;(<span class="branch-1 cbranch-no" title="branch not covered" >e.edges_foldAngle=s.map((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return e.edges_foldAngle[t]||0}</span>)))</span>,{vertices:{new:Array.from(Array(e.vertices_coords.length-a.vertices)).map((function(e,t){return a.vertices+t}))},edges:{backmap:s}}}},Uo=["vertices_coords","edges_vertices","edges_assignment","edges_foldAngle"],Zo=function fragment(e){var t=arguments.length&gt;1&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >void 0!==arguments[1]?<span class="branch-0 cbranch-no" title="branch not covered" ></span>arguments[1]:</span>Jn.core.EPSILON;e.vertices_coords=e.vertices_coords.map((function(e){return e.slice(0,2)})),[rr,or,ir].map((function(t){return _r(e,t)})).reduce(jo,[]).filter((function(e){return!Uo.includes(e)})).forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return delete e[t]}</span>));var n,r={vertices:{},edges:{}};for(n=0;n&lt;20;n++){var o=Vo(e,t/2),i=Fo(e),c=To(e),a=Ro(e,t);if(void 0===a){r.vertices.map=void 0===r.vertices.map?o.map:so(r.vertices.map,o.map),r.edges.map=void 0===r.edges.map?so(i.map,c.map):so(r.edges.map,i.map,c.map);break}var u=fo(a.edges.backmap),s=so(i.map,c.map,u);r.vertices.map=void 0===r.vertices.map?o.map:<span class="branch-1 cbranch-no" title="branch not covered" >so(r.vertices.map,o.map),</span>r.edges.map=void 0===r.edges.map?s:<span class="branch-1 cbranch-no" title="branch not covered" >so(r.edges.map,s)}</span>return 20===n&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >console.warn("debug warning. fragment reached max iterations"),</span>r},Xo=function clone(e){var t,n;if("object"!==_typeof(e))return e;<span class="missing-if-branch" title="if path not taken" >I</span>if(!e)<span class="cstat-no" title="statement not covered" >return e;i</span>f("[object Array]"===Object.prototype.toString.apply(e)){for(t=[],n=0;n&lt;e.length;n+=1)t[n]=clone(e[n]);return t}for(n in t={},e)e.hasOwnProperty(n)&amp;&amp;(t[n]=clone(e[n]));return t},$o=function add_edges(e,t){var n;e.edges_vertices||(<span class="branch-1 cbranch-no" title="branch not covered" >e.edges_vertices=[])</span>,"number"==typeof t[0]&amp;&amp;(t=[t]);var r=t.map((function(t,n){return e.edges_vertices.length+n}));(n=e.edges_vertices).push.apply(n,_toConsumableArray(t));var o=Fo(e).map;return r.map((function(e){return o[e]}))},Ho=function split_edge(e,t,n){<span class="missing-if-branch" title="else path not taken" >E</span>if(!(e.edges_vertices.length&lt;t)){var r,o=e.edges_vertices[t];<span class="missing-if-branch" title="if path not taken" >I</span>if(!n)<span class="cstat-no" title="statement not covered" >n=(r=Jn.core).midpoint.apply(r,_toConsumableArray(o));v</span>ar i=o.map((function(t){return e.vertices_coords[t]})).map((function(e){return Jn.core.distance(e,n)&lt;Jn.core.EPSILON}));<span class="missing-if-branch" title="else path not taken" >E</span>if(i[0])return{vertex:o[0],edges:{}};<span class="cstat-no" title="statement not covered" >if(i[1])<span class="cstat-no" title="statement not covered" >return{vertex:o[1],edges:{}};v</span></span>ar c=<span class="cstat-no" title="statement not covered" >e.vertices_coords.length;<span class="cstat-no" title="statement not covered" ></span>e.vertices_coords[c]=n;v</span>ar a=<span class="cstat-no" title="statement not covered" >[0,1].map((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t+e.edges_vertices.length}</span>));<span class="cstat-no" title="statement not covered" ></span>(function <span class="fstat-no" title="function not covered" >split_edge_into_two(</span>e,t,n){var r=<span class="cstat-no" title="statement not covered" >e.edges_vertices[t],</span>o=<span class="cstat-no" title="statement not covered" >[{edges_vertices:[r[0],n]},{edges_vertices:[n,r[1]]}];<span class="cstat-no" title="statement not covered" ></span>return o.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(n,r){<span class="cstat-no" title="statement not covered" >if([ar,ur].filter((<span class="fstat-no" title="function not covered" >fu</span>nction(n){<span class="cstat-no" title="statement not covered" >return void 0!==e[n]&amp;&amp;void 0!==e[n][t]}</span>)).forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(r){<span class="cstat-no" title="statement not covered" >return n[r]=e[r][t]}</span>)),e.edges_faces&amp;&amp;void 0!==e.edges_faces[t]&amp;&amp;(n.edges_faces=_toConsumableArray(e.edges_faces[t])),e.edges_vector){var o=<span class="cstat-no" title="statement not covered" >n.edges_vertices.map((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return e.vertices_coords[t]}</span>));<span class="cstat-no" title="statement not covered" ></span>n.edges_vector=Jn.core.subtract(o[1],o[0])}<span class="cstat-no" title="statement not covered" ></span>i</span>f(e.edges_length){var i,c=<span class="cstat-no" title="statement not covered" >n.edges_vertices.map((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return e.vertices_coords[t]}</span>));<span class="cstat-no" title="statement not covered" ></span>n.edges_length=(i=Jn.core).distance2.apply(i,_toConsumableArray(c))}</span>}</span>)),o}</span>)(e,t,c).forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(t,n){<span class="cstat-no" title="statement not covered" >return Object.keys(t).forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(r){<span class="cstat-no" title="statement not covered" >e[r][a[n]]=t[r]}</span>))}</span>)),function <span class="fstat-no" title="function not covered" >update_vertices_vertices(</span>e,t,n){var r=<span class="cstat-no" title="statement not covered" >e.vertices_vertices;<span class="cstat-no" title="statement not covered" ></span>r&amp;&amp;(r[t]=_toConsumableArray(n),n.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(e,n,o){var i=<span class="cstat-no" title="statement not covered" >o[(n+1)%o.length],</span>c=<span class="cstat-no" title="statement not covered" >r[e].indexOf(i);<span class="cstat-no" title="statement not covered" ></span>r[e][c]=t}</span>)))}</span>(e,c,o),function <span class="fstat-no" title="function not covered" >update_vertices_edges(</span>e,t,n,r,o){var i=<span class="cstat-no" title="statement not covered" >e.vertices_edges;<span class="cstat-no" title="statement not covered" ></span>i&amp;&amp;(i[r]=_toConsumableArray(o),t.map((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return i[e].indexOf(n)}</span>)).forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(e,n){<span class="cstat-no" title="statement not covered" >i[t[n]][e]=o[n]}</span>)))}</span>(e,o,t,c,a);v</span>ar u=<span class="cstat-no" title="statement not covered" >function <span class="fstat-no" title="function not covered" >find_adjacent_faces_to_edge(</span>e,t){var n=<span class="cstat-no" title="statement not covered" >e.vertices_faces,</span>r=<span class="cstat-no" title="statement not covered" >e.edges_vertices,</span>o=<span class="cstat-no" title="statement not covered" >e.edges_faces,</span>i=<span class="cstat-no" title="statement not covered" >e.faces_edges;<span class="cstat-no" title="statement not covered" ></span>if(e.faces_vertices,o&amp;&amp;o[t])<span class="cstat-no" title="statement not covered" >return o[t];v</span></span>ar c=<span class="cstat-no" title="statement not covered" >r[t];<span class="cstat-no" title="statement not covered" ></span>if(void 0!==n){<span class="cstat-no" title="statement not covered" >for(var a=<span class="cstat-no" title="statement not covered" >[],</span>u=<span class="cstat-no" title="statement not covered" >0;</span>u&lt;n[c[0]].length;u+=1)<span class="cstat-no" title="statement not covered" >for(var s=<span class="cstat-no" title="statement not covered" >0;</span>s&lt;n[c[1]].length;s+=1)<span class="cstat-no" title="statement not covered" >n[c[0]][u]===n[c[1]][s]&amp;&amp;a.push(n[c[0]][u]);<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn a}<span class="cstat-no" title="statement not covered" ></span>i</span>f(i){<span class="cstat-no" title="statement not covered" >for(var l=<span class="cstat-no" title="statement not covered" >[],</span>v=<span class="cstat-no" title="statement not covered" >0;</span>v&lt;i.length;v+=1)<span class="cstat-no" title="statement not covered" >for(var d=<span class="cstat-no" title="statement not covered" >0;</span>d&lt;i[v].length;d+=1)<span class="cstat-no" title="statement not covered" >i[v][d]===t&amp;&amp;l.push(v);<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn l}</span>}</span>(e,t);<span class="cstat-no" title="statement not covered" ></span>u&amp;&amp;(function <span class="fstat-no" title="function not covered" >update_vertices_faces(</span>e,t,n){var r=<span class="cstat-no" title="statement not covered" >e.vertices_faces;<span class="cstat-no" title="statement not covered" ></span>r&amp;&amp;(r[t]=_toConsumableArray(n))}</span>(e,c,o),function <span class="fstat-no" title="function not covered" >update_faces_vertices(</span>e,t,n,r){var o=<span class="cstat-no" title="statement not covered" >e.faces_vertices;<span class="cstat-no" title="statement not covered" ></span>o&amp;&amp;t.map((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return o[e]}</span>)).forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return e.map((<span class="fstat-no" title="function not covered" >fu</span>nction(e,t,n){var o=<span class="cstat-no" title="statement not covered" >(t+1)%n.length;<span class="cstat-no" title="statement not covered" ></span>return e===r[0]&amp;&amp;n[o]===r[1]||e===r[1]&amp;&amp;n[o]===r[0]?o:void 0}</span>)).filter((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return void 0!==e}</span>)).sort((<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){<span class="cstat-no" title="statement not covered" >return t-e}</span>)).forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return e.splice(t,0,n)}</span>))}</span>))}</span>(e,u,c,o),function <span class="fstat-no" title="function not covered" >update_faces_edges(</span>e,t,n,r,o){var i=<span class="cstat-no" title="statement not covered" >e.edges_vertices,</span>c=<span class="cstat-no" title="statement not covered" >e.faces_edges;<span class="cstat-no" title="statement not covered" ></span>c&amp;&amp;t.map((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return c[e]}</span>)).forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(e){var t=<span class="cstat-no" title="statement not covered" >e.indexOf(o),</span>c=<span class="cstat-no" title="statement not covered" >e[(t+e.length-1)%e.length],</span>a=<span class="cstat-no" title="statement not covered" >e[(t+1)%e.length],</span>u=<span class="cstat-no" title="statement not covered" >[[c,o],[o,a]].map((<span class="fstat-no" title="function not covered" >fu</span>nction(e){var t=<span class="cstat-no" title="statement not covered" >e.map((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return i[e]}</span>));<span class="cstat-no" title="statement not covered" ></span>return t[0][0]===t[1][0]||t[0][0]===t[1][1]?t[0][0]:t[0][1]}</span>)).reduce((<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){<span class="cstat-no" title="statement not covered" >return e.concat(t)}</span>),[]),</span>s=<span class="cstat-no" title="statement not covered" >[[u[0],n],[n,u[1]]].map((<span class="fstat-no" title="function not covered" >fu</span>nction(e){var t=<span class="cstat-no" title="statement not covered" >e.map((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return-1!==i[r[0]].indexOf(e)}</span>)).reduce((<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){<span class="cstat-no" title="statement not covered" >return e&amp;&amp;t}</span>),!0),</span>n=<span class="cstat-no" title="statement not covered" >e.map((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return-1!==i[r[1]].indexOf(e)}</span>)).reduce((<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){<span class="cstat-no" title="statement not covered" >return e&amp;&amp;t}</span>),!0);<span class="cstat-no" title="statement not covered" ></span>if(t)<span class="cstat-no" title="statement not covered" >return r[0];<span class="cstat-no" title="statement not covered" >i</span></span>f(n)<span class="cstat-no" title="statement not covered" >return r[1];<span class="cstat-no" title="statement not covered" >t</span></span>hrow new Error("something wrong with input graph's faces_edges construction")}</span>));<span class="cstat-no" title="statement not covered" ></span>return t===e.length-1?(e.splice(t,1,s[0]),e.unshift(s[1])):e.splice.apply(e,[t,1].concat(_toConsumableArray(s))),s}</span>))}</span>(e,u,c,a,t));v</span>ar s=<span class="cstat-no" title="statement not covered" >go(e,or,[t]);<span class="cstat-no" title="statement not covered" ></span>return a.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){<span class="cstat-no" title="statement not covered" >a[t]=s[a[t]]}</span>)),s.splice(-2),s[t]=a,{vertex:c,edges:{map:s,remove:t}}}</span>},Yo=function <span class="fstat-no" title="function not covered" >split_convex_face(</span>e,t,n,r){var o=<span class="cstat-no" title="statement not covered" >function <span class="fstat-no" title="function not covered" >intersect_face_with_line(</span>e,t,n,r){var o=<span class="cstat-no" title="statement not covered" >e.vertices_coords,</span>i=<span class="cstat-no" title="statement not covered" >e.edges_vertices,</span>c=<span class="cstat-no" title="statement not covered" >e.faces_vertices,</span>a=<span class="cstat-no" title="statement not covered" >e.faces_edges,</span>u=<span class="cstat-no" title="statement not covered" >c[t].map((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return o[e]}</span>)).map((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return Jn.core.point_on_line(e,n,r)}</span>)).map((<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){<span class="cstat-no" title="statement not covered" >return e?t:void 0}</span>)).filter((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return void 0!==e}</span>)).slice(0,2),</span>s=<span class="cstat-no" title="statement not covered" >u.map((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return{vertex:c[t][e],face_vertex_index:e}}</span>));<span class="cstat-no" title="statement not covered" ></span>if(s.length&gt;1){var l=<span class="cstat-no" title="statement not covered" >u[1]-u[0];<span class="cstat-no" title="statement not covered" ></span>if(1===(l&lt;0?l+c[t].length:l))<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >r</span></span>eturn{vertices:s,edges:[]}}</span>v</span>ar v=<span class="cstat-no" title="statement not covered" >a[t].map((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return i[e].map((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return o[e]}</span>))}</span>)).map((<span class="fstat-no" title="function not covered" >fu</span>nction(e){var t;<span class="cstat-no" title="statement not covered" >return(t=Jn.core).intersect_line_seg_exclude.apply(t,[n,r].concat(_toConsumableArray(e)))}</span>)).map((<span class="fstat-no" title="function not covered" >fu</span>nction(e,n){<span class="cstat-no" title="statement not covered" >return{coords:e,face_edge_index:n,edge:a[t][n]}}</span>)).filter((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return void 0!==e.coords}</span>)).slice(0,2);<span class="cstat-no" title="statement not covered" ></span>return s.length&gt;0&amp;&amp;v.length&gt;0?{vertices:s,edges:v}:v.length&gt;1?{vertices:[],edges:v}:void 0}</span>(e,t,n,r);<span class="cstat-no" title="statement not covered" ></span>if(void 0!==o){var i=<span class="cstat-no" title="statement not covered" >o.vertices.map((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return e.vertex}</span>)),</span>c=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>o.edges.map((<span class="fstat-no" title="function not covered" >fu</span>nction(t,n,r){<span class="cstat-no" title="statement not covered" >t.edge=c.length?c[0].edges.map[t.edge]:t.edge,c.push(Ho(e,t.edge,t.coords))}</span>)),i.push.apply(i,_toConsumableArray(c.map((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return e.vertex}</span>))));v</span>ar a=<span class="cstat-no" title="statement not covered" >e.edges_vertices.length,</span>u=<span class="cstat-no" title="statement not covered" >[0,1].map((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return e.faces_vertices.length+t-1}</span>)),</span>s=<span class="cstat-no" title="statement not covered" >function <span class="fstat-no" title="function not covered" >make_edge(</span>e,t,n){var r,o,i=<span class="cstat-no" title="statement not covered" >e.vertices_coords,</span>c=<span class="cstat-no" title="statement not covered" >t.map((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return i[e]}</span>)).reverse();<span class="cstat-no" title="statement not covered" ></span>return{edges_vertices:_toConsumableArray(t),edges_foldAngle:0,edges_assignment:"U",edges_length:(r=Jn.core).distance2.apply(r,_toConsumableArray(c)),edges_vector:(o=Jn.core).subtract.apply(o,_toConsumableArray(c)),edges_faces:_toConsumableArray(n)}}</span>(e,i,u);<span class="cstat-no" title="statement not covered" ></span>Object.keys(s).filter((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return void 0!==e[t]}</span>)).forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >e[t][a]=s[t]}</span>)),function <span class="fstat-no" title="function not covered" >update_vertices_vertices(</span>e,t){var n=<span class="cstat-no" title="statement not covered" >e.vertices_coords,</span>r=<span class="cstat-no" title="statement not covered" >e.vertices_vertices,</span>o=<span class="cstat-no" title="statement not covered" >e.edges_vertices,</span>i=<span class="cstat-no" title="statement not covered" >o[t][0],</span>c=<span class="cstat-no" title="statement not covered" >o[t][1];<span class="cstat-no" title="statement not covered" ></span>r[i]=wr({vertices_coords:n},r[i].concat(c),i),r[c]=wr({vertices_coords:n},r[c].concat(i),c)}</span>(e,a);v</span>ar l=<span class="cstat-no" title="statement not covered" >function <span class="fstat-no" title="function not covered" >make_faces(</span>e,t,n){var r=<span class="cstat-no" title="statement not covered" >e.edges_vertices,</span>o=<span class="cstat-no" title="statement not covered" >e.faces_vertices,</span>i=<span class="cstat-no" title="statement not covered" >Nr({edges_vertices:r}),</span>c=<span class="cstat-no" title="statement not covered" >n.map((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return o[t].indexOf(e)}</span>));<span class="cstat-no" title="statement not covered" ></span>return function <span class="fstat-no" title="function not covered" >split_circular_array(</span>e,t){<span class="cstat-no" title="statement not covered" >return t.sort((<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){<span class="cstat-no" title="statement not covered" >return e-t}</span>)),[e.slice(t[1]).concat(e.slice(0,t[0]+1)),e.slice(t[0],t[1]+1)]}</span>(o[t],c).map((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return{faces_vertices:e,faces_edges:e.map((<span class="fstat-no" title="function not covered" >fu</span>nction(e,t,n){<span class="cstat-no" title="statement not covered" >return"".concat(e," ").concat(n[(t+1)%n.length])}</span>)).map((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return i[e]}</span>))}}</span>))}</span>(e,t,i),</span>v=<span class="cstat-no" title="statement not covered" >go(e,"faces",[t]);<span class="cstat-no" title="statement not covered" ></span>if(l.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(t,n){<span class="cstat-no" title="statement not covered" >return Object.keys(t).filter((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return void 0!==e[t]}</span>)).forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(r){<span class="cstat-no" title="statement not covered" >e[r][u[n]]=t[r]}</span>))}</span>)),e.vertices_faces=Sr(e),e.edges_faces=Fr(e),e.faces_faces=Zr(e),2===c.length){var d=<span class="cstat-no" title="statement not covered" >function <span class="fstat-no" title="function not covered" >invert_array(</span>e){var t=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>return e.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(e,n){<span class="cstat-no" title="statement not covered" >t[e]=n}</span>)),t}</span>(c[0].edges.map);<span class="cstat-no" title="statement not covered" ></span>c[1].edges.remove=d[c[1].edges.remove]}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn v[t]=u,{vertices:i,faces:{map:v,remove:t},edges:{map:so.apply(void 0,_toConsumableArray(c.map((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return e.edges.map}</span>)))),new:a,remove:c.map((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return e.edges.remove}</span>))}}}</span>}</span>,Wo=function <span class="fstat-no" title="function not covered" >fold_faces_layer(</span>e,t){var n=<span class="cstat-no" title="statement not covered" >[],</span>r=<span class="cstat-no" title="statement not covered" >e.map((<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){<span class="cstat-no" title="statement not covered" >return t}</span>)),</span>o=<span class="cstat-no" title="statement not covered" >r.filter((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return t[e]}</span>)),</span>i=<span class="cstat-no" title="statement not covered" >r.filter((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return!t[e]}</span>));<span class="cstat-no" title="statement not covered" ></span>return i.sort((<span class="fstat-no" title="function not covered" >fu</span>nction(t,n){<span class="cstat-no" title="statement not covered" >return e[t]-e[n]}</span>)).forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){<span class="cstat-no" title="statement not covered" >n[e]=t}</span>)),o.sort((<span class="fstat-no" title="function not covered" >fu</span>nction(t,n){<span class="cstat-no" title="statement not covered" >return e[n]-e[t]}</span>)).forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){<span class="cstat-no" title="statement not covered" >n[e]=i.length+t}</span>)),n}</span>,Jo=function <span class="fstat-no" title="function not covered" >get_face_sidedness(</span>e,t,n,r){var o=<span class="cstat-no" title="statement not covered" >[n[0]-t[0],n[1]-t[1]],</span>i=<span class="cstat-no" title="statement not covered" >e[0]*o[1]-e[1]*o[0];<span class="cstat-no" title="statement not covered" ></span>return r?i&gt;0:i&lt;0}</span>,Ko=function <span class="fstat-no" title="function not covered" >make_face_center_fast(</span>e,t){<span class="cstat-no" title="statement not covered" >return e.faces_vertices[t]?e.faces_vertices[t].map((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return e.vertices_coords[t]}</span>)).reduce((<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){<span class="cstat-no" title="statement not covered" >return[e[0]+t[0],e[1]+t[1]]}</span>),[0,0]).map((<span class="fstat-no" title="function not covered" >fu</span>nction(n){<span class="cstat-no" title="statement not covered" >return n/e.faces_vertices[t].length}</span>)):[0,0]}</span>,Qo=function <span class="fstat-no" title="function not covered" >prepare_graph_crease(</span>e,t,n,r){var o=<span class="cstat-no" title="statement not covered" >po.faces(e),</span>i=<span class="cstat-no" title="statement not covered" >Array.from(Array(o));<span class="cstat-no" title="statement not covered" ></span>e["faces_re:layer"]||(e["faces_re:layer"]=Array(o).fill(0)),e["faces_re:preindex"]=i.map((<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){<span class="cstat-no" title="statement not covered" >return t}</span>)),e.faces_matrix||(e.faces_matrix=Hr(e,r)),e.faces_coloring=Yr(e),e["faces_re:creases"]=e.faces_matrix.map((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return Jn.core.invert_matrix3(e)}</span>)).map((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return Jn.core.multiply_matrix3_line3(e,t,n)}</span>)),e.faces_center=i.map((<span class="fstat-no" title="function not covered" >fu</span>nction(t,n){<span class="cstat-no" title="statement not covered" >return Ko(e,n)}</span>)),e["faces_re:sidedness"]=i.map((<span class="fstat-no" title="function not covered" >fu</span>nction(t,n){<span class="cstat-no" title="statement not covered" >return Jo(e["faces_re:creases"][n].vector,e["faces_re:creases"][n].origin,e.faces_center[n],e.faces_coloring[n])}</span>))}</span>,ei=function <span class="fstat-no" title="function not covered" >two_furthest_points(</span>e){var t=<span class="cstat-no" title="statement not covered" >[0,-1/0],</span>n=<span class="cstat-no" title="statement not covered" >[1/0,0],</span>r=<span class="cstat-no" title="statement not covered" >[-1/0,0],</span>o=<span class="cstat-no" title="statement not covered" >[0,1/0];<span class="cstat-no" title="statement not covered" ></span>return e.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >e[0]&lt;n[0]&amp;&amp;(n=e),e[0]&gt;r[0]&amp;&amp;(r=e),e[1]&lt;o[1]&amp;&amp;(o=e),e[1]&gt;t[1]&amp;&amp;(t=e)}</span>)),Math.abs(t[1]-o[1])&gt;Math.abs(r[0]-n[0])?[o,t]:[n,r]}</span>,ti={M:"V",m:"V",V:"M",v:"M"},ni=function <span class="fstat-no" title="function not covered" >opposingCrease(</span>e){<span class="cstat-no" title="statement not covered" >return ti[e]||e}</span>,ri=function <span class="fstat-no" title="function not covered" >flat_fold(</span>e,t,n,r){var o=<span class="cstat-no" title="statement not covered" >arguments.length&gt;4&amp;&amp;void 0!==arguments[4]?arguments[4]:"V",</span>i=<span class="cstat-no" title="statement not covered" >ni(o);<span class="cstat-no" title="statement not covered" ></span>if(null==r){var c=<span class="cstat-no" title="statement not covered" >ro(e,n);<span class="cstat-no" title="statement not covered" ></span>r=void 0===c?0:c}<span class="cstat-no" title="statement not covered" ></span>t</span>=Jn.core.resize(3,t),n=Jn.core.resize(3,n),Qo(e,t,n,r);v</span>ar a=<span class="cstat-no" title="statement not covered" >Xo(e);<span class="cstat-no" title="statement not covered" ></span>a.vertices_coords.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return e.splice(2)}</span>));v</span>ar u=<span class="cstat-no" title="statement not covered" >Array.from(Array(po.faces(e))).map((<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){<span class="cstat-no" title="statement not covered" >return t}</span>)).reverse().map((<span class="fstat-no" title="function not covered" >fu</span>nction(t){var n=<span class="cstat-no" title="statement not covered" >a.faces_coloring[t],</span>r=<span class="cstat-no" title="statement not covered" >Yo(a,t,a["faces_re:creases"][t].vector,a["faces_re:creases"][t].origin);<span class="cstat-no" title="statement not covered" ></span>if(void 0!==r)<span class="cstat-no" title="statement not covered" >return a.edges_assignment[r.edges.new]=n?o:i,a.edges_foldAngle[r.edges.new]=n?fr[o]||0:fr[i]||0,r.faces.map[r.faces.remove].forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >a.faces_center[t]=Ko(a,t),a["faces_re:sidedness"][t]=Jo(e["faces_re:creases"][r.faces.remove].vector,e["faces_re:creases"][r.faces.remove].origin,a.faces_center[t],e.faces_coloring[r.faces.remove]),a["faces_re:layer"][t]=e["faces_re:layer"][r.faces.remove],a["faces_re:preindex"][t]=e["faces_re:preindex"][r.faces.remove]}</span>)),r}</span></span>)).reverse();<span class="cstat-no" title="statement not covered" ></span>a["faces_re:layer"]=Wo(a["faces_re:layer"],a["faces_re:sidedness"]);v</span>ar s=<span class="cstat-no" title="statement not covered" >void 0===u[0]?0:a["faces_re:preindex"].map((<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){<span class="cstat-no" title="statement not covered" >return{pre:e,new:t}}</span>)).filter((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return 0===e.pre}</span>)).filter((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return a["faces_re:sidedness"][e.new]}</span>)).shift().new,</span>l=<span class="cstat-no" title="statement not covered" >e.faces_matrix[0];<span class="cstat-no" title="statement not covered" ></span>"M"!==o&amp;&amp;"m"!==o&amp;&amp;"V"!==o&amp;&amp;"v"!==o||(l=void 0!==u[0]||e["faces_re:sidedness"][0]?Jn.core.multiply_matrices3(e.faces_matrix[0],Jn.core.make_matrix3_reflectZ(e["faces_re:creases"][0].vector,e["faces_re:creases"][0].origin)):e.faces_matrix[0]);v</span>ar v=<span class="cstat-no" title="statement not covered" >Hr(a,s).map((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return Jn.core.multiply_matrices3(l,e)}</span>));<span class="cstat-no" title="statement not covered" ></span>a.faces_coloring=Yr({faces_matrix:v});v</span>ar d=<span class="cstat-no" title="statement not covered" >Jn.core.multiply_matrix3_line3(l,e["faces_re:creases"][0].vector,e["faces_re:creases"][0].origin),</span>p=<span class="cstat-no" title="statement not covered" >Jn.core.normalize(Jn.core.rotate270(d.vector)),</span>h=<span class="cstat-no" title="statement not covered" >u.map((<span class="fstat-no" title="function not covered" >fu</span>nction(t,n){<span class="cstat-no" title="statement not covered" >return void 0===t?void 0:a.edges_vertices[t.edges.new].map((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return a.vertices_coords[e]}</span>)).map((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return Jn.core.multiply_matrix3_vector3(e.faces_matrix[n],t)}</span>))}</span>)).filter((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return void 0!==e}</span>)).reduce((<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){<span class="cstat-no" title="statement not covered" >return e.concat(t)}</span>),[]);<span class="cstat-no" title="statement not covered" ></span>return a["re:construction"]=0===h.length?{type:"flip",direction:p}:{type:"fold",assignment:o,direction:p,edge:ei(h)},a.faces_matrix=v,a["vertices_re:foldedCoords"]=Tr(a,s),a.faces_matrix=v,delete e["faces_re:creases"],delete a["faces_re:creases"],delete e["faces_re:sidedness"],delete a["faces_re:sidedness"],delete e["faces_re:preindex"],delete a["faces_re:preindex"],delete e.faces_coloring,delete a.faces_coloring,delete e.faces_center,delete a.faces_center,a}</span>,oi=function clean(e){var t=arguments.length&gt;1&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >void 0!==arguments[1]?<span class="branch-0 cbranch-no" title="branch not covered" ></span>arguments[1]:</span>{};return"object"===_typeof(t)&amp;&amp;!1===t.edges||(To(e),Fo(e)),"object"===_typeof(t)&amp;&amp;!0===t.vertices&amp;&amp;<span class="branch-2 cbranch-no" title="branch not covered" >qo(e),</span>e},ii=function invert_array(e){var t=[];return e.forEach((function(e,n){t[e]=n})),t},ci={V:1,v:1,M:-1,m:-1},ai=function upOrDown(e,t){return t%2==0?ci[e]:-ci[e]},ui=function between(e,t,n){return t&lt;n?e.slice(t+1,n):e.slice(n+1,t)},si=function get_sectors_layer(e,t){var n=arguments.length&gt;2&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >void 0!==arguments[2]?<span class="branch-0 cbranch-no" title="branch not covered" ></span>arguments[2]:</span>Jn.core.EPSILON,r=0,o=e.map((function(e,t){return t%2==0?e:-e})).map((function(e){return r+=e})),i=o.map((function(e,t,n){return t%2==0?n[(t+n.length-1)%n.length]:e})).map((function(e){return e+n})),c=o.map((function(e,t,n){return t%2==0?e:n[(t+n.length-1)%n.length]})).map((function(e){return e-n})),a=function test(t){var n=[];t.forEach((function(e,t){n[e]=t}));for(var r=t.length+(t.length===e.length?0:-1),a=function _loop(e){var r=(e+1)%t.length,a=ui(t,n[e],n[r]),u=a.map((function(t){return o[e]&lt;i[t]})).reduce(Oo,!0),s=a.map((function(t){return o[e]&gt;c[t]})).reduce(Oo,!0);if(!u&amp;&amp;!s)return{v:!1}},u=0;u&lt;r;u+=1){var s=a(u);if("object"===_typeof(s))return s.v}return!0},u=function final_test(e){var n=ii(e);return n[0]&gt;n[n.length-1]?<span class="branch-0 cbranch-no" title="branch not covered" >"M"===t[0]:</span>"V"===t[0]},s=function recurse(){var n=arguments.length&gt;0&amp;&amp;void 0!==arguments[0]?arguments[0]:[],r=arguments.length&gt;1&amp;&amp;void 0!==arguments[1]?arguments[1]:0,o=arguments.length&gt;2&amp;&amp;void 0!==arguments[2]?arguments[2]:0;if(n=n.slice(0,o).concat([r],n.slice(o,n.length)),!a(n))return[];if(r&gt;=e.length-1)return u(n)?[n]:<span class="branch-1 cbranch-no" title="branch not covered" >[];</span>var i=ai(t[(r+1)%e.length],r),c=1===i?Array.from(Array(n.length-o)).map((function(e,t){return o+t+1})):Array.from(Array(o+1)).map((function(e,t){return t}));return c.map((function(e){return recurse(n,r+1,e)})).reduce((function(e,t){return e.concat(t)}),[]).map(ii)};return s()},fi=function <span class="fstat-no" title="function not covered" >odd_assignment(</span>e){<span class="cstat-no" title="statement not covered" >for(var t=<span class="cstat-no" title="statement not covered" >0,</span>n=<span class="cstat-no" title="statement not covered" >0,</span>r=<span class="cstat-no" title="statement not covered" >0;</span>r&lt;e.length;r+=1)<span class="cstat-no" title="statement not covered" >"M"!==e[r]&amp;&amp;"m"!==e[r]||(t+=1),"V"!==e[r]&amp;&amp;"v"!==e[r]||(n+=1);<span class="cstat-no" title="statement not covered" >f</span></span>or(var o=<span class="cstat-no" title="statement not covered" >0;</span>o&lt;e.length;o+=1){<span class="cstat-no" title="statement not covered" >if(t&gt;n&amp;&amp;("V"===e[o]||"v"===e[o]))<span class="cstat-no" title="statement not covered" >return o;<span class="cstat-no" title="statement not covered" >i</span></span>f(n&gt;t&amp;&amp;("M"===e[o]||"m"===e[o]))<span class="cstat-no" title="statement not covered" >return o}</span></span>}</span>,li=Object.assign(Object.create(null),{assign:ko,add_vertices:mo,add_vertices_split_edges:function <span class="fstat-no" title="function not covered" >add_vertices_split_edges(</span>e,t){var n=<span class="cstat-no" title="statement not covered" >mo(e,t),</span>r=<span class="cstat-no" title="statement not covered" >e.edges_vertices.map((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t.map((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return e.vertices_coords[t]}</span>))}</span>)),</span>o=<span class="cstat-no" title="statement not covered" >t.map((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return r.map((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return Jn.core.point_on_segment_exclusive(e,t[0],t[1])}</span>)).map((<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){<span class="cstat-no" title="statement not covered" >return e?t:void 0}</span>)).filter((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return void 0!==e}</span>)).shift()}</span>)),</span>i=<span class="cstat-no" title="statement not covered" >o.filter((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return void 0!==e}</span>)),</span>c=<span class="cstat-no" title="statement not covered" >o.map((<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){<span class="cstat-no" title="statement not covered" >return{e:e,i:t}}</span>)).filter((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return void 0!==e.e}</span>)).map((<span class="fstat-no" title="function not covered" >fu</span>nction(t){var r=<span class="cstat-no" title="statement not covered" >mr(e,"edges",t.e);<span class="cstat-no" title="statement not covered" ></span>return[r,Xo(r)].map((<span class="fstat-no" title="function not covered" >fu</span>nction(r,o){<span class="cstat-no" title="statement not covered" >return Object.assign(r,{edges_vertices:[e.edges_vertices[t.e][o],n[t.i]]})}</span>))}</span>)).reduce((<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){<span class="cstat-no" title="statement not covered" >return e.concat(t)}</span>),[]),</span>a=<span class="cstat-no" title="statement not covered" >po.edges(e),</span>u=<span class="cstat-no" title="statement not covered" >{new:{edges:[]}};<span class="cstat-no" title="statement not covered" ></span>return c.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(t,n){<span class="cstat-no" title="statement not covered" >return Object.keys(t).forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(r){<span class="cstat-no" title="statement not covered" >void 0===e[r]&amp;&amp;(e[r]=[]),e[r][a+n]=t[r],u.new.edges[n]=a+n}</span>))}</span>)),go(e,"edges",i),n}</span>,add_edges:$o,split_edge:Ho,split_face:Yo,flat_fold:ri,clean:oi,get_circular_edges:No,get_duplicate_edges:zo,get_duplicate_vertices:Lo,get_collinear_vertices:Bo,count:po,implied:xr,fragment:Zo,remove:go,populate:ho,subgraph:Mo,explode_faces:function <span class="fstat-no" title="function not covered" >explode_faces(</span>e){var t=<span class="cstat-no" title="statement not covered" >e.faces_vertices.map((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t.map((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return e.vertices_coords[t]}</span>))}</span>)).reduce((<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){<span class="cstat-no" title="statement not covered" >return e.concat(t)}</span>),[]),</span>n=<span class="cstat-no" title="statement not covered" >0,</span>r=<span class="cstat-no" title="statement not covered" >e.faces_vertices.map((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return e.map((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return n++}</span>))}</span>));<span class="cstat-no" title="statement not covered" ></span>return{vertices_coords:JSON.parse(JSON.stringify(t)),faces_vertices:r}}</span>,layer_solver:si,assignment_solver:function <span class="fstat-no" title="function not covered" >assignment_solver(</span>e,t){<span class="cstat-no" title="statement not covered" >null==t&amp;&amp;(t=e.map((<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return"U"}</span>)));v</span>ar n=<span class="cstat-no" title="statement not covered" >function <span class="fstat-no" title="function not covered" >all_possible_assignments(</span>e){var t=<span class="cstat-no" title="statement not covered" >function <span class="fstat-no" title="function not covered" >get_unassigneds(</span>e){<span class="cstat-no" title="statement not covered" >return e.map((<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){<span class="cstat-no" title="statement not covered" >return t}</span>)).filter((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return"U"===e[t]||"u"===e[t]}</span>))}</span>(e),</span>n=<span class="cstat-no" title="statement not covered" >Array.from(Array(Math.pow(2,t.length))).map((<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){<span class="cstat-no" title="statement not covered" >return t.toString(2)}</span>)).map((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return Array(t.length-e.length+1).join("0")+e}</span>)).map((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return Array.from(e).map((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return"0"===e?"V":"M"}</span>))}</span>)).map((<span class="fstat-no" title="function not covered" >fu</span>nction(n){var r=<span class="cstat-no" title="statement not covered" >e.slice();<span class="cstat-no" title="statement not covered" ></span>return t.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){<span class="cstat-no" title="statement not covered" >r[e]=n[t]}</span>)),r}</span>)),</span>r=<span class="cstat-no" title="statement not covered" >n.map((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return e.filter((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return"M"===e||"m"===e}</span>)).length}</span>)),</span>o=<span class="cstat-no" title="statement not covered" >n.map((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return e.filter((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return"V"===e||"v"===e}</span>)).length}</span>));<span class="cstat-no" title="statement not covered" ></span>return n.filter((<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){<span class="cstat-no" title="statement not covered" >return 2===Math.abs(r[t]-o[t])}</span>))}</span>(t),</span>r=<span class="cstat-no" title="statement not covered" >n.map((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return si(e,t)}</span>));<span class="cstat-no" title="statement not covered" ></span>return n.map((<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){<span class="cstat-no" title="statement not covered" >return t}</span>)).filter((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return r[e].length&gt;0}</span>)).map((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return{assignment:n[e],layer:r[e]}}</span>))}</span>,single_vertex_fold_angles:function <span class="fstat-no" title="function not covered" >single_vertex_fold_angles(</span>e,t){var n=<span class="cstat-no" title="statement not covered" >arguments.length&gt;2&amp;&amp;void 0!==arguments[2]?arguments[2]:0,</span>r=<span class="cstat-no" title="statement not covered" >fi(t);<span class="cstat-no" title="statement not covered" ></span>if(void 0!==r){var o=<span class="cstat-no" title="statement not covered" >e[(r+1)%e.length],</span>i=<span class="cstat-no" title="statement not covered" >e[(r+2)%e.length],</span>c=<span class="cstat-no" title="statement not covered" >Math.PI*n,</span>a=<span class="cstat-no" title="statement not covered" >-Math.cos(o)*Math.cos(i)+Math.sin(o)*Math.sin(i)*Math.cos(Math.PI-c),</span>u=<span class="cstat-no" title="statement not covered" >Math.cos(Math.PI-c)-Math.pow(Math.sin(Math.PI-c),2)*Math.sin(o)*Math.sin(i)/(1-a),</span>s=<span class="cstat-no" title="statement not covered" >-Math.acos(u)+Math.PI;<span class="cstat-no" title="statement not covered" ></span>return r%2==0?[s,c,s,c].map((<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){<span class="cstat-no" title="statement not covered" >return r===t?-e:e}</span>)):[c,s,c,s].map((<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){<span class="cstat-no" title="statement not covered" >return r===t?-e:e}</span>))}</span>}</span>},Wr,eo,Eo,Kr,kr,io,br,Mr,uo,lo,Go,Po),vi=function best_fit_arrow(e,t){Jr(e).vertices;var n,r=Qr(e,t),o=((n=Jn.core).midpoint.apply(n,_toConsumableArray(r)),{vector:Jn.core.rotate90(t.vector),origin:t.origin});return Qr(e,o)},di=Object.freeze({__proto__:null,one_crease_arrow:function one_crease_arrow(e,t,n,r){return vi(e,t)}}),pi=function <span class="fstat-no" title="function not covered" >line_line_for_arrows(</span>e,t){<span class="cstat-no" title="statement not covered" >return Jn.core.intersect_lines(e.vector,e.origin,t.vector,t.origin,Jn.core.include_l,Jn.core.include_l)}</span>,_i=function <span class="fstat-no" title="function not covered" >reflect_point(</span>e,t){var n=<span class="cstat-no" title="statement not covered" >Jn.core.intersect_lines(e.vector,e.origin,Jn.core.rotate270(e.vector),t,Jn.core.include_l,Jn.core.include_l),</span>r=<span class="cstat-no" title="statement not covered" >Jn.core.subtract(n,t);<span class="cstat-no" title="statement not covered" ></span>return Jn.core.add(n,r)}</span>,gi=function boundary_for_arrows(e){var t=e.vertices_coords;return Jn.core.convex_hull(t)},hi=function widest_perp(e,t,n){var r=gi(e);<span class="missing-if-branch" title="else path not taken" >E</span>if(void 0===n){var o,i=Jn.core.clip_line_in_convex_poly_exclusive(r,t.vector,t.origin);n=(o=Jn.core).midpoint.apply(o,_toConsumableArray(i))}var c=Jn.core.rotate270(t.vector),a=Jn.core.clip_line_in_convex_poly_exclusive(r,c,n).map((function(e){return Jn.core.distance(n,e)})).sort((function(e,t){return e-t})).shift(),u=Jn.core.scale(Jn.core.normalize(c),a);return[Jn.core.add(n,Jn.core.flip(u)),Jn.core.add(n,u)]},mi=[null,function axiom_1_arrows(e,t,n){return[hi(n,t)]},function <span class="fstat-no" title="function not covered" >axiom_2_arrows(</span>e){<span class="cstat-no" title="statement not covered" >return[e.points]}</span>,function <span class="fstat-no" title="function not covered" >axiom_3_arrows(</span>e,t,n){var r,o,i,c,a=<span class="cstat-no" title="statement not covered" >gi(n),</span>u=<span class="cstat-no" title="statement not covered" >e.lines.map((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return Jn.core.clip_line_in_convex_poly_exclusive(a,e.vector,e.origin)}</span>)),</span>s=<span class="cstat-no" title="statement not covered" >Jn.core.intersect_seg_seg_exclude(u[0][0],u[0][1],u[1][0],u[1][1]);<span class="cstat-no" title="statement not covered" ></span>if(s){var l=<span class="cstat-no" title="statement not covered" >e.lines.map((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return e.vector}</span>)),</span>v=<span class="cstat-no" title="statement not covered" >l.map(Jn.core.flip),</span>d=<span class="cstat-no" title="statement not covered" >l.concat(v).map((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return Jn.ray(e,s)}</span>)),</span>p=<span class="cstat-no" title="statement not covered" >d.filter((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return Jn.core.dot(e.vector,t.vector)&gt;0&amp;&amp;Jn.core.cross2(e.vector,t.vector)&gt;0}</span>)).shift(),</span>h=<span class="cstat-no" title="statement not covered" >d.filter((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return Jn.core.dot(e.vector,t.vector)&gt;0&amp;&amp;Jn.core.cross2(e.vector,t.vector)&lt;0}</span>)).shift(),</span>m=<span class="cstat-no" title="statement not covered" >d.filter((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return Jn.core.dot(e.vector,t.vector)&lt;0&amp;&amp;Jn.core.cross2(e.vector,t.vector)&gt;0}</span>)).shift(),</span>b=<span class="cstat-no" title="statement not covered" >d.filter((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return Jn.core.dot(e.vector,t.vector)&lt;0&amp;&amp;Jn.core.cross2(e.vector,t.vector)&lt;0}</span>)).shift(),</span>k=<span class="cstat-no" title="statement not covered" >[p,h,m,b].map((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return Jn.core.convex_poly_ray_exclusive(a,e.vector,e.origin).shift().shift()}</span>)),</span>w=<span class="cstat-no" title="statement not covered" >k.map((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return Jn.core.distance(e,s)}</span>));<span class="cstat-no" title="statement not covered" ></span>w[0]&lt;w[1]?(r=k[0],o=Jn.core.add(h.origin,h.vector.normalize().scale(w[0]))):(r=k[1],o=Jn.core.add(p.origin,p.vector.normalize().scale(w[1]))),w[2]&lt;w[3]?(i=k[2],c=Jn.core.add(b.origin,b.vector.normalize().scale(w[2]))):(i=k[3],c=Jn.core.add(m.origin,m.vector.normalize().scale(w[3])))}</span>else{var E,M=<span class="cstat-no" title="statement not covered" >u.map((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return Jn.core.midpoint(e[0],e[1])}</span>)),</span>O=<span class="cstat-no" title="statement not covered" >(E=Jn.line).fromPoints.apply(E,_toConsumableArray(M)),</span>j=<span class="cstat-no" title="statement not covered" >Jn.intersect(t,O),</span>C=<span class="cstat-no" title="statement not covered" >Jn.line(t.vector.rotate90(),j),</span>S=<span class="cstat-no" title="statement not covered" >e.lines.map((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return Jn.intersect(e,C)}</span>));<span class="cstat-no" title="statement not covered" ></span>r=S[0],o=S[1]}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn void 0===i?[[r,o]]:[[r,o],[i,c]]}</span>,function <span class="fstat-no" title="function not covered" >axiom_4_arrows(</span>e,t,n){<span class="cstat-no" title="statement not covered" >return[hi(n,t,pi(t,e.lines[0]))]}</span>,function <span class="fstat-no" title="function not covered" >axiom_5_arrows(</span>e,t){<span class="cstat-no" title="statement not covered" >return[[e.points[1],_i(t,e.points[1])]]}</span>,function <span class="fstat-no" title="function not covered" >axiom_6_arrows(</span>e,t){<span class="cstat-no" title="statement not covered" >return e.points.map((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return[e,_i(t,e)]}</span>))}</span>,function <span class="fstat-no" title="function not covered" >axiom_7_arrows(</span>e,t,n){<span class="cstat-no" title="statement not covered" >return[[e.points[0],_i(t,e.points[0])],hi(n,t,pi(t,e.lines[1]))]}</span>];delete mi[0];var yi=Object.assign(Object.create(null),di,{axiom_arrows:mi}),bi=Object.create(null),xi=function vertex_degree(e,t){var n=this;Object.defineProperty(e,"degree",{get:function get(){return n.vertices_vertices&amp;&amp;n.vertices_vertices[t]?<span class="branch-0 cbranch-no" title="branch not covered" >n.vertices_vertices[t].length:</span>null}})},Ai=function edge_coords(e,t){var n=this;Object.defineProperty(e,"coords",{get:function get(){if(n.edges_vertices&amp;&amp;n.edges_vertices[t]&amp;&amp;n.vertices_coords)return n.edges_vertices[t].map((function(e){return n.vertices_coords[e]}))}})},ki=function face_simple(e,t){var n=this;Object.defineProperty(e,"simple",{get:function get(){if(!n.faces_vertices||!n.faces_vertices[t])return null;for(var r=0;r&lt;e.length-1;r+=1)<span class="cstat-no" title="statement not covered" >for(var o=<span class="cstat-no" title="statement not covered" >r+1;</span>o&lt;e.length;o+=1)<span class="cstat-no" title="statement not covered" >if(n.faces_vertices[t][r]===n.faces_vertices[t][o])<span class="cstat-no" title="statement not covered" >return!1;r</span></span></span>eturn!0}})},wi=function face_coords(e,t){var n=this;Object.defineProperty(e,"coords",{get:function get(){if(n.faces_vertices&amp;&amp;n.faces_vertices[t]&amp;&amp;n.vertices_coords)return n.faces_vertices[t].map((function(e){return n.vertices_coords[e]}))}})},Ei={vertices:function setup_vertex(e,t){return xi.call(this,e,t),e},edges:function setup_edge(e,t){return Ai.call(this,e,t),e},faces:function setup_face(e,t){return ki.call(this,e,t),wi.call(this,e,t),e}},Mi={};Mi.prototype=Object.create(Object.prototype),Mi.prototype.constructor=Mi;var Oi=Object.assign({clean:oi,populate:ho,fragment:Zo,subgraph:Mo,assign:ko},Eo);Object.keys(Oi).forEach((function(e){Mi.prototype[e]=function(){return Oi[e].apply(Oi,[this].concat(Array.prototype.slice.call(arguments)))}})),Mi.prototype.copy=function(){return Object.assign(Object.create(Mi.prototype),Xo(this))},Mi.prototype.load=function(e){var t=this,n=arguments.length&gt;1&amp;&amp;void 0!==arguments[1]?arguments[1]:{};"object"===_typeof(e)&amp;&amp;(!0!==n.append&amp;&amp;nr.forEach((function(e){return delete t[e]})),Object.assign(this,{file_spec:Qn,file_creator:er},Xo(e)))},Mi.prototype.clear=function(){var e=this;tr.graph.forEach((function(t){return delete e[t]})),tr.orders.forEach((function(t){return delete e[t]})),delete this.file_frames};var ji=function shortenKeys(e,t,n){var r=this,o=Object.create(null);return Object.keys(e).forEach((function(t){o[t.substring(r.length+1)]=e[t]})),o},Ci=function getComponent(e){return hr(this,e).map(ji.bind(e)).map(Ei[e].bind(this))};["vertices","edges","faces"].forEach((function(e){return Object.defineProperty(Mi.prototype,e,{get:function get(){return Ci.call(this,e)}})})),Object.defineProperty(Mi.prototype,"junctions",{get:function <span class="fstat-no" title="function not covered" >get(</span>){<span class="cstat-no" title="statement not covered" >return Lr(this).map((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return Jn.junction.apply(Jn,_toConsumableArray(e))}</span>))}</span>}),Object.defineProperty(Mi.prototype,"boundary",{get:function get(){var e=this,t=Jr(this),n=Jn.polygon(t.vertices.map((function(t){return e.vertices_coords[t]})));return Object.keys(t).forEach((function(e){n[e]=t[e]})),n}});var Si={vertices:to,edges:no,faces:ro},Pi=function nearestElement(e){for(var t,n=arguments.length,r=new Array(n&gt;1?n-1:<span class="branch-1 cbranch-no" title="branch not covered" >0)</span>,o=1;o&lt;n;o++)r[o-1]=arguments[o];var i=(t=Jn.core).get_vector.apply(t,r),c=Si[e](this,i),a=mr(this,e,c);return Ei[e].call(this,a,c),a.index=c,a};Mi.prototype.nearest=function(){var e=arguments,t=this,n=Object.create(null);return["vertices","edges","faces"].forEach((function(r){return Object.defineProperty(n,sr[r],{get:function get(){return Pi.call.apply(Pi,[t,r].concat(_toConsumableArray(e)))}})})),n};var Ni=Mi.prototype,zi={};zi.prototype=Object.create(Ni),zi.prototype.constructor=zi;zi.prototype.copy=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return Object.assign(Object.create(zi.prototype),Xo(this))}</span>,["line","ray","segment"].forEach((function(e){zi.prototype[e]=<span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" >Jn[e].apply(Jn,arguments);<span class="cstat-no" title="statement not covered" ></span>if(t){var n=<span class="cstat-no" title="statement not covered" >Qr(this,t);<span class="cstat-no" title="statement not covered" ></span>if(n){var r=<span class="cstat-no" title="statement not covered" >mo(this,n),</span>o=<span class="cstat-no" title="statement not covered" >$o(this,r),</span>i=<span class="cstat-no" title="statement not covered" >Zo(this).edges.map;<span class="cstat-no" title="statement not covered" ></span>return ho(this),o.map((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return i[e]}</span>))}</span>}</span>}</span>})),["circle","ellipse","rect","polygon"].forEach((function(e){zi.prototype[e]=<span class="fstat-no" title="function not covered" >fu</span>nction(){var t=<span class="cstat-no" title="statement not covered" >this,</span>n=<span class="cstat-no" title="statement not covered" >Jn[e].apply(Jn,arguments);<span class="cstat-no" title="statement not covered" ></span>if(n){var r=<span class="cstat-no" title="statement not covered" >n.segments(96).map((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return Jn.segment(e)}</span>)).map((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return Qr(t,e)}</span>)).filter((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return void 0!==e}</span>));<span class="cstat-no" title="statement not covered" ></span>if(r){var o=<span class="cstat-no" title="statement not covered" >[],</span>i=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>r.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(e){var n=<span class="cstat-no" title="statement not covered" >mo(t,e);<span class="cstat-no" title="statement not covered" ></span>o.push.apply(o,_toConsumableArray(n)),i.push.apply(i,_toConsumableArray($o(t,n)))}</span>));v</span>ar c=<span class="cstat-no" title="statement not covered" >Zo(this).edges.map;<span class="cstat-no" title="statement not covered" ></span>return ho(this),i.map((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return c[e]}</span>))}</span>}</span>}</span>}));var Ii=zi.prototype,Li={};Li.prototype=Object.create(Ni),Li.prototype.constructor=Li,Li.prototype.flatFold=<span class="fstat-no" title="function not covered" >fu</span>nction(){var e=<span class="cstat-no" title="statement not covered" >this,</span>t=<span class="cstat-no" title="statement not covered" >Jn.core.get_line(arguments),</span>n=<span class="cstat-no" title="statement not covered" >ri(this,t.vector,t.origin);<span class="cstat-no" title="statement not covered" ></span>return[rr,or,ir].map((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return _r(e,t)}</span>)).reduce(jo,[]).forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return delete e[t]}</span>)),Object.assign(this,n),this}</span>,Li.prototype.copy=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return Object.assign(Object.create(Li.prototype),Xo(this))}</span>,Li.prototype.folded=<span class="fstat-no" title="function not covered" >fu</span>nction(){var e=<span class="cstat-no" title="statement not covered" >Tr(this);<span class="cstat-no" title="statement not covered" ></span>return Object.assign(Object.create(Li.prototype),Object.assign(Xo(this),{vertices_coords:e}))}</span>;var qi=Li.prototype,Ti=function make_polygon_vertices(e){return 4===e?[[0,0],[1,0],[1,1],[0,1]]:<span class="branch-1 cbranch-no" title="branch not covered" >Jn.core.make_regular_polygon(e,.5/Math.sin(Math.PI/e))}</span>,Fi={},Vi=[null,null,null,"triangle","square","pentagon","hexagon","heptagon","octogon","nonagon","decagon","hendecagon","dodecagon"];[0,1,2].forEach((function(e){delete Vi[e]}));var Gi=function create_init(e){return ho(e)};Vi.forEach((function(e,t){var n=Array.from(Array(t));Fi[e]=function(){return Gi({vertices_coords:Ti(t),edges_vertices:n.map((function(e,t){return[t,(t+1)%n.length]})),edges_assignment:n.map((function(){return"B"}))})}})),Fi.circle=<span class="fstat-no" title="function not covered" >fu</span>nction(){var e=<span class="cstat-no" title="statement not covered" >arguments.length&gt;0&amp;&amp;void 0!==arguments[0]?arguments[0]:90;<span class="cstat-no" title="statement not covered" ></span>return Gi({vertices_coords:Jn.core.make_regular_polygon(e,1),edges_vertices:Array.from(Array(e)).map((<span class="fstat-no" title="function not covered" >fu</span>nction(e,t,n){<span class="cstat-no" title="statement not covered" >return[t,(t+1)%n.length]}</span>)),edges_assignment:Array.from(Array(e)).map((<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return"B"}</span>))})}</span>,Fi.kite=function(){return Gi({vertices_coords:[[0,0],[Math.sqrt(2)-1,0],[1,0],[1,1-(Math.sqrt(2)-1)],[1,1],[0,1]],edges_vertices:[[0,1],[1,2],[2,3],[3,4],[4,5],[5,0],[5,1],[3,5],[5,2]],edges_assignment:["B","B","B","B","B","B","V","V","F"]})};var Bi=[null,Jn.core.axiom1,Jn.core.axiom2,Jn.core.axiom3,Jn.core.axiom4,Jn.core.axiom5,Jn.core.axiom6,Jn.core.axiom7];delete Bi[0];var Di=function <span class="fstat-no" title="function not covered" >axiom(</span>e,t){<span class="cstat-no" title="statement not covered" >return Bi[e].apply(Bi,_toConsumableArray(function <span class="fstat-no" title="function not covered" >sort_axiom_params(</span>e,t,n){<span class="cstat-no" title="statement not covered" >switch(e){case"1":case"2":case 1:case 2:<span class="cstat-no" title="statement not covered" >return t;c</span>ase"3":case 3:<span class="cstat-no" title="statement not covered" >return[n[0].vector,n[0].origin,n[1].vector,n[1].origin];c</span>ase"4":case 4:<span class="cstat-no" title="statement not covered" >return[n[0].vector,t[0]];c</span>ase"5":case 5:<span class="cstat-no" title="statement not covered" >return[n[0].vector,n[0].origin,t[0],t[1]];c</span>ase"6":case 6:<span class="cstat-no" title="statement not covered" >return[n[0].vector,n[0].origin,n[1].vector,n[1].origin,t[0],t[1]];c</span>ase"7":case 7:<span class="cstat-no" title="statement not covered" >return[n[0].vector,n[0].origin,n[1].vector,t[0]]}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn[]}</span>(e,t.points.map((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return Jn.core.get_vector(e)}</span>)),t.lines.map((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return Jn.core.get_line(e)}</span>)))))}</span>;Object.keys(Bi).forEach((function(e){Di[e]=Bi[e]}));var Ri,Ui={axioms:{ar:[null,"اصنع خطاً يمر بنقطتين","اصنع خطاً عن طريق طي نقطة واحدة إلى أخرى","اصنع خطاً عن طريق طي خط واحد على آخر","اصنع خطاً يمر عبر نقطة واحدة ويجعل خطاً واحداً فوق نفسه","اصنع خطاً يمر بالنقطة الأولى ويجعل النقطة الثانية على الخط","اصنع خطاً يجلب النقطة الأولى إلى الخط الأول والنقطة الثانية إلى الخط الثاني","اصنع خطاً يجلب نقطة إلى خط ويجعل خط ثاني فوق نفسه"],de:[null,"Falte eine Linie durch zwei Punkte","Falte zwei Punkte aufeinander","Falte zwei Linien aufeinander","Falte eine Linie auf sich selbst, falte dabei durch einen Punkt","Falte einen Punkt auf eine Linie, falte dabei durch einen anderen Punkt","Falte einen Punkt auf eine Linie und einen weiteren Punkt auf eine weitere Linie","Falte einen Punkt auf eine Linie und eine weitere Linie in sich selbst zusammen"],en:[null,"fold a line through two points","fold two points together","fold two lines together","fold a line on top of itself, creasing through a point","fold a point to a line, creasing through another point","fold a point to a line and another point to another line","fold a point to a line and another line onto itself"],es:[null,"dobla una línea entre dos puntos","dobla dos puntos juntos","dobla y une dos líneas","dobla una línea sobre sí misma, doblándola hacia un punto","dobla un punto hasta una línea, doblándola a través de otro punto","dobla un punto hacia una línea y otro punto hacia otra línea","dobla un punto hacia una línea y otra línea sobre sí misma"],fr:[null,"créez un pli passant par deux points","pliez pour superposer deux points","pliez pour superposer deux lignes","rabattez une ligne sur elle-même à l'aide d'un pli qui passe par un point","rabattez un point sur une ligne à l'aide d'un pli qui passe par un autre point","rabattez un point sur une ligne et un autre point sur une autre ligne","rabattez un point sur une ligne et une autre ligne sur elle-même"],hi:[null,"एक क्रीज़ बनाएँ जो दो स्थानों से गुजरता है","एक स्थान को दूसरे स्थान पर मोड़कर एक क्रीज़ बनाएँ","एक रेखा पर दूसरी रेखा को मोड़कर क्रीज़ बनाएँ","एक क्रीज़ बनाएँ जो एक स्थान से गुजरता है और एक रेखा को स्वयं के ऊपर ले आता है","एक क्रीज़ बनाएँ जो पहले स्थान से गुजरता है और दूसरे स्थान को रेखा पर ले आता है","एक क्रीज़ बनाएँ जो पहले स्थान को पहली रेखा पर और दूसरे स्थान को दूसरी रेखा पर ले आता है","एक क्रीज़ बनाएँ जो एक स्थान को एक रेखा पर ले आता है और दूसरी रेखा को स्वयं के ऊपर ले आता है"],jp:[null,"2点に沿って折り目を付けます","2点を合わせて折ります","2つの線を合わせて折ります","点を通過させ、既にある線に沿って折ります","点を線沿いに合わせ別の点を通過させ折ります","線に向かって点を折り、同時にもう一方の線に向かってもう一方の点を折ります","線に向かって点を折り、同時に別の線をその上に折ります"],ko:[null,"두 점을 통과하는 선으로 접으세요","두 점을 함께 접으세요","두 선을 함께 접으세요","그 위에 선을 접으면서 점을 통과하게 접으세요","점을 선으로 접으면서, 다른 점을 지나게 접으세요","점을 선으로 접고 다른 점을 다른 선으로 접으세요","점을 선으로 접고 다른 선을 그 위에 접으세요"],ms:[null,"lipat garisan melalui dua titik","lipat dua titik bersama","lipat dua garisan bersama","lipat satu garisan di atasnya sendiri, melipat melalui satu titik","lipat satu titik ke garisan, melipat melalui titik lain","lipat satu titik ke garisan dan satu lagi titik ke garisan lain","lipat satu titik ke garisan dan satu lagi garisan di atasnya sendiri"],pt:[null,"dobre uma linha entre dois pontos","dobre os dois pontos para uni-los","dobre as duas linhas para uni-las","dobre uma linha sobre si mesma, criando uma dobra ao longo de um ponto","dobre um ponto até uma linha, criando uma dobra ao longo de outro ponto","dobre um ponto até uma linha e outro ponto até outra linha","dobre um ponto até uma linha e outra linha sobre si mesma"],ru:[null,"сложите линию через две точки","сложите две точки вместе","сложите две линии вместе","сверните линию сверху себя, сгибая через точку","сложите точку в линию, сгибая через другую точку","сложите точку в линию и другую точку в другую линию","сложите точку в линию и другую линию на себя"],tr:[null,"iki noktadan geçen bir çizgi boyunca katla","iki noktayı birbirine katla","iki çizgiyi birbirine katla","bir noktadan kıvırarak kendi üzerindeki bir çizgi boyunca katla","başka bir noktadan kıvırarak bir noktayı bir çizgiye katla","bir noktayı bir çizgiye ve başka bir noktayı başka bir çizgiye katla","bir noktayı bir çizgiye ve başka bir çizgiyi kendi üzerine katla"],vi:[null,"tạo một nếp gấp đi qua hai điểm","tạo nếp gấp bằng cách gấp một điểm này sang điểm khác","tạo nếp gấp bằng cách gấp một đường lên một đường khác","tạo một nếp gấp đi qua một điểm và đưa một đường lên trên chính nó","tạo một nếp gấp đi qua điểm đầu tiên và đưa điểm thứ hai lên đường thẳng","tạo một nếp gấp mang điểm đầu tiên đến đường đầu tiên và điểm thứ hai cho đường thứ hai","tạo một nếp gấp mang lại một điểm cho một đường và đưa một đường thứ hai lên trên chính nó"],zh:[null,"通過兩點折一條線","將兩點折疊起來","將兩條線折疊在一起","通過一個點折疊一條線在自身上面","將一個點，通過另一個點折疊成一條線，","將一個點折疊為一條線，再將另一個點折疊到另一條線","將一個點折疊成一條線，另一條線折疊到它自身上"]},folds:{es:{fold:{verb:"",noun:"doblez"},valley:"doblez de valle",mountain:"doblez de montaña",inside:"",outside:"",open:"",closed:"",rabbit:"",rabbit2:"",petal:"",squash:"",flip:"dale la vuelta a tu papel"},en:{fold:{verb:"fold",noun:"crease"},valley:"valley fold",mountain:"mountain fold",inside:"inside reverse fold",outside:"outside reverse fold",open:"open sink",closed:"closed sink",rabbit:"rabbit ear fold",rabbit2:"double rabbit ear fold",petal:"petal fold",squash:"squash fold",flip:"flip over"},zh:{fold:{verb:"",noun:""},valley:"谷摺",mountain:"山摺",inside:"內中割摺",outside:"外中割摺",open:"開放式沉壓摺",closed:"封閉式沉壓摺",rabbit:"兔耳摺",rabbit2:"雙兔耳摺",petal:"花瓣摺",blintz:"坐墊基",squash:"壓摺",flip:""}}},Zi=function(){var n={};<span class="missing-if-branch" title="else path not taken" >E</span>if(t){var r=require("xmldom"),o=r.DOMParser,i=r.XMLSerializer;n.DOMParser=o,n.XMLSerializer=i,n.document=(new o).parseFromString("&lt;!DOCTYPE html&gt;&lt;title&gt;.&lt;/title&gt;","text/html")}else <span class="cstat-no" title="statement not covered" >e&amp;&amp;(n=window);r</span>eturn n}(),Xi=function <span class="fstat-no" title="function not covered" >make_edge_cylinder(</span>e,t,n){var r=<span class="cstat-no" title="statement not covered" >arguments.length&gt;3&amp;&amp;void 0!==arguments[3]?arguments[3]:0;<span class="cstat-no" title="statement not covered" ></span>if(Jn.core.mag_squared(t)&lt;Jn.core.EPSILON)<span class="cstat-no" title="statement not covered" >throw"degenerate edge";<span class="cstat-no" title="statement not covered" >f</span></span>or(var o=<span class="cstat-no" title="statement not covered" >Jn.core.normalize(t),</span>i=<span class="cstat-no" title="statement not covered" >[[1,0,0],[0,1,0],[0,0,1]].map((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return Jn.core.cross3(e,o)}</span>)).sort((<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){<span class="cstat-no" title="statement not covered" >return Jn.core.magnitude(t)-Jn.core.magnitude(e)}</span>)).shift(),</span>c=<span class="cstat-no" title="statement not covered" >[Jn.core.normalize(i)],</span>a=<span class="cstat-no" title="statement not covered" >1;</span>a&lt;4;a+=1)<span class="cstat-no" title="statement not covered" >c.push(Jn.core.cross3(c[a-1],o));v</span></span>ar u=<span class="cstat-no" title="statement not covered" >c.map((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return Jn.core.scale(e,n)}</span>)),</span>s=<span class="cstat-no" title="statement not covered" >[-r,r].map((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return Jn.core.scale(o,e)}</span>)),</span>l=<span class="cstat-no" title="statement not covered" >0===r?e:e.map((<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){<span class="cstat-no" title="statement not covered" >return Jn.core.add(e,s[t])}</span>));<span class="cstat-no" title="statement not covered" ></span>return l.map((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return u.map((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return Jn.core.add(e,t)}</span>))}</span>)).reduce(jo,[])}</span>,$i=Object.freeze({__proto__:null,make_faces_geometry:function <span class="fstat-no" title="function not covered" >make_faces_geometry(</span>e){var t=<span class="cstat-no" title="statement not covered" >Zi.THREE,</span>n=<span class="cstat-no" title="statement not covered" >e.vertices_coords.map((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return[e[0],e[1],e[2]||0]}</span>)).reduce(jo,[]),</span>r=<span class="cstat-no" title="statement not covered" >e.vertices_coords.map((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return[0,0,1]}</span>)).reduce(jo,[]),</span>o=<span class="cstat-no" title="statement not covered" >e.vertices_coords.map((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return[1,1,1]}</span>)).reduce(jo,[]),</span>i=<span class="cstat-no" title="statement not covered" >e.faces_vertices.map((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return e.map((<span class="fstat-no" title="function not covered" >fu</span>nction(e,t,n){<span class="cstat-no" title="statement not covered" >return[n[0],n[t+1],n[t+2]]}</span>)).slice(0,e.length-2)}</span>)).reduce(jo,[]).reduce(jo,[]),</span>c=<span class="cstat-no" title="statement not covered" >new t.BufferGeometry;<span class="cstat-no" title="statement not covered" ></span>return c.setAttribute("position",new t.Float32BufferAttribute(n,3)),c.setAttribute("normal",new t.Float32BufferAttribute(r,3)),c.setAttribute("color",new t.Float32BufferAttribute(o,3)),c.setIndex(i),c}</span>,make_edges_geometry:function <span class="fstat-no" title="function not covered" >make_edges_geometry(</span>e){var t=<span class="cstat-no" title="statement not covered" >e.vertices_coords,</span>n=<span class="cstat-no" title="statement not covered" >e.edges_vertices,</span>r=<span class="cstat-no" title="statement not covered" >e.edges_assignment,</span>o=<span class="cstat-no" title="statement not covered" >e.edges_coords,</span>i=<span class="cstat-no" title="statement not covered" >e.edges_vector,</span>c=<span class="cstat-no" title="statement not covered" >arguments.length&gt;1&amp;&amp;void 0!==arguments[1]?arguments[1]:.002,</span>a=<span class="cstat-no" title="statement not covered" >arguments.length&gt;2&amp;&amp;void 0!==arguments[2]?arguments[2]:0,</span>u=<span class="cstat-no" title="statement not covered" >Zi.THREE;<span class="cstat-no" title="statement not covered" ></span>o||(o=n.map((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return e.map((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return t[e]}</span>))}</span>))),i||(i=o.map((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return Jn.core.subtract(e[1],e[0])}</span>))),o=o.map((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return e.map((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return Jn.core.resize(3,e)}</span>))}</span>)),i=i.map((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return Jn.core.resize(3,e)}</span>));v</span>ar s=<span class="cstat-no" title="statement not covered" >{B:[0,0,0],M:[0,0,0],F:[0,0,0],V:[0,0,0]},</span>l=<span class="cstat-no" title="statement not covered" >r.map((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return[s[e],s[e],s[e],s[e],s[e],s[e],s[e],s[e]]}</span>)).reduce(jo,[]).reduce(jo,[]).reduce(jo,[]),</span>v=<span class="cstat-no" title="statement not covered" >o.map((<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){<span class="cstat-no" title="statement not covered" >return Xi(e,i[t],c,a)}</span>)).reduce(jo,[]).reduce(jo,[]),</span>d=<span class="cstat-no" title="statement not covered" >i.map((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >if(Jn.core.mag_squared(e)&lt;Jn.core.EPSILON)<span class="cstat-no" title="statement not covered" >throw"degenerate edge";v</span></span>ar t=<span class="cstat-no" title="statement not covered" >Jn.core.normalize(e),</span>n=(<span class="cstat-no" title="statement not covered" >Jn.core.scale(t,c),Jn.core.scale(Jn.core.normalize(Jn.core.cross3(e,[0,0,-1])),c))</span>,r=<span class="cstat-no" title="statement not covered" >Jn.core.scale(Jn.core.normalize(Jn.core.cross3(e,[0,0,1])),c);<span class="cstat-no" title="statement not covered" ></span>return[n,[-n[2],n[1],n[0]],r,[-r[2],r[1],r[0]],n,[-n[2],n[1],n[0]],r,[-r[2],r[1],r[0]]]}</span>)).reduce(jo,[]).reduce(jo,[]),</span>p=<span class="cstat-no" title="statement not covered" >o.map((<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){<span class="cstat-no" title="statement not covered" >return[8*t+0,8*t+4,8*t+1,8*t+1,8*t+4,8*t+5,8*t+1,8*t+5,8*t+2,8*t+2,8*t+5,8*t+6,8*t+2,8*t+6,8*t+3,8*t+3,8*t+6,8*t+7,8*t+3,8*t+7,8*t+0,8*t+0,8*t+7,8*t+4,8*t+0,8*t+1,8*t+3,8*t+1,8*t+2,8*t+3,8*t+5,8*t+4,8*t+7,8*t+7,8*t+6,8*t+5]}</span>)).reduce(jo,[]),</span>h=<span class="cstat-no" title="statement not covered" >new u.BufferGeometry;<span class="cstat-no" title="statement not covered" ></span>return h.setAttribute("position",new u.Float32BufferAttribute(v,3)),h.setAttribute("normal",new u.Float32BufferAttribute(d,3)),h.setAttribute("color",new u.Float32BufferAttribute(l,3)),h.setIndex(p),h.computeVertexNormals(),h}</span>}),Hi={};["number","object","transform","class","style","function","string","undefined","boolean","path","svg","id","viewBox"].forEach((function(e){return Hi[e]=e}));var Yi=("undefined"==typeof window?"undefined":<span class="branch-1 cbranch-no" title="branch not covered" >_typeof(window))</span>!==Hi.undefined&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >_typeof(window.document)!==Hi.undefined,</span>Wi=("undefined"==typeof process?<span class="branch-0 cbranch-no" title="branch not covered" >"undefined":</span>_typeof(process))!==Hi.undefined&amp;&amp;null!=process.versions&amp;&amp;null!=process.versions.node,Ji=("undefined"==typeof self?"undefined":<span class="branch-1 cbranch-no" title="branch not covered" >_typeof(self))</span>===Hi.object&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >self.constructor&amp;</span>&amp;<span class="branch-2 cbranch-no" title="branch not covered" >"DedicatedWorkerGlobalScope"===self.constructor.name,</span>Ki=Object.freeze({__proto__:null,isBrowser:Yi,isNode:Wi,isWebWorker:Ji}),Qi=function(){var e={};<span class="missing-if-branch" title="else path not taken" >E</span>if(Wi){var t=require("xmldom"),n=t.DOMParser,r=t.XMLSerializer;e.DOMParser=n,e.XMLSerializer=r,e.document=(new n).parseFromString("&lt;!DOCTYPE html&gt;&lt;title&gt;.&lt;/title&gt;","text/html")}else <span class="cstat-no" title="statement not covered" >Yi&amp;&amp;(e=window);r</span>eturn e}(),ec="http://www.w3.org/2000/svg",tc={s:["svg"],d:["defs"],h:["desc","filter","metadata","style","script","title","view"],c:["cdata"],g:["g"],v:["circle","ellipse","line","path","polygon","polyline","rect"],t:["text"],i:["marker","symbol","clipPath","mask"],p:["linearGradient","radialGradient","pattern"],cT:["textPath","tspan"],cG:["stop"],cF:["feBlend","feColorMatrix","feComponentTransfer","feComposite","feConvolveMatrix","feDiffuseLighting","feDisplacementMap","feDistantLight","feDropShadow","feFlood","feFuncA","feFuncB","feFuncG","feFuncR","feGaussianBlur","feImage","feMerge","feMergeNode","feMorphology","feOffset","fePointLight","feSpecularLighting","feSpotLight","feTile","feTurbulence"]},nc=function <span class="fstat-no" title="function not covered" >vec(</span>e,t){<span class="cstat-no" title="statement not covered" >return[Math.cos(e)*t,Math.sin(e)*t]}</span>,rc=function <span class="fstat-no" title="function not covered" >arcPath(</span>e,t,n,r,o){var i=<span class="cstat-no" title="statement not covered" >arguments.length&gt;5&amp;&amp;void 0!==arguments[5]&amp;&amp;arguments[5];<span class="cstat-no" title="statement not covered" ></span>if(null==o)<span class="cstat-no" title="statement not covered" >return"";v</span></span>ar c=<span class="cstat-no" title="statement not covered" >nc(r,n),</span>a=<span class="cstat-no" title="statement not covered" >nc(o,n),</span>u=<span class="cstat-no" title="statement not covered" >[a[0]-c[0],a[1]-c[1]],</span>s=<span class="cstat-no" title="statement not covered" >c[0]*a[1]-c[1]*a[0],</span>l=<span class="cstat-no" title="statement not covered" >c[0]*a[0]+c[1]*a[1],</span>v=<span class="cstat-no" title="statement not covered" >Math.atan2(s,l)&gt;0?0:1,</span>d=<span class="cstat-no" title="statement not covered" >i?"M ".concat(e,",").concat(t," l ").concat(c[0],",").concat(c[1]," "):"M ".concat(e+c[0],",").concat(t+c[1]," ");<span class="cstat-no" title="statement not covered" ></span>return d+=["a ",n,n,0,v,1,u[0],u[1]].join(" "),i&amp;&amp;(d+=" Z"),d}</span>,oc=function <span class="fstat-no" title="function not covered" >arcArguments(</span>e,t,n,r,o){<span class="cstat-no" title="statement not covered" >return[rc(e,t,n,r,o,!1)]}</span>,ic={arc:{nodeName:"path",attributes:["d"],args:oc,methods:{setArc:function <span class="fstat-no" title="function not covered" >setArc(</span>e){<span class="cstat-no" title="statement not covered" >for(var t=<span class="cstat-no" title="statement not covered" >arguments.length,</span>n=<span class="cstat-no" title="statement not covered" >new Array(t&gt;1?t-1:0),</span>r=<span class="cstat-no" title="statement not covered" >1;</span>r&lt;t;r++)<span class="cstat-no" title="statement not covered" >n[r-1]=arguments[r];<span class="cstat-no" title="statement not covered" >r</span></span>eturn e.setAttribute("d",oc.apply(void 0,n))}</span>}}},cc=function <span class="fstat-no" title="function not covered" >wedgeArguments(</span>e,t,n,r,o){<span class="cstat-no" title="statement not covered" >return[rc(e,t,n,r,o,!0)]}</span>,ac={wedge:{nodeName:"path",args:cc,attributes:["d"],methods:{setArc:function <span class="fstat-no" title="function not covered" >setArc(</span>e){<span class="cstat-no" title="statement not covered" >for(var t=<span class="cstat-no" title="statement not covered" >arguments.length,</span>n=<span class="cstat-no" title="statement not covered" >new Array(t&gt;1?t-1:0),</span>r=<span class="cstat-no" title="statement not covered" >1;</span>r&lt;t;r++)<span class="cstat-no" title="statement not covered" >n[r-1]=arguments[r];<span class="cstat-no" title="statement not covered" >r</span></span>eturn e.setAttribute("d",cc.apply(void 0,n))}</span>}}},uc=128,sc=function <span class="fstat-no" title="function not covered" >parabolaArguments(</span>){var e=<span class="cstat-no" title="statement not covered" >arguments.length&gt;0&amp;&amp;void 0!==arguments[0]?arguments[0]:-1,</span>t=<span class="cstat-no" title="statement not covered" >arguments.length&gt;1&amp;&amp;void 0!==arguments[1]?arguments[1]:0,</span>n=<span class="cstat-no" title="statement not covered" >arguments.length&gt;2&amp;&amp;void 0!==arguments[2]?arguments[2]:2,</span>r=<span class="cstat-no" title="statement not covered" >arguments.length&gt;3&amp;&amp;void 0!==arguments[3]?arguments[3]:1;<span class="cstat-no" title="statement not covered" ></span>return Array.from(Array(129)).map((<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){<span class="cstat-no" title="statement not covered" >return(t-uc)/uc*2+1}</span>)).map((<span class="fstat-no" title="function not covered" >fu</span>nction(o){<span class="cstat-no" title="statement not covered" >return[e+(o+1)*n*.5,t+Math.pow(o,2)*r]}</span>))}</span>,fc={parabola:{nodeName:"polyline",attributes:["points"],args:function <span class="fstat-no" title="function not covered" >parabolaPathString(</span>e,t,n,r){<span class="cstat-no" title="statement not covered" >return[sc(e,t,n,r).map((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return"".concat(e[0],",").concat(e[1])}</span>)).join(" ")]}</span>}},lc=function <span class="fstat-no" title="function not covered" >regularPolygonArguments(</span>e,t,n,r){var o=<span class="cstat-no" title="statement not covered" >[t,n];<span class="cstat-no" title="statement not covered" ></span>return Array.from(Array(e)).map((<span class="fstat-no" title="function not covered" >fu</span>nction(t,n){<span class="cstat-no" title="statement not covered" >return 2*Math.PI*n/e}</span>)).map((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return[Math.cos(e),Math.sin(e)]}</span>)).map((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return o.map((<span class="fstat-no" title="function not covered" >fu</span>nction(t,n){<span class="cstat-no" title="statement not covered" >return t+r*e[n]}</span>))}</span>))}</span>,vc={regularPolygon:{nodeName:"polygon",attributes:["points"],args:function <span class="fstat-no" title="function not covered" >polygonPathString(</span>e){var t=<span class="cstat-no" title="statement not covered" >arguments.length&gt;1&amp;&amp;void 0!==arguments[1]?arguments[1]:0,</span>n=<span class="cstat-no" title="statement not covered" >arguments.length&gt;2&amp;&amp;void 0!==arguments[2]?arguments[2]:0,</span>r=<span class="cstat-no" title="statement not covered" >arguments.length&gt;3&amp;&amp;void 0!==arguments[3]?arguments[3]:1;<span class="cstat-no" title="statement not covered" ></span>return[lc(e,t,n,r).map((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return"".concat(e[0],",").concat(e[1])}</span>)).join(" ")]}</span>}},dc={roundRect:{nodeName:"path",attributes:["d"],args:function <span class="fstat-no" title="function not covered" >roundRectArguments(</span>e,t,n,r){var o=<span class="cstat-no" title="statement not covered" >arguments.length&gt;4&amp;&amp;void 0!==arguments[4]?arguments[4]:0;<span class="cstat-no" title="statement not covered" ></span>o&gt;n/2&amp;&amp;(o=n/2),o&gt;r/2&amp;&amp;(o=r/2);v</span>ar i=<span class="cstat-no" title="statement not covered" >n-2*o,</span>c=<span class="cstat-no" title="statement not covered" >r-2*o,</span>a=<span class="cstat-no" title="statement not covered" >"A".concat(o," ").concat(o," 0 0 1");<span class="cstat-no" title="statement not covered" ></span>return["M".concat(e+(n-i)/2,",").concat(t),"h".concat(i),a,"".concat(e+n,",").concat(t+(r-c)/2),"v".concat(c),a,"".concat(e+n-o,",").concat(t+r),"h".concat(-i),a,"".concat(e,",").concat(t+r-o),"v".concat(-c),a,"".concat(e+o,",").concat(t)].join(" ")}</span>}},pc=function is_iterable(e){return null!=e&amp;&amp;_typeof(e[Symbol.iterator])===Hi.function},_c=function flatten_arrays(){switch(arguments.length){<span class="branch-0 cbranch-no" title="branch not covered" >case void 0:<span class="branch-1 cbranch-no" title="branch not covered" >c</span>ase 0:<span class="cstat-no" title="statement not covered" >return Array.from(arguments);c</span></span>ase 1:return pc(arguments[0])&amp;&amp;"string"!=typeof arguments[0]?flatten_arrays.apply(void 0,_toConsumableArray(arguments[0])):[arguments[0]];default:return Array.from(arguments).map((function(e){return pc(e)?_toConsumableArray(flatten_arrays(e)):<span class="branch-1 cbranch-no" title="branch not covered" >e}</span>)).reduce((function(e,t){return e.concat(t)}),[])}},gc=function <span class="fstat-no" title="function not covered" >coordinates(</span>){<span class="cstat-no" title="statement not covered" >for(var e=<span class="cstat-no" title="statement not covered" >arguments.length,</span>t=<span class="cstat-no" title="statement not covered" >new Array(e),</span>n=<span class="cstat-no" title="statement not covered" >0;</span>n&lt;e;n++)<span class="cstat-no" title="statement not covered" >t[n]=arguments[n];<span class="cstat-no" title="statement not covered" >r</span></span>eturn t.filter((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return _typeof(e)===Hi.number}</span>)).concat(t.filter((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return _typeof(e)===Hi.object&amp;&amp;null!==e}</span>)).map((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return _typeof(e.x)===Hi.number?[e.x,e.y]:_typeof(e[0])===Hi.number?[e[0],e[1]]:void 0}</span>)).filter((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return void 0!==e}</span>)).reduce((<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){<span class="cstat-no" title="statement not covered" >return e.concat(t)}</span>),[]))}</span>,hc=function <span class="fstat-no" title="function not covered" >add(</span>e,t){<span class="cstat-no" title="statement not covered" >return[e[0]+t[0],e[1]+t[1]]}</span>,mc=function <span class="fstat-no" title="function not covered" >sub(</span>e,t){<span class="cstat-no" title="statement not covered" >return[e[0]-t[0],e[1]-t[1]]}</span>,yc=function <span class="fstat-no" title="function not covered" >scale(</span>e,t){<span class="cstat-no" title="statement not covered" >return[e[0]*t,e[1]*t]}</span>,bc=function <span class="fstat-no" title="function not covered" >curveArguments(</span>){var e=<span class="cstat-no" title="statement not covered" >gc.apply(void 0,_toConsumableArray(_c.apply(void 0,arguments))),</span>t=<span class="cstat-no" title="statement not covered" >e.slice(0,4);<span class="cstat-no" title="statement not covered" ></span>if(!t.length)<span class="cstat-no" title="statement not covered" >return[""];v</span></span>ar n=<span class="cstat-no" title="statement not covered" >e[4]||0,</span>r=<span class="cstat-no" title="statement not covered" >e[5]||.5,</span>o=<span class="cstat-no" title="statement not covered" >[t[0],t[1]],</span>i=<span class="cstat-no" title="statement not covered" >[t[2],t[3]],</span>c=<span class="cstat-no" title="statement not covered" >mc(i,o),</span>a=<span class="cstat-no" title="statement not covered" >hc(o,yc(c,.5)),</span>u=<span class="cstat-no" title="statement not covered" >[c[1],-c[0]],</span>s=<span class="cstat-no" title="statement not covered" >hc(a,yc(u,n)),</span>l=<span class="cstat-no" title="statement not covered" >hc(o,yc(mc(s,o),r)),</span>v=<span class="cstat-no" title="statement not covered" >hc(i,yc(mc(s,i),r));<span class="cstat-no" title="statement not covered" ></span>return["M".concat(o[0],",").concat(o[1],"C").concat(l[0],",").concat(l[1]," ").concat(v[0],",").concat(v[1]," ").concat(i[0],",").concat(i[1])]}</span>,xc={bend:function <span class="fstat-no" title="function not covered" >bend(</span>e,t){<span class="cstat-no" title="statement not covered" >return e.setAttribute("d",bc.apply(void 0,_toConsumableArray(function <span class="fstat-no" title="function not covered" >getEndpoints(</span>e){var t=<span class="cstat-no" title="statement not covered" >e.getAttribute("d");<span class="cstat-no" title="statement not covered" ></span>return null==t||""===t?[]:[t.slice(t.indexOf("M")+1,t.indexOf("C")).split(","),t.split(" ").pop().split(",")].map((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return e.map((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return parseFloat(e)}</span>))}</span>))}</span>(e)).concat([t]))),e}</span>},Ac={curve:{nodeName:"path",attributes:["d"],args:bc,methods:xc}},kc={};Object.assign(kc,ic,ac,fc,vc,dc,Ac);var wc=Object.keys(kc),Ec=[tc.h,tc.p,tc.i],Mc=[tc.g,tc.v,tc.t,wc],Oc={svg:[tc.s,tc.d].concat(Ec).concat(Mc),g:Mc,text:[tc.cT],linearGradient:[tc.cG],radialGradient:[tc.cG],defs:Ec,filter:[tc.cF],marker:Mc,symbol:Mc,clipPath:Mc,mask:Mc},jc=Object.create(null);Object.keys(Oc).forEach((function(e){jc[e]=Oc[e].reduce((function(e,t){return e.concat(t)}),[])}));var Cc=Object.freeze(jc),Sc={toCamel:function toCamel(e){return e.replace(/([-_][a-z])/gi,(function(e){return e.toUpperCase().replace("-","").replace("_","")}))},toKebab:function <span class="fstat-no" title="function not covered" >toKebab(</span>e){<span class="cstat-no" title="statement not covered" >return e.replace(/([a-z0-9])([A-Z])/g,"$1-$2").replace(/([A-Z])([A-Z])(?=[a-z])/g,"$1-$2").toLowerCase()}</span>,capitalized:function <span class="fstat-no" title="function not covered" >capitalized(</span>e){<span class="cstat-no" title="statement not covered" >return e.charAt(0).toUpperCase()+e.slice(1)}</span>},Pc=function <span class="fstat-no" title="function not covered" >viewBoxValue(</span>e,t,n,r){var o=<span class="cstat-no" title="statement not covered" >arguments.length&gt;4&amp;&amp;void 0!==arguments[4]?arguments[4]:0,</span>i=<span class="cstat-no" title="statement not covered" >1,</span>c=<span class="cstat-no" title="statement not covered" >n/i-n,</span>a=<span class="cstat-no" title="statement not covered" >e-c-o,</span>u=<span class="cstat-no" title="statement not covered" >t-c-o,</span>s=<span class="cstat-no" title="statement not covered" >n+2*c+2*o,</span>l=<span class="cstat-no" title="statement not covered" >r+2*c+2*o;<span class="cstat-no" title="statement not covered" ></span>return[a,u,s,l].join(" ")}</span>;function <span class="fstat-no" title="function not covered" >viewBox(</span>){var e=<span class="cstat-no" title="statement not covered" >gc.apply(void 0,_toConsumableArray(_c(arguments)));<span class="cstat-no" title="statement not covered" ></span>return 2===e.length&amp;&amp;e.unshift(0,0),4===e.length?Pc.apply(void 0,_toConsumableArray(e)):void 0}</span>var Nc=function <span class="fstat-no" title="function not covered" >cdata(</span>e){<span class="cstat-no" title="statement not covered" >return(new Qi.DOMParser).parseFromString("&lt;root&gt;&lt;/root&gt;","text/xml").createCDATASection("".concat(e))}</span>,zc=function <span class="fstat-no" title="function not covered" >removeChildren(</span>e){<span class="cstat-no" title="statement not covered" >for(;e.lastChild;)<span class="cstat-no" title="statement not covered" >e.removeChild(e.lastChild);<span class="cstat-no" title="statement not covered" >r</span></span>eturn e}</span>,Ic=function <span class="fstat-no" title="function not covered" >moveChildren(</span>e,t){<span class="cstat-no" title="statement not covered" >for(;t.childNodes.length&gt;0;){var n=<span class="cstat-no" title="statement not covered" >t.childNodes[0];<span class="cstat-no" title="statement not covered" ></span>t.removeChild(n),e.appendChild(n)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn e}</span>,Lc=function <span class="fstat-no" title="function not covered" >assignSVG(</span>e,t){<span class="cstat-no" title="statement not covered" >return Array.from(t.attributes).forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return e.setAttribute(t.name,t.value)}</span>)),Ic(e,t)}</span>,qc={removeChildren:zc,appendTo:function <span class="fstat-no" title="function not covered" >appendTo(</span>e,t){<span class="cstat-no" title="statement not covered" >return null!=t&amp;&amp;t.appendChild(e),e}</span>,setAttributes:function <span class="fstat-no" title="function not covered" >setAttributes(</span>e,t){<span class="cstat-no" title="statement not covered" >return Object.keys(t).forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(n){<span class="cstat-no" title="statement not covered" >return e.setAttribute(Sc.toKebab(n),t[n])}</span>))}</span>},Tc=function <span class="fstat-no" title="function not covered" >filterWhitespaceNodes(</span>e){<span class="cstat-no" title="statement not covered" >if(null===e)<span class="cstat-no" title="statement not covered" >return e;<span class="cstat-no" title="statement not covered" >f</span></span>or(var t=<span class="cstat-no" title="statement not covered" >e.childNodes.length-1;</span>t&gt;=0;t-=1){var n=<span class="cstat-no" title="statement not covered" >e.childNodes[t];<span class="cstat-no" title="statement not covered" ></span>3===n.nodeType&amp;&amp;n.data.match(/^\s*$/)&amp;&amp;e.removeChild(n),1===n.nodeType&amp;&amp;filterWhitespaceNodes(n)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn e}</span>,Fc=function <span class="fstat-no" title="function not covered" >parse(</span>e){<span class="cstat-no" title="statement not covered" >return(new Qi.DOMParser).parseFromString(e,"text/xml")}</span>,Vc=function <span class="fstat-no" title="function not covered" >checkParseError(</span>e){var t=<span class="cstat-no" title="statement not covered" >e.getElementsByTagName("parsererror");<span class="cstat-no" title="statement not covered" ></span>if(t.length&gt;0)<span class="cstat-no" title="statement not covered" >throw new Error(t[0]);<span class="cstat-no" title="statement not covered" >r</span></span>eturn Tc(e.documentElement)}</span>,Gc=function <span class="fstat-no" title="function not covered" >sync(</span>e){<span class="cstat-no" title="statement not covered" >if(_typeof(e)===Hi.string||e instanceof String)<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >return Vc(Fc(e))}</span>catch(e){<span class="cstat-no" title="statement not covered" >return e}<span class="cstat-no" title="statement not covered" ></span>i</span></span>f(null!=e.childNodes)<span class="cstat-no" title="statement not covered" >return e}</span></span>,Bc=function <span class="fstat-no" title="function not covered" >Load(</span>e){<span class="cstat-no" title="statement not covered" >return function <span class="fstat-no" title="function not covered" >isFilename(</span>e){<span class="cstat-no" title="statement not covered" >return _typeof(e)===Hi.string&amp;&amp;/^[\w,\s-]+\.[A-Za-z]{3}$/.test(e)&amp;&amp;e.length&lt;1e4}</span>(e)&amp;&amp;Yi&amp;&amp;_typeof(Qi.fetch)===Hi.function?function <span class="fstat-no" title="function not covered" >async(</span>e){<span class="cstat-no" title="statement not covered" >return new Promise((<span class="fstat-no" title="function not covered" >fu</span>nction(t,n){<span class="cstat-no" title="statement not covered" >if(_typeof(e)===Hi.string||e instanceof String)<span class="cstat-no" title="statement not covered" >fetch(e).then((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return e.text()}</span>)).then((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return Vc(Fc(e))}</span>)).then((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return"svg"===e.nodeName?e:e.getElementsByTagName("svg")[0]}</span>)).then((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return null==e?n("valid XML found, but no SVG element"):t(e)}</span>)).catch((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return n(e)}</span>));e</span>lse <span class="cstat-no" title="statement not covered" >if(e instanceof Qi.Document)<span class="cstat-no" title="statement not covered" >return asyncDone(e)}</span></span></span>))}</span>(e):Gc(e)}</span>;var Dc=function <span class="fstat-no" title="function not covered" >save(</span>e,t){<span class="cstat-no" title="statement not covered" >if((t=Object.assign(function <span class="fstat-no" title="function not covered" >SAVE_OPTIONS(</span>){<span class="cstat-no" title="statement not covered" >return{download:!1,output:Hi.string,windowStyle:!1,filename:"image.svg"}}</span>(),t)).windowStyle){var n=<span class="cstat-no" title="statement not covered" >Qi.document.createElementNS(ec,Hi.style);<span class="cstat-no" title="statement not covered" ></span>n.setAttribute("type","text/css"),n.innerHTML=function <span class="fstat-no" title="function not covered" >getWindowStylesheets(</span>){var e=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>if(Qi.document.styleSheets)<span class="cstat-no" title="statement not covered" >for(var t=<span class="cstat-no" title="statement not covered" >0;</span>t&lt;Qi.document.styleSheets.length;t+=1){var n=<span class="cstat-no" title="statement not covered" >Qi.document.styleSheets[t];<span class="cstat-no" title="statement not covered" ></span>try{<span class="cstat-no" title="statement not covered" >for(var r=(<span class="cstat-no" title="statement not covered" >"cssRules"in n?n.cssRules:n.rules)</span>,o=<span class="cstat-no" title="statement not covered" >0;</span>o&lt;r.length;o+=1){var i=<span class="cstat-no" title="statement not covered" >r[o];<span class="cstat-no" title="statement not covered" ></span>"cssText"in i?e.push(i.cssText):e.push("".concat(i.selectorText," {\n").concat(i.style.cssText,"\n}\n"))}</span>}</span>catch(e){<span class="cstat-no" title="statement not covered" >console.warn(e)}</span>}<span class="cstat-no" title="statement not covered" ></span>r</span></span>eturn e.join("\n")}</span>(),e.appendChild(n)}</span>v</span>ar r=<span class="cstat-no" title="statement not covered" >function <span class="fstat-no" title="function not covered" >vkXML(</span>e,t){<span class="cstat-no" title="statement not covered" >for(var n=<span class="cstat-no" title="statement not covered" >e.replace(/&gt;\s{0,}&lt;/g,"&gt;&lt;").replace(/&lt;/g,"~::~&lt;").replace(/\s*xmlns\:/g,"~::~xmlns:").split("~::~"),</span>r=<span class="cstat-no" title="statement not covered" >n.length,</span>o=<span class="cstat-no" title="statement not covered" >!1,</span>i=<span class="cstat-no" title="statement not covered" >0,</span>c=<span class="cstat-no" title="statement not covered" >"",</span>a=<span class="cstat-no" title="statement not covered" >null!=t&amp;&amp;"string"==typeof t?t:"\t",</span>u=<span class="cstat-no" title="statement not covered" >["\n"],</span>s=<span class="cstat-no" title="statement not covered" >0;</span>s&lt;100;s+=1)<span class="cstat-no" title="statement not covered" >u.push(u[s]+a);<span class="cstat-no" title="statement not covered" >f</span></span>or(var l=<span class="cstat-no" title="statement not covered" >0;</span>l&lt;r;l+=1)<span class="cstat-no" title="statement not covered" >n[l].search(/&lt;!/)&gt;-1?(c+=u[i]+n[l],o=!0,(n[l].search(/--&gt;/)&gt;-1||n[l].search(/\]&gt;/)&gt;-1||n[l].search(/!DOCTYPE/)&gt;-1)&amp;&amp;(o=!1)):n[l].search(/--&gt;/)&gt;-1||n[l].search(/\]&gt;/)&gt;-1?(c+=n[l],o=!1):/^&lt;\w/.exec(n[l-1])&amp;&amp;/^&lt;\/\w/.exec(n[l])&amp;&amp;/^&lt;[\w:\-\.\,]+/.exec(n[l-1])==/^&lt;\/[\w:\-\.\,]+/.exec(n[l])[0].replace("/","")?(c+=n[l],o||(i-=1)):n[l].search(/&lt;\w/)&gt;-1&amp;&amp;-1===n[l].search(/&lt;\//)&amp;&amp;-1===n[l].search(/\/&gt;/)?c=c+=o?n[l]:u[i++]+n[l]:n[l].search(/&lt;\w/)&gt;-1&amp;&amp;n[l].search(/&lt;\//)&gt;-1?c=c+=o?n[l]:u[i]+n[l]:n[l].search(/&lt;\//)&gt;-1?c=c+=o?n[l]:u[--i]+n[l]:n[l].search(/\/&gt;/)&gt;-1?c=c+=o?n[l]:u[i]+n[l]:n[l].search(/&lt;\?/)&gt;-1||n[l].search(/xmlns\:/)&gt;-1||n[l].search(/xmlns\=/)&gt;-1?c+=u[i]+n[l]:c+=n[l];<span class="cstat-no" title="statement not covered" >r</span></span>eturn"\n"===c[0]?c.slice(1):c}</span>((new Qi.XMLSerializer).serializeToString(e));<span class="cstat-no" title="statement not covered" ></span>return t.download&amp;&amp;Yi&amp;&amp;!Wi&amp;&amp;function <span class="fstat-no" title="function not covered" >downloadInBrowser(</span>e,t){var n=<span class="cstat-no" title="statement not covered" >new Qi.Blob([t],{type:"text/plain"}),</span>r=<span class="cstat-no" title="statement not covered" >Qi.document.createElement("a");<span class="cstat-no" title="statement not covered" ></span>r.setAttribute("href",Qi.URL.createObjectURL(n)),r.setAttribute("download",e),Qi.document.body.appendChild(r),r.click(),Qi.document.body.removeChild(r)}</span>(t.filename,r),"svg"===t.output?e:r}</span>,Rc=function <span class="fstat-no" title="function not covered" >setViewBox(</span>e){<span class="cstat-no" title="statement not covered" >for(var t=<span class="cstat-no" title="statement not covered" >arguments.length,</span>n=<span class="cstat-no" title="statement not covered" >new Array(t&gt;1?t-1:0),</span>r=<span class="cstat-no" title="statement not covered" >1;</span>r&lt;t;r++)<span class="cstat-no" title="statement not covered" >n[r-1]=arguments[r];v</span></span>ar o=<span class="cstat-no" title="statement not covered" >1===n.length&amp;&amp;"string"==typeof n[0]?n[0]:viewBox.apply(void 0,n);<span class="cstat-no" title="statement not covered" ></span>return o&amp;&amp;e.setAttribute(Hi.viewBox,o),e}</span>,Uc=function <span class="fstat-no" title="function not covered" >getViewBox(</span>e){var t=<span class="cstat-no" title="statement not covered" >e.getAttribute(Hi.viewBox);<span class="cstat-no" title="statement not covered" ></span>return null==t?void 0:t.split(" ").map((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return parseFloat(e)}</span>))}</span>,Zc=function <span class="fstat-no" title="function not covered" >convertToViewBox(</span>e,t,n){var r=<span class="cstat-no" title="statement not covered" >e.createSVGPoint();<span class="cstat-no" title="statement not covered" ></span>r.x=t,r.y=n;v</span>ar o=<span class="cstat-no" title="statement not covered" >r.matrixTransform(e.getScreenCTM().inverse());<span class="cstat-no" title="statement not covered" ></span>return[o.x,o.y]}</span>,Xc=Object.freeze({__proto__:null,setViewBox:Rc,getViewBox:Uc,convertToViewBox:Zc}),$c=function <span class="fstat-no" title="function not covered" >loadSVG(</span>e,t){var n=<span class="cstat-no" title="statement not covered" >Bc(t);<span class="cstat-no" title="statement not covered" ></span>if(null!=n)<span class="cstat-no" title="statement not covered" >return _typeof(n.then)===Hi.function?n.then((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return Lc(e,t)}</span>)):Lc(e,n)}</span></span>,Hc=function <span class="fstat-no" title="function not covered" >getFrame(</span>e){var t=<span class="cstat-no" title="statement not covered" >Uc(e);<span class="cstat-no" title="statement not covered" ></span>if(void 0!==t)<span class="cstat-no" title="statement not covered" >return t;<span class="cstat-no" title="statement not covered" >i</span></span>f(_typeof(e.getBoundingClientRect)===Hi.function){var n=<span class="cstat-no" title="statement not covered" >e.getBoundingClientRect();<span class="cstat-no" title="statement not covered" ></span>return[n.x,n.y,n.width,n.height]}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn[]}</span>,Yc="svg-background-rectangle",Wc=function <span class="fstat-no" title="function not covered" >stylesheet(</span>e,t){var n=<span class="cstat-no" title="statement not covered" >function <span class="fstat-no" title="function not covered" >findStyleSheet(</span>e){var t=<span class="cstat-no" title="statement not covered" >e.getElementsByTagName(Hi.style);<span class="cstat-no" title="statement not covered" ></span>return 0===t.length?void 0:t[0]}</span>(e);<span class="cstat-no" title="statement not covered" ></span>return null==n&amp;&amp;(n=this.Constructor(Hi.style),e.insertBefore(n,e.firstChild)),n.textContent="",n.appendChild(Nc(t)),n}</span>,Jc={clear:function <span class="fstat-no" title="function not covered" >clearSVG(</span>e){<span class="cstat-no" title="statement not covered" >return Array.from(e.attributes).filter((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return"xmlns"!==e}</span>)).forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return e.removeAttribute(t.name)}</span>)),zc(e)}</span>,size:Rc,setViewBox:Rc,getViewBox:Uc,padding:function <span class="fstat-no" title="function not covered" >setPadding(</span>e,t){var n=<span class="cstat-no" title="statement not covered" >Uc(e);<span class="cstat-no" title="statement not covered" ></span>return void 0!==n&amp;&amp;Rc.apply(void 0,[e].concat(_toConsumableArray([-t,-t,2*t,2*t].map((<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){<span class="cstat-no" title="statement not covered" >return n[t]+e}</span>))))),e}</span>,background:function <span class="fstat-no" title="function not covered" >background(</span>e,t){var n=<span class="cstat-no" title="statement not covered" >Array.from(e.childNodes).filter((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return e.getAttribute(Hi.class)===Yc}</span>)).shift();<span class="cstat-no" title="statement not covered" ></span>return null==n&amp;&amp;((n=this.Constructor.apply(this,["rect"].concat(_toConsumableArray(Hc(e))))).setAttribute(Hi.class,Yc),n.setAttribute("stroke","none"),e.insertBefore(n,e.firstChild)),n.setAttribute("fill",t),e}</span>,getWidth:function <span class="fstat-no" title="function not covered" >getWidth(</span>e){<span class="cstat-no" title="statement not covered" >return Hc(e)[2]}</span>,getHeight:function <span class="fstat-no" title="function not covered" >getHeight(</span>e){<span class="cstat-no" title="statement not covered" >return Hc(e)[3]}</span>,stylesheet:function <span class="fstat-no" title="function not covered" >stylesheet(</span>e,t){<span class="cstat-no" title="statement not covered" >return Wc.call(this,e,t)}</span>,load:$c,save:Dc},Kc={math:{vector:function <span class="fstat-no" title="function not covered" >vector(</span>){<span class="cstat-no" title="statement not covered" >for(var e=<span class="cstat-no" title="statement not covered" >arguments.length,</span>t=<span class="cstat-no" title="statement not covered" >new Array(e),</span>n=<span class="cstat-no" title="statement not covered" >0;</span>n&lt;e;n++)<span class="cstat-no" title="statement not covered" >t[n]=arguments[n];<span class="cstat-no" title="statement not covered" >r</span></span>eturn[].concat(t)}</span>}},Qc={move:["mousemove","touchmove"],press:["mousedown","touchstart"],release:["mouseup","touchend"]},ea=Object.values(Qc).reduce((function(e,t){return e.concat(t)}),[]),ta=function <span class="fstat-no" title="function not covered" >defineGetter(</span>e,t,n){<span class="cstat-no" title="statement not covered" >return Object.defineProperty(e,t,{get:function <span class="fstat-no" title="function not covered" >get(</span>){<span class="cstat-no" title="statement not covered" >return n}</span>,enumerable:!0,configurable:!0})}</span>,na=function <span class="fstat-no" title="function not covered" >assignPress(</span>e,t){var n;<span class="cstat-no" title="statement not covered" >(["pressX","pressY"].filter((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return!e.hasOwnProperty(t)}</span>)).forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(n,r){<span class="cstat-no" title="statement not covered" >return ta(e,n,t[r])}</span>)),e.hasOwnProperty("press"))||ta(e,"press",(n=Kc.math).vector.apply(n,_toConsumableArray(t)))}</span>,ra=function <span class="fstat-no" title="function not covered" >TouchEvents(</span>e){var t=<span class="cstat-no" title="statement not covered" >[],</span>n=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>Object.keys(Qc).forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >Qc[e].forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >n[e]=[]}</span>))}</span>));v</span>ar r=<span class="cstat-no" title="statement not covered" >{press:function <span class="fstat-no" title="function not covered" >press(</span>e,n){<span class="cstat-no" title="statement not covered" >na(e,t=n)}</span>,release:function <span class="fstat-no" title="function not covered" >release(</span>){},move:function <span class="fstat-no" title="function not covered" >move(</span>e,n){<span class="cstat-no" title="statement not covered" >e.buttons&gt;0&amp;&amp;void 0===t[0]?t=n:0===e.buttons&amp;&amp;void 0!==t[0]&amp;&amp;(t=[]),na(e,t)}</span>};<span class="cstat-no" title="statement not covered" ></span>Object.keys(Qc).forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(t){var o=<span class="cstat-no" title="statement not covered" >"on"+Sc.capitalized(t);<span class="cstat-no" title="statement not covered" ></span>Object.defineProperty(e,o,{set:function <span class="fstat-no" title="function not covered" >set(</span>o){<span class="cstat-no" title="statement not covered" >return null==o?function <span class="fstat-no" title="function not covered" >removeHandler(</span>t){<span class="cstat-no" title="statement not covered" >return Qc[t].forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return n[t].forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(n){<span class="cstat-no" title="statement not covered" >return e.removeEventListener(t,n)}</span>))}</span>))}</span>(t):Qc[t].forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(i){var c=<span class="cstat-no" title="statement not covered" >function <span class="fstat-no" title="function not covered" >handlerFunc(</span>n){var i=<span class="cstat-no" title="statement not covered" >null!=n.touches?n.touches[0]:n;<span class="cstat-no" title="statement not covered" ></span>if(void 0!==i){var c,a=<span class="cstat-no" title="statement not covered" >Zc(e,i.clientX,i.clientY).map((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return isNaN(e)?void 0:e}</span>));<span class="cstat-no" title="statement not covered" ></span>if(["x","y"].filter((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return!n.hasOwnProperty(e)}</span>)).forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){<span class="cstat-no" title="statement not covered" >return ta(n,e,a[t])}</span>)),!n.hasOwnProperty("position"))<span class="cstat-no" title="statement not covered" >ta(n,"position",(c=Kc.math).vector.apply(c,_toConsumableArray(a)));<span class="cstat-no" title="statement not covered" >r</span></span>[t](n,a)}<span class="cstat-no" title="statement not covered" ></span>o</span>(n)}</span>;<span class="cstat-no" title="statement not covered" ></span>e.addEventListener&amp;&amp;(n[i].push(c),e.addEventListener(i,c))}</span>))}</span>,enumerable:!0})}</span>)),Object.defineProperty(e,"off",{value:function <span class="fstat-no" title="function not covered" >value(</span>){<span class="cstat-no" title="statement not covered" >return function <span class="fstat-no" title="function not covered" >off(</span>e,t){<span class="cstat-no" title="statement not covered" >return ea.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(n){<span class="cstat-no" title="statement not covered" >t[n].forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return e.removeEventListener(n,t)}</span>)),t[n]=[]}</span>))}</span>(e,n)}</span>})}</span>,oa=function <span class="fstat-no" title="function not covered" >UUID(</span>){<span class="cstat-no" title="statement not covered" >return Math.random().toString(36).replace(/[^a-z]+/g,"").concat("aaaaa").substr(0,5)}</span>,ia=function <span class="fstat-no" title="function not covered" >Animation(</span>e){var t,n,r=<span class="cstat-no" title="statement not covered" >{},</span>o=<span class="cstat-no" title="statement not covered" >0,</span>i=<span class="cstat-no" title="statement not covered" >function <span class="fstat-no" title="function not covered" >removeHandlers(</span>){<span class="cstat-no" title="statement not covered" >Qi.cancelAnimationFrame&amp;&amp;Qi.cancelAnimationFrame(n),Object.keys(r).forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return delete r[e]}</span>)),t=void 0,o=0}</span>;<span class="cstat-no" title="statement not covered" ></span>Object.defineProperty(e,"play",{set:function <span class="fstat-no" title="function not covered" >set(</span>e){<span class="cstat-no" title="statement not covered" >if(i(),null!=e){var c=<span class="cstat-no" title="statement not covered" >oa();<span class="cstat-no" title="statement not covered" ></span>r[c]=function <span class="fstat-no" title="function not covered" >handlerFunc(</span>i){<span class="cstat-no" title="statement not covered" >t||(t=i,o=0),e({time:.001*(i-t),frame:o}),o+=1,r[c]&amp;&amp;(n=Qi.requestAnimationFrame(r[c]))}</span>,Qi.requestAnimationFrame&amp;&amp;(n=Qi.requestAnimationFrame(r[c]))}</span>}</span>,enumerable:!0}),Object.defineProperty(e,"stop",{value:i,enumerable:!0})}</span>,ca=function <span class="fstat-no" title="function not covered" >distanceSq2(</span>e,t){<span class="cstat-no" title="statement not covered" >return Math.pow(e[0]-t[0],2)+Math.pow(e[1]-t[1],2)}</span>,aa=function <span class="fstat-no" title="function not covered" >distance2(</span>e,t){<span class="cstat-no" title="statement not covered" >return Math.sqrt(ca(e,t))}</span>,ua=Object.freeze({__proto__:null,distanceSq2:ca,distance2:aa}),sa=[["cx","cy"],["x","y"]],fa=function <span class="fstat-no" title="function not covered" >controlPoint(</span>e){var t=<span class="cstat-no" title="statement not covered" >[0,0],</span>n=<span class="cstat-no" title="statement not covered" >{selected:!1,svg:void 0,updatePosition:function <span class="fstat-no" title="function not covered" >updatePosition(</span>e){<span class="cstat-no" title="statement not covered" >return e}</span>},</span>r=<span class="cstat-no" title="statement not covered" >function <span class="fstat-no" title="function not covered" >updateSVG(</span>){<span class="cstat-no" title="statement not covered" >n.svg&amp;&amp;(n.svg.parentNode||e.appendChild(n.svg),sa.filter((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return null!=n.svg[e[0]]}</span>)).forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return e.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(e,r){<span class="cstat-no" title="statement not covered" >n.svg.setAttribute(e,t[r])}</span>))}</span>)))}</span>,</span>o=<span class="cstat-no" title="statement not covered" >new Proxy(t,{set:function <span class="fstat-no" title="function not covered" >set(</span>e,t,n){<span class="cstat-no" title="statement not covered" >return e[t]=n,r(),!0}</span>}),</span>i=<span class="cstat-no" title="statement not covered" >function <span class="fstat-no" title="function not covered" >setPosition(</span>){<span class="cstat-no" title="statement not covered" >gc.apply(void 0,_toConsumableArray(_c.apply(void 0,arguments))).forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(e,n){<span class="cstat-no" title="statement not covered" >t[n]=e}</span>)),r(),"function"==typeof t.delegate&amp;&amp;t.delegate.apply(t.pointsContainer,[o,t.pointsContainer])}</span>;<span class="cstat-no" title="statement not covered" ></span>return t.delegate=void 0,t.setPosition=i,t.onMouseMove=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return n.selected?i(n.updatePosition(e)):void 0}</span>,t.onMouseUp=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >n.selected=!1}</span>,t.distance=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return Math.sqrt(ca(e,t))}</span>,["x","y"].forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(e,n){<span class="cstat-no" title="statement not covered" >return Object.defineProperty(t,e,{get:function <span class="fstat-no" title="function not covered" >get(</span>){<span class="cstat-no" title="statement not covered" >return t[n]}</span>,set:function <span class="fstat-no" title="function not covered" >set(</span>e){<span class="cstat-no" title="statement not covered" >t[n]=e}</span>})}</span>)),["svg","updatePosition","selected"].forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return Object.defineProperty(t,e,{get:function <span class="fstat-no" title="function not covered" >get(</span>){<span class="cstat-no" title="statement not covered" >return n[e]}</span>,set:function <span class="fstat-no" title="function not covered" >set(</span>t){<span class="cstat-no" title="statement not covered" >n[e]=t}</span>})}</span>)),Object.defineProperty(t,"remove",{value:function <span class="fstat-no" title="function not covered" >value(</span>){<span class="cstat-no" title="statement not covered" >!function <span class="fstat-no" title="function not covered" >removeFromParent(</span>e){<span class="cstat-no" title="statement not covered" >e&amp;&amp;e.parentNode&amp;&amp;e.parentNode.removeChild(e)}</span>(n.svg),t.delegate=void 0}</span>}),o}</span>,la=function <span class="fstat-no" title="function not covered" >controls(</span>e,t,n){var r,o,i=<span class="cstat-no" title="statement not covered" >Array.from(Array(t)).map((<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return fa(e)}</span>)),</span>c=<span class="cstat-no" title="statement not covered" >function <span class="fstat-no" title="function not covered" >protocol(</span>e){<span class="cstat-no" title="statement not covered" >return"function"==typeof o?o.call(i,e,r,i):void 0}</span>;<span class="cstat-no" title="statement not covered" ></span>i.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >e.delegate=c,e.pointsContainer=i}</span>));<span class="cstat-no" title="statement not covered" >e</span>.onPress=function <span class="fstat-no" title="function not covered" >mousePressedHandler(</span>e){<span class="cstat-no" title="statement not covered" >i.length&gt;0&amp;&amp;(r=i.map((<span class="fstat-no" title="function not covered" >fu</span>nction(t,n){<span class="cstat-no" title="statement not covered" >return{i:n,d:ca(t,[e.x,e.y])}}</span>)).sort((<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){<span class="cstat-no" title="statement not covered" >return e.d-t.d}</span>)).shift().i,i[r].selected=!0)}</span>,e.onMove=function <span class="fstat-no" title="function not covered" >mouseMovedHandler(</span>e){<span class="cstat-no" title="statement not covered" >i.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t.onMouseMove(e)}</span>))}</span>,e.onRelease=function <span class="fstat-no" title="function not covered" >mouseReleasedHandler(</span>){<span class="cstat-no" title="statement not covered" >i.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return e.onMouseUp()}</span>)),r=void 0}</span>,Object.defineProperty(i,"selectedIndex",{get:function <span class="fstat-no" title="function not covered" >get(</span>){<span class="cstat-no" title="statement not covered" >return r}</span>}),Object.defineProperty(i,"selected",{get:function <span class="fstat-no" title="function not covered" >get(</span>){<span class="cstat-no" title="statement not covered" >return i[r]}</span>}),Object.defineProperty(i,"add",{value:function <span class="fstat-no" title="function not covered" >value(</span>t){<span class="cstat-no" title="statement not covered" >i.push(fa(e))}</span>}),i.removeAll=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >for(;i.length&gt;0;)<span class="cstat-no" title="statement not covered" >i.pop().remove()}</span></span>;v</span>ar a=<span class="cstat-no" title="statement not covered" >{onChange:function <span class="fstat-no" title="function not covered" >onChange(</span>e,t){<span class="cstat-no" title="statement not covered" >if(o=e,!0===t){var n=<span class="cstat-no" title="statement not covered" >i.length-1;<span class="cstat-no" title="statement not covered" ></span>e.call(i,i[n],n,i)}</span>}</span>,position:function <span class="fstat-no" title="function not covered" >position(</span>e){<span class="cstat-no" title="statement not covered" >return i.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(t,n){<span class="cstat-no" title="statement not covered" >return t.setPosition(e.call(i,t,n,i))}</span>))}</span>,svg:function <span class="fstat-no" title="function not covered" >svg(</span>e){<span class="cstat-no" title="statement not covered" >return i.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(t,n){<span class="cstat-no" title="statement not covered" >t.svg=e.call(i,t,n,i)}</span>))}</span>};<span class="cstat-no" title="statement not covered" ></span>return Object.keys(a).forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >i[e]=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return"function"==typeof arguments[0]&amp;&amp;a[e].apply(a,arguments),i}</span>}</span>)),i.parent=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return null!=e&amp;&amp;null!=e.appendChild&amp;&amp;i.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >e.appendChild(t.svg)}</span>)),i}</span>,i}</span>,va=function <span class="fstat-no" title="function not covered" >applyControlsToSVG(</span>e){<span class="cstat-no" title="statement not covered" >e.controls=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >for(var t=<span class="cstat-no" title="statement not covered" >arguments.length,</span>n=<span class="cstat-no" title="statement not covered" >new Array(t),</span>r=<span class="cstat-no" title="statement not covered" >0;</span>r&lt;t;r++)<span class="cstat-no" title="statement not covered" >n[r]=arguments[r];<span class="cstat-no" title="statement not covered" >r</span></span>eturn la.call.apply(la,[e,e].concat(n))}</span>}</span>,da=(new Qi.DOMParser).parseFromString("&lt;div /&gt;","text/xml").documentElement.constructor,pa={svg:{args:function <span class="fstat-no" title="function not covered" >args(</span>){<span class="cstat-no" title="statement not covered" >return[viewBox(gc.apply(void 0,arguments))].filter((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return null!=e}</span>))}</span>,methods:Jc,init:function <span class="fstat-no" title="function not covered" >init(</span>e){<span class="cstat-no" title="statement not covered" >for(var t=<span class="cstat-no" title="statement not covered" >arguments.length,</span>n=<span class="cstat-no" title="statement not covered" >new Array(t&gt;1?t-1:0),</span>r=<span class="cstat-no" title="statement not covered" >1;</span>r&lt;t;r++)<span class="cstat-no" title="statement not covered" >n[r-1]=arguments[r];<span class="cstat-no" title="statement not covered" >n</span></span>.filter((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return _typeof(e)===Hi.string}</span>)).forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return $c(e,t)}</span>)),n.filter((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return null!=e}</span>)).filter((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return e instanceof da}</span>)).filter((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return _typeof(e.appendChild)===Hi.function}</span>)).forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t.appendChild(e)}</span>)),ra(e),ia(e),va(e)}</span>}},_a=function <span class="fstat-no" title="function not covered" >loadGroup(</span>e){<span class="cstat-no" title="statement not covered" >for(var t=<span class="cstat-no" title="statement not covered" >arguments.length,</span>n=<span class="cstat-no" title="statement not covered" >new Array(t&gt;1?t-1:0),</span>r=<span class="cstat-no" title="statement not covered" >1;</span>r&lt;t;r++)<span class="cstat-no" title="statement not covered" >n[r-1]=arguments[r];v</span></span>ar o=<span class="cstat-no" title="statement not covered" >n.map((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return Gc(e)}</span>)).filter((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return void 0!==e}</span>));<span class="cstat-no" title="statement not covered" ></span>return o.filter((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return e.tagName===Hi.svg}</span>)).forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return Ic(e,t)}</span>)),o.filter((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return e.tagName!==Hi.svg}</span>)).forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return e.appendChild(t)}</span>)),e}</span>,ga={g:{init:_a,methods:{load:_a}}},ha=Object.assign(Object.create(null),{svg:["viewBox"],line:["x1","y1","x2","y2"],rect:["x","y","width","height"],circle:["cx","cy","r"],ellipse:["cx","cy","rx","ry"],polygon:["points"],polyline:["points"],path:["d"],text:["x","y"],mask:["id"],symbol:["id"],clipPath:["id","clip-rule"],marker:["id","markerHeight","markerUnits","markerWidth","orient","refX","refY"],linearGradient:["x1","x2","y1","y2"],radialGradient:["cx","cy","r","fr","fx","fy"],stop:["offset","stop-color","stop-opacity"],pattern:["patternContentUnits","patternTransform","patternUnits"]}),ma=function <span class="fstat-no" title="function not covered" >setRadius(</span>e,t){<span class="cstat-no" title="statement not covered" >return e.setAttribute(ha.circle[2],t),e}</span>,ya=function <span class="fstat-no" title="function not covered" >setOrigin(</span>e,t,n){<span class="cstat-no" title="statement not covered" >return _toConsumableArray(gc.apply(void 0,_toConsumableArray(_c(t,n))).slice(0,2)).forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(t,n){<span class="cstat-no" title="statement not covered" >return e.setAttribute(ha.circle[n],t)}</span>)),e}</span>,ba=function <span class="fstat-no" title="function not covered" >fromPoints(</span>e,t,n,r){<span class="cstat-no" title="statement not covered" >return[e,t,aa([e,t],[n,r])]}</span>,xa={circle:{args:function <span class="fstat-no" title="function not covered" >args(</span>e,t,n,r){var o=<span class="cstat-no" title="statement not covered" >gc.apply(void 0,_toConsumableArray(_c(e,t,n,r)));<span class="cstat-no" title="statement not covered" ></span>switch(o.length){case 0:case 1:<span class="cstat-no" title="statement not covered" >return[,,].concat(_toConsumableArray(o));c</span>ase 2:case 3:<span class="cstat-no" title="statement not covered" >return o;d</span>efault:<span class="cstat-no" title="statement not covered" >return ba.apply(void 0,_toConsumableArray(o))}</span>}</span>,methods:{radius:ma,setRadius:ma,origin:ya,setOrigin:ya,center:ya,setCenter:ya,position:ya,setPosition:ya}}},Aa=function <span class="fstat-no" title="function not covered" >setRadii(</span>e,t,n){<span class="cstat-no" title="statement not covered" >return[,,t,n].forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(t,n){<span class="cstat-no" title="statement not covered" >return e.setAttribute(ha.ellipse[n],t)}</span>)),e}</span>,ka=function <span class="fstat-no" title="function not covered" >setCenter(</span>e,t,n){<span class="cstat-no" title="statement not covered" >return _toConsumableArray(gc.apply(void 0,_toConsumableArray(_c(t,n))).slice(0,2)).forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(t,n){<span class="cstat-no" title="statement not covered" >return e.setAttribute(ha.ellipse[n],t)}</span>)),e}</span>,wa={ellipse:{args:function <span class="fstat-no" title="function not covered" >args(</span>e,t,n,r){var o=<span class="cstat-no" title="statement not covered" >gc.apply(void 0,_toConsumableArray(_c(e,t,n,r))).slice(0,4);<span class="cstat-no" title="statement not covered" ></span>switch(o.length){case 0:case 1:case 2:<span class="cstat-no" title="statement not covered" >return[,,].concat(_toConsumableArray(o));d</span>efault:<span class="cstat-no" title="statement not covered" >return o}</span>}</span>,methods:{radius:Aa,setRadius:Aa,origin:ka,setOrigin:ka,center:ka,setCenter:ka,position:ka,setPosition:ka}}},Ea=function <span class="fstat-no" title="function not covered" >Args(</span>e,t,n,r){<span class="cstat-no" title="statement not covered" >return gc.apply(void 0,_toConsumableArray(_c(e,t,n,r))).slice(0,4)}</span>,Ma={line:{args:Ea,methods:{setPoints:function <span class="fstat-no" title="function not covered" >setPoints(</span>e,t,n,r,o){<span class="cstat-no" title="statement not covered" >return Ea(t,n,r,o).forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(t,n){<span class="cstat-no" title="statement not covered" >return e.setAttribute(ha.line[n],t)}</span>)),e}</span>}}},Oa=/[MmLlSsQqLlHhVvCcSsQqTtAaZz]/g,ja=/-?[0-9]*\.?\d+/g,Ca={m:"move",l:"line",v:"vertical",h:"horizontal",a:"ellipse",c:"curve",s:"smoothCurve",q:"quadCurve",t:"smoothQuadCurve",z:"close"};Object.keys(Ca).forEach((function(e){var t=Ca[e];Ca[e.toUpperCase()]=t.charAt(0).toUpperCase()+t.slice(1)}));var Sa=function <span class="fstat-no" title="function not covered" >getD(</span>e){var t=<span class="cstat-no" title="statement not covered" >e.getAttribute("d");<span class="cstat-no" title="statement not covered" ></span>return null==t?"":t}</span>,Pa=function <span class="fstat-no" title="function not covered" >appendPathCommand(</span>e,t){<span class="cstat-no" title="statement not covered" >for(var n=<span class="cstat-no" title="statement not covered" >arguments.length,</span>r=<span class="cstat-no" title="statement not covered" >new Array(n&gt;2?n-2:0),</span>o=<span class="cstat-no" title="statement not covered" >2;</span>o&lt;n;o++)<span class="cstat-no" title="statement not covered" >r[o-2]=arguments[o];<span class="cstat-no" title="statement not covered" >r</span></span>eturn e.setAttribute("d","".concat(Sa(e)).concat(t).concat(_c.apply(void 0,r).join(" "))),e}</span>,Na=function <span class="fstat-no" title="function not covered" >getCommands(</span>e){<span class="cstat-no" title="statement not covered" >return function <span class="fstat-no" title="function not covered" >parsePathCommands(</span>e){<span class="cstat-no" title="statement not covered" >for(var t,n=<span class="cstat-no" title="statement not covered" >[];</span>null!==(t=Oa.exec(e));)<span class="cstat-no" title="statement not covered" >n.push(t);<span class="cstat-no" title="statement not covered" >r</span></span>eturn n.map((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return{command:e[t.index],index:t.index}}</span>)).reduceRight((<span class="fstat-no" title="function not covered" >fu</span>nction(t,n){var r=<span class="cstat-no" title="statement not covered" >e.substring(n.index,t.length?t[t.length-1].index:e.length);<span class="cstat-no" title="statement not covered" ></span>return t.concat([{command:n.command,index:n.index,chunk:r.length&gt;0?r.substr(1,r.length-1):r}])}</span>),[]).reverse().map((<span class="fstat-no" title="function not covered" >fu</span>nction(e){var t=<span class="cstat-no" title="statement not covered" >e.chunk.match(ja);<span class="cstat-no" title="statement not covered" ></span>return e.en=Ca[e.command],e.values=t?t.map(parseFloat):[],delete e.chunk,e}</span>))}</span>(Sa(e))}</span>,za={addCommand:Pa,appendCommand:Pa,clear:function <span class="fstat-no" title="function not covered" >clear(</span>e){<span class="cstat-no" title="statement not covered" >return e.removeAttribute("d"),e}</span>,getCommands:Na,get:Na,getD:function <span class="fstat-no" title="function not covered" >getD(</span>e){<span class="cstat-no" title="statement not covered" >return e.getAttribute("d")}</span>};Object.keys(Ca).forEach((function(e){za[Ca[e]]=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >for(var n=<span class="cstat-no" title="statement not covered" >arguments.length,</span>r=<span class="cstat-no" title="statement not covered" >new Array(n&gt;1?n-1:0),</span>o=<span class="cstat-no" title="statement not covered" >1;</span>o&lt;n;o++)<span class="cstat-no" title="statement not covered" >r[o-1]=arguments[o];<span class="cstat-no" title="statement not covered" >r</span></span>eturn Pa.apply(void 0,[t,e].concat(r))}</span>}));var Ia={path:{methods:za}},La=function <span class="fstat-no" title="function not covered" >setRectSize(</span>e,t,n){<span class="cstat-no" title="statement not covered" >return[,,t,n].forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(t,n){<span class="cstat-no" title="statement not covered" >return e.setAttribute(ha.rect[n],t)}</span>)),e}</span>,qa=function <span class="fstat-no" title="function not covered" >setRectOrigin(</span>e,t,n){<span class="cstat-no" title="statement not covered" >return _toConsumableArray(gc.apply(void 0,_toConsumableArray(_c(t,n))).slice(0,2)).forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(t,n){<span class="cstat-no" title="statement not covered" >return e.setAttribute(ha.rect[n],t)}</span>)),e}</span>,Ta=function <span class="fstat-no" title="function not covered" >fixNegatives(</span>e){<span class="cstat-no" title="statement not covered" >return[0,1].forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >e[2+t]&lt;0&amp;&amp;(void 0===e[0+t]&amp;&amp;(e[0+t]=0),e[0+t]+=e[2+t],e[2+t]=-e[2+t])}</span>)),e}</span>,Fa={rect:{args:function <span class="fstat-no" title="function not covered" >args(</span>e,t,n,r){var o=<span class="cstat-no" title="statement not covered" >gc.apply(void 0,_toConsumableArray(_c(e,t,n,r))).slice(0,4);<span class="cstat-no" title="statement not covered" ></span>switch(o.length){case 0:case 1:case 2:case 3:<span class="cstat-no" title="statement not covered" >return Ta([,,].concat(_toConsumableArray(o)));d</span>efault:<span class="cstat-no" title="statement not covered" >return Ta(o)}</span>}</span>,methods:{origin:qa,setOrigin:qa,center:qa,setCenter:qa,size:La,setSize:La}}},Va={style:{init:function <span class="fstat-no" title="function not covered" >init(</span>e,t){<span class="cstat-no" title="statement not covered" >e.textContent="",e.appendChild(Nc(t))}</span>,methods:{setTextContent:function <span class="fstat-no" title="function not covered" >setTextContent(</span>e,t){<span class="cstat-no" title="statement not covered" >return e.textContent="",e.appendChild(Nc(t)),e}</span>}}},Ga={text:{args:function <span class="fstat-no" title="function not covered" >args(</span>e,t,n){<span class="cstat-no" title="statement not covered" >return gc.apply(void 0,_toConsumableArray(_c(e,t,n))).slice(0,2)}</span>,init:function <span class="fstat-no" title="function not covered" >init(</span>e,t,n,r,o){var i=<span class="cstat-no" title="statement not covered" >[t,n,r,o].filter((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return _typeof(e)===Hi.string}</span>)).shift();<span class="cstat-no" title="statement not covered" ></span>i&amp;&amp;e.appendChild(Qi.document.createTextNode(i))}</span>}},Ba=function <span class="fstat-no" title="function not covered" >makeIDString(</span>){<span class="cstat-no" title="statement not covered" >return Array.from(arguments).filter((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return _typeof(e)===Hi.string||e instanceof String}</span>)).shift()||oa()}</span>,Da=function <span class="fstat-no" title="function not covered" >args(</span>){<span class="cstat-no" title="statement not covered" >return[Ba.apply(void 0,arguments)]}</span>,Ra={mask:{args:Da},clipPath:{args:Da},symbol:{args:Da},marker:{args:Da,methods:{size:Rc,setViewBox:Rc}}},Ua=function <span class="fstat-no" title="function not covered" >getPoints(</span>e){var t=<span class="cstat-no" title="statement not covered" >e.getAttribute("points");<span class="cstat-no" title="statement not covered" ></span>return null==t?"":t}</span>,Za=function <span class="fstat-no" title="function not covered" >polyString(</span>){var e=<span class="cstat-no" title="statement not covered" >arguments;<span class="cstat-no" title="statement not covered" ></span>return Array.from(Array(Math.floor(arguments.length/2))).map((<span class="fstat-no" title="function not covered" >fu</span>nction(t,n){<span class="cstat-no" title="statement not covered" >return"".concat(e[2*n+0],",").concat(e[2*n+1])}</span>)).join(" ")}</span>,Xa=function <span class="fstat-no" title="function not covered" >stringifyArgs(</span>){<span class="cstat-no" title="statement not covered" >return[Za.apply(void 0,_toConsumableArray(gc.apply(void 0,_toConsumableArray(_c.apply(void 0,arguments)))))]}</span>,$a=function <span class="fstat-no" title="function not covered" >setPoints$1(</span>e){<span class="cstat-no" title="statement not covered" >for(var t=<span class="cstat-no" title="statement not covered" >arguments.length,</span>n=<span class="cstat-no" title="statement not covered" >new Array(t&gt;1?t-1:0),</span>r=<span class="cstat-no" title="statement not covered" >1;</span>r&lt;t;r++)<span class="cstat-no" title="statement not covered" >n[r-1]=arguments[r];<span class="cstat-no" title="statement not covered" >r</span></span>eturn e.setAttribute("points",Xa.apply(void 0,n)[0]),e}</span>,Ha=function <span class="fstat-no" title="function not covered" >addPoint(</span>e){<span class="cstat-no" title="statement not covered" >for(var t=<span class="cstat-no" title="statement not covered" >arguments.length,</span>n=<span class="cstat-no" title="statement not covered" >new Array(t&gt;1?t-1:0),</span>r=<span class="cstat-no" title="statement not covered" >1;</span>r&lt;t;r++)<span class="cstat-no" title="statement not covered" >n[r-1]=arguments[r];<span class="cstat-no" title="statement not covered" >r</span></span>eturn e.setAttribute("points",[Ua(e),Xa.apply(void 0,n)[0]].filter((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return""!==e}</span>)).join(" ")),e}</span>,Ya=function <span class="fstat-no" title="function not covered" >Args$1(</span>){<span class="cstat-no" title="statement not covered" >return 1===arguments.length&amp;&amp;_typeof(arguments.length&lt;=0?void 0:arguments[0])===Hi.string?[arguments.length&lt;=0?void 0:arguments[0]]:Xa.apply(void 0,arguments)}</span>,Wa={polyline:{args:Ya,methods:{setPoints:$a,addPoint:Ha}},polygon:{args:Ya,methods:{setPoints:$a,addPoint:Ha}}},Ja=Object.assign({},pa,ga,xa,wa,Ma,Ia,Fa,Va,Ga,Ra,Wa),Ka={presentation:["color","color-interpolation","cursor","direction","display","fill","fill-opacity","fill-rule","font-family","font-size","font-size-adjust","font-stretch","font-style","font-variant","font-weight","image-rendering","letter-spacing","opacity","overflow","paint-order","pointer-events","preserveAspectRatio","shape-rendering","stroke","stroke-dasharray","stroke-dashoffset","stroke-linecap","stroke-linejoin","stroke-miterlimit","stroke-opacity","stroke-width","tabindex","transform-origin","user-select","vector-effect","visibility"],animation:["accumulate","additive","attributeName","begin","by","calcMode","dur","end","from","keyPoints","keySplines","keyTimes","max","min","repeatCount","repeatDur","restart","to","values"],effects:["azimuth","baseFrequency","bias","color-interpolation-filters","diffuseConstant","divisor","edgeMode","elevation","exponent","filter","filterRes","filterUnits","flood-color","flood-opacity","in","in2","intercept","k1","k2","k3","k4","kernelMatrix","lighting-color","limitingConeAngle","mode","numOctaves","operator","order","pointsAtX","pointsAtY","pointsAtZ","preserveAlpha","primitiveUnits","radius","result","seed","specularConstant","specularExponent","stdDeviation","stitchTiles","surfaceScale","targetX","targetY","type","xChannelSelector","yChannelSelector"],text:["dx","dy","alignment-baseline","baseline-shift","dominant-baseline","lengthAdjust","method","overline-position","overline-thickness","rotate","spacing","startOffset","strikethrough-position","strikethrough-thickness","text-anchor","text-decoration","text-rendering","textLength","underline-position","underline-thickness","word-spacing","writing-mode"],gradient:["gradientTransform","gradientUnits","spreadMethod"]};Object.values(tc).reduce((function(e,t){return e.concat(t)}),[]).filter((function(e){return void 0===ha[e]})).forEach((function(e){ha[e]=[]})),[[["svg","defs","g"].concat(tc.v,tc.t),Ka.presentation],[["filter"],Ka.effects],[tc.cT.concat("text"),Ka.text],[tc.cF,Ka.effects],[tc.cG,Ka.gradient]].forEach((function(e){return e[0].forEach((function(t){ha[t]=ha[t].concat(e[1])}))}));var Qa=function <span class="fstat-no" title="function not covered" >getClassList(</span>e){<span class="cstat-no" title="statement not covered" >if(null==e)<span class="cstat-no" title="statement not covered" >return[];v</span></span>ar t=<span class="cstat-no" title="statement not covered" >e.getAttribute(Hi.class);<span class="cstat-no" title="statement not covered" ></span>return null==t?[]:t.split(" ").filter((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return""!==e}</span>))}</span>,eu={addClass:function <span class="fstat-no" title="function not covered" >addClass(</span>e,t){var n=<span class="cstat-no" title="statement not covered" >Qa(e).filter((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return e!==t}</span>));<span class="cstat-no" title="statement not covered" ></span>n.push(t),e.setAttributeNS(null,Hi.class,n.join(" "))}</span>,removeClass:function <span class="fstat-no" title="function not covered" >removeClass(</span>e,t){var n=<span class="cstat-no" title="statement not covered" >Qa(e).filter((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return e!==t}</span>));<span class="cstat-no" title="statement not covered" ></span>e.setAttributeNS(null,Hi.class,n.join(" "))}</span>,setClass:function <span class="fstat-no" title="function not covered" >setClass(</span>e,t){<span class="cstat-no" title="statement not covered" >e.setAttributeNS(null,Hi.class,t)}</span>,setId:function <span class="fstat-no" title="function not covered" >setId(</span>e,t){<span class="cstat-no" title="statement not covered" >e.setAttributeNS(null,Hi.id,t)}</span>},tu=function <span class="fstat-no" title="function not covered" >getAttr(</span>e){var t=<span class="cstat-no" title="statement not covered" >e.getAttribute(Hi.transform);<span class="cstat-no" title="statement not covered" ></span>return null==t||""===t?void 0:t}</span>,nu={clearTransform:function <span class="fstat-no" title="function not covered" >clearTransform(</span>e){<span class="cstat-no" title="statement not covered" >return e.removeAttribute(Hi.transform),e}</span>};["translate","rotate","scale","matrix"].forEach((function(e){nu[e]=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >for(var n=<span class="cstat-no" title="statement not covered" >arguments.length,</span>r=<span class="cstat-no" title="statement not covered" >new Array(n&gt;1?n-1:0),</span>o=<span class="cstat-no" title="statement not covered" >1;</span>o&lt;n;o++)<span class="cstat-no" title="statement not covered" >r[o-1]=arguments[o];<span class="cstat-no" title="statement not covered" >r</span></span>eturn t.setAttribute(Hi.transform,[tu(t),"".concat(e,"(").concat(r.join(" "),")")].filter((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return void 0!==e}</span>)).join(" "))}</span>}));var ru={};["clip-path","mask","symbol","marker-end","marker-mid","marker-start"].forEach((function(e){ru[Sc.toCamel(e)]=<span class="fstat-no" title="function not covered" >fu</span>nction(t,n){<span class="cstat-no" title="statement not covered" >return t.setAttribute(e,function <span class="fstat-no" title="function not covered" >findIdURL(</span>e){<span class="cstat-no" title="statement not covered" >if(null==e)<span class="cstat-no" title="statement not covered" >return"";<span class="cstat-no" title="statement not covered" >i</span></span>f(_typeof(e)===Hi.string)<span class="cstat-no" title="statement not covered" >return"url"===e.slice(0,3)?e:"url(#".concat(e,")");<span class="cstat-no" title="statement not covered" >i</span></span>f(null!=e.getAttribute){var t=<span class="cstat-no" title="statement not covered" >e.getAttribute(Hi.id);<span class="cstat-no" title="statement not covered" ></span>return"url(#".concat(t,")")}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn""}</span>(n))}</span>}));var ou={};(Ri=tc.v).push.apply(Ri,_toConsumableArray(Object.keys(kc))),Object.keys(kc).forEach((function(e){kc[e].attributes=void 0===kc[e].attributes?<span class="branch-0 cbranch-no" title="branch not covered" >_toConsumableArray(Ka.presentation):</span>kc[e].attributes.concat(Ka.presentation)})),Object.assign(ou,Ja,kc),Object.keys(tc).forEach((function(e){return tc[e].filter((function(e){return void 0===ou[e]})).forEach((function(e){ou[e]={}}))}));var iu=function <span class="fstat-no" title="function not covered" >passthrough(</span>){<span class="cstat-no" title="statement not covered" >return Array.from(arguments)}</span>;Object.keys(ou).forEach((function(e){ou[e].nodeName||(ou[e].nodeName=e),ou[e].init||(ou[e].init=iu),ou[e].args||(ou[e].args=iu),ou[e].methods||(ou[e].methods={}),ou[e].attributes||(ou[e].attributes=ha[e]||<span class="branch-1 cbranch-no" title="branch not covered" >[])</span>}));var cu=function assign(e,t){e.forEach((function(e){return Object.keys(t).forEach((function(n){ou[e].methods[n]=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return t[n].apply(t,arguments),arguments[0]}</span>}))}))};cu(_c(tc.t,tc.v,tc.g,tc.s,tc.p,tc.i,tc.h,tc.d),eu),cu(_c(tc.t,tc.v,tc.g,tc.s,tc.p,tc.i,tc.h,tc.d),qc),cu(_c(tc.v,tc.g,tc.s),nu),cu(_c(tc.t,tc.v,tc.g),ru);var au={svg:{version:"1.1",xmlns:ec},style:{type:"text/css"}},uu=function <span class="fstat-no" title="function not covered" >RequiredAttributes(</span>e,t){<span class="cstat-no" title="statement not covered" >au[t]&amp;&amp;Object.keys(au[t]).forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(n){<span class="cstat-no" title="statement not covered" >return e.setAttribute(n,au[t][n])}</span>))}</span>,su={},fu=function <span class="fstat-no" title="function not covered" >constructor(</span>e){<span class="cstat-no" title="statement not covered" >for(var t,n,r=<span class="cstat-no" title="statement not covered" >arguments.length,</span>o=<span class="cstat-no" title="statement not covered" >new Array(r&gt;1?r-1:0),</span>i=<span class="cstat-no" title="statement not covered" >1;</span>i&lt;r;i++)<span class="cstat-no" title="statement not covered" >o[i-1]=arguments[i];v</span></span>ar c=<span class="cstat-no" title="statement not covered" >Qi.document.createElementNS(ec,ou[e].nodeName);<span class="cstat-no" title="statement not covered" ></span>return uu(c,e),(t=ou[e]).init.apply(t,[c].concat(o)),(n=ou[e]).args.apply(n,o).forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(t,n){<span class="cstat-no" title="statement not covered" >null!=ou[e].attributes[n]&amp;&amp;c.setAttribute(ou[e].attributes[n],t)}</span>)),ou[e].attributes.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >Object.defineProperty(c,Sc.toCamel(e),{value:function <span class="fstat-no" title="function not covered" >value(</span>){<span class="cstat-no" title="statement not covered" >return c.setAttribute.apply(c,[e].concat(Array.prototype.slice.call(arguments))),c}</span>})}</span>)),Object.keys(ou[e].methods).forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return Object.defineProperty(c,t,{value:function <span class="fstat-no" title="function not covered" >value(</span>){var n;<span class="cstat-no" title="statement not covered" >return(n=ou[e].methods[t]).call.apply(n,[su,c].concat(Array.prototype.slice.call(arguments)))}</span>})}</span>)),Cc[e]&amp;&amp;Cc[e].forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >Object.defineProperty(c,e,{value:function <span class="fstat-no" title="function not covered" >value(</span>){var t=<span class="cstat-no" title="statement not covered" >constructor.apply(void 0,[e].concat(Array.prototype.slice.call(arguments)));<span class="cstat-no" title="statement not covered" ></span>return c.appendChild(t),t}</span>})}</span>)),c}</span>;su.Constructor=fu;var lu={};Object.keys(tc).forEach((function(e){return tc[e].forEach((function(e){lu[e]=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >for(var t=<span class="cstat-no" title="statement not covered" >arguments.length,</span>n=<span class="cstat-no" title="statement not covered" >new Array(t),</span>r=<span class="cstat-no" title="statement not covered" >0;</span>r&lt;t;r++)<span class="cstat-no" title="statement not covered" >n[r]=arguments[r];<span class="cstat-no" title="statement not covered" >r</span></span>eturn fu.apply(void 0,[e].concat(n))}</span>}))}));var vu=function <span class="fstat-no" title="function not covered" >getFoldObject(</span>e){<span class="cstat-no" title="statement not covered" >return e.filter((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return function <span class="fstat-no" title="function not covered" >possibleFoldObject(</span>e){<span class="cstat-no" title="statement not covered" >if("object"!==_typeof(e))<span class="cstat-no" title="statement not covered" >return!1;v</span></span>ar t=<span class="cstat-no" title="statement not covered" >["vertices_coords","edges_vertices","faces_vertices","faces_edges"];<span class="cstat-no" title="statement not covered" ></span>return Object.keys(e).map((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return t.includes(e)}</span>)).reduce((<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){<span class="cstat-no" title="statement not covered" >return e||t}</span>),!1)}</span>(e)}</span>)).shift()}</span>,du=function <span class="fstat-no" title="function not covered" >initialize(</span>e){<span class="cstat-no" title="statement not covered" >for(var t=<span class="cstat-no" title="statement not covered" >arguments.length,</span>n=<span class="cstat-no" title="statement not covered" >new Array(t&gt;1?t-1:0),</span>r=<span class="cstat-no" title="statement not covered" >1;</span>r&lt;t;r++)<span class="cstat-no" title="statement not covered" >n[r-1]=arguments[r];<span class="cstat-no" title="statement not covered" >n</span></span>.filter((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return _typeof(e)===Hi.function}</span>)).forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t.call(e,e)}</span>))}</span>,pu=function <span class="fstat-no" title="function not covered" >SVG(</span>){var e=<span class="cstat-no" title="statement not covered" >arguments,</span>t=<span class="cstat-no" title="statement not covered" >fu.apply(void 0,[Hi.svg].concat(Array.prototype.slice.call(arguments)));<span class="cstat-no" title="statement not covered" ></span>return"loading"===Qi.document.readyState?Qi.document.addEventListener("DOMContentLoaded",(<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return du.apply(void 0,[t].concat(_toConsumableArray(e)))}</span>)):du.apply(void 0,[t].concat(Array.prototype.slice.call(arguments))),t}</span>;function <span class="fstat-no" title="function not covered" >vkXML$1(</span>e,t){<span class="cstat-no" title="statement not covered" >for(var n=<span class="cstat-no" title="statement not covered" >e.replace(/&gt;\s{0,}&lt;/g,"&gt;&lt;").replace(/&lt;/g,"~::~&lt;").replace(/\s*xmlns\:/g,"~::~xmlns:").split("~::~"),</span>r=<span class="cstat-no" title="statement not covered" >n.length,</span>o=<span class="cstat-no" title="statement not covered" >!1,</span>i=<span class="cstat-no" title="statement not covered" >0,</span>c=<span class="cstat-no" title="statement not covered" >"",</span>a=<span class="cstat-no" title="statement not covered" >null!=t&amp;&amp;"string"==typeof t?t:"\t",</span>u=<span class="cstat-no" title="statement not covered" >["\n"],</span>s=<span class="cstat-no" title="statement not covered" >0;</span>s&lt;100;s+=1)<span class="cstat-no" title="statement not covered" >u.push(u[s]+a);<span class="cstat-no" title="statement not covered" >f</span></span>or(var l=<span class="cstat-no" title="statement not covered" >0;</span>l&lt;r;l+=1)<span class="cstat-no" title="statement not covered" >n[l].search(/&lt;!/)&gt;-1?(c+=u[i]+n[l],o=!0,(n[l].search(/--&gt;/)&gt;-1||n[l].search(/\]&gt;/)&gt;-1||n[l].search(/!DOCTYPE/)&gt;-1)&amp;&amp;(o=!1)):n[l].search(/--&gt;/)&gt;-1||n[l].search(/\]&gt;/)&gt;-1?(c+=n[l],o=!1):/^&lt;\w/.exec(n[l-1])&amp;&amp;/^&lt;\/\w/.exec(n[l])&amp;&amp;/^&lt;[\w:\-\.\,]+/.exec(n[l-1])==/^&lt;\/[\w:\-\.\,]+/.exec(n[l])[0].replace("/","")?(c+=n[l],o||(i-=1)):n[l].search(/&lt;\w/)&gt;-1&amp;&amp;-1===n[l].search(/&lt;\//)&amp;&amp;-1===n[l].search(/\/&gt;/)?c=c+=o?n[l]:u[i++]+n[l]:n[l].search(/&lt;\w/)&gt;-1&amp;&amp;n[l].search(/&lt;\//)&gt;-1?c=c+=o?n[l]:u[i]+n[l]:n[l].search(/&lt;\//)&gt;-1?c=c+=o?n[l]:u[--i]+n[l]:n[l].search(/\/&gt;/)&gt;-1?c=c+=o?n[l]:u[i]+n[l]:n[l].search(/&lt;\?/)&gt;-1||n[l].search(/xmlns\:/)&gt;-1||n[l].search(/xmlns\=/)&gt;-1?c+=u[i]+n[l]:c+=n[l];<span class="cstat-no" title="statement not covered" >r</span></span>eturn"\n"===c[0]?c.slice(1):c}</span>Object.assign(pu,lu),pu.NS=ec,pu.linker=function Linker(e){var t=this;["segment","circle","ellipse","rect","polygon"].filter((function(t){return e[t]&amp;&amp;e[t].prototype})).forEach((function(n){e[n].prototype.svg=<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return t.path(this.svgPath())}</span>})),e.svg=t}.bind(pu),pu.use=function use(e){e.origami&amp;&amp;function bindRabbitEar(e,t){Kc.math.vector=t.vector}(0,e),e.render_into_svg&amp;&amp;function bindFoldToSvg(e,t){var n=ou.svg.init;ou.svg.init=<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >for(var r=<span class="cstat-no" title="statement not covered" >arguments.length,</span>o=<span class="cstat-no" title="statement not covered" >new Array(r&gt;1?r-1:0),</span>i=<span class="cstat-no" title="statement not covered" >1;</span>i&lt;r;i++)<span class="cstat-no" title="statement not covered" >o[i-1]=arguments[i];v</span></span>ar c=<span class="cstat-no" title="statement not covered" >vu(o);<span class="cstat-no" title="statement not covered" ></span>if(c){var a=<span class="cstat-no" title="statement not covered" >t.options.apply(t,o);<span class="cstat-no" title="statement not covered" ></span>t.render_into_svg(e,c,a)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn n.apply(void 0,[e].concat(o))}</span>}(0,e)}.bind(pu),pu.core=Object.assign(Object.create(null),{load:Bc,save:Dc,coordinates:gc,flatten:_c,attributes:ha,children:Cc,cdata:Nc,detect:Ki},Sc,eu,qc,ua,nu,Xc);var _u="vertices",gu="edges",hu="faces",mu="boundaries",yu="boundary",bu="mountain",xu="valley",Au="mark",ku="unassigned",wu="front",Eu="back",Mu="svg",Ou="class",ju="index",Cu="object",Su="string",Pu="undefined",Nu="black",zu="white",Iu="lightgray",Lu="stroke-width",qu="vertices_coords",Tu="edges_vertices",Fu="faces_vertices",Vu="faces_edges",Gu="edges_assignment",Bu="faces_re:layer",Du=("undefined"==typeof window?"undefined":<span class="branch-1 cbranch-no" title="branch not covered" >_typeof(window))</span>!==Pu&amp;&amp;<span class="branch-1 cbranch-no" title="branch not covered" >_typeof(window.document)!==Pu,</span>Ru=("undefined"==typeof process?<span class="branch-0 cbranch-no" title="branch not covered" >"undefined":</span>_typeof(process))!==Pu&amp;&amp;null!=process.versions&amp;&amp;null!=process.versions.node,Uu=function(){var e={};<span class="missing-if-branch" title="else path not taken" >E</span>if(Ru){var t=require("xmldom"),n=t.DOMParser,r=t.XMLSerializer;e.DOMParser=n,e.XMLSerializer=r,e.document=(new n).parseFromString("&lt;!DOCTYPE html&gt;&lt;title&gt;.&lt;/title&gt;","text/html")}else <span class="cstat-no" title="statement not covered" >Du&amp;&amp;(e=window);r</span>eturn e}(),Zu="http://www.w3.org/2000/svg",Xu={SVG:{NS:Zu,g:function <span class="fstat-no" title="function not covered" >g(</span>){<span class="cstat-no" title="statement not covered" >return Uu.document.createElementNS(Zu,"g")}</span>,defs:function <span class="fstat-no" title="function not covered" >defs(</span>){<span class="cstat-no" title="statement not covered" >return Uu.document.createElementNS(Zu,"defs")}</span>,style:function <span class="fstat-no" title="function not covered" >style(</span>){var e=<span class="cstat-no" title="statement not covered" >Uu.document.createElementNS(Zu,"style");<span class="cstat-no" title="statement not covered" ></span>return e.setAttributeNS(null,"type","text/css"),e}</span>,line:function <span class="fstat-no" title="function not covered" >line(</span>e,t,n,r){var o=<span class="cstat-no" title="statement not covered" >Uu.document.createElementNS(Zu,"line");<span class="cstat-no" title="statement not covered" ></span>return o.setAttributeNS(null,"x1",e),o.setAttributeNS(null,"y1",t),o.setAttributeNS(null,"x2",n),o.setAttributeNS(null,"y2",r),o}</span>,circle:function <span class="fstat-no" title="function not covered" >circle(</span>e,t,n){var r=<span class="cstat-no" title="statement not covered" >Uu.document.createElementNS(Zu,"circle");<span class="cstat-no" title="statement not covered" ></span>return r.setAttributeNS(null,"cx",e),r.setAttributeNS(null,"cy",t),r.setAttributeNS(null,"r",n),r}</span>,polygon:function <span class="fstat-no" title="function not covered" >polygon(</span>e){var t=<span class="cstat-no" title="statement not covered" >Uu.document.createElementNS(Zu,"polygon"),</span>n=<span class="cstat-no" title="statement not covered" >e.map((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return"".concat(e[0],",").concat(e[1])}</span>)).join(" ");<span class="cstat-no" title="statement not covered" ></span>return t.setAttributeNS(null,"points",n),t}</span>,path:function <span class="fstat-no" title="function not covered" >path(</span>e){var t=<span class="cstat-no" title="statement not covered" >Uu.document.createElementNS(Zu,"path");<span class="cstat-no" title="statement not covered" ></span>return t.setAttributeNS(null,"d",e),t}</span>}},$u=function <span class="fstat-no" title="function not covered" >recursive_freeze(</span>e){<span class="cstat-no" title="statement not covered" >return Object.freeze(e),void 0===e||Object.getOwnPropertyNames(e).filter((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return null!==e[t]&amp;&amp;(_typeof(e[t])===Cu||"function"===_typeof(e[t]))&amp;&amp;!Object.isFrozen(e[t])}</span>)).forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return recursive_freeze(e[t])}</span>)),e}</span>,Hu=function <span class="fstat-no" title="function not covered" >recursive_assign(</span>e,t){<span class="cstat-no" title="statement not covered" >return Object.keys(t).forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(n){<span class="cstat-no" title="statement not covered" >_typeof(t[n])===Cu&amp;&amp;null!==t[n]?(n in e||(e[n]={}),recursive_assign(e[n],t[n])):_typeof(e)!==Cu||n in e||(e[n]=t[n])}</span>)),e}</span>,Yu=function <span class="fstat-no" title="function not covered" >get_object(</span>e){<span class="cstat-no" title="statement not covered" >if(null==e)<span class="cstat-no" title="statement not covered" >return{};<span class="cstat-no" title="statement not covered" >i</span></span>f(_typeof(e)===Cu&amp;&amp;null!==e)<span class="cstat-no" title="statement not covered" >return e;<span class="cstat-no" title="statement not covered" >i</span></span>f(_typeof(e)===Su||e instanceof String)<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >return JSON.parse(e)}</span>catch(e){<span class="cstat-no" title="statement not covered" >return{}}<span class="cstat-no" title="statement not covered" ></span>r</span></span>eturn{}}</span>,Wu=function <span class="fstat-no" title="function not covered" >bounding_rect(</span>e){<span class="cstat-no" title="statement not covered" >if(null==e.vertices_coords||e.vertices_coords.length&lt;=0)<span class="cstat-no" title="statement not covered" >return[0,0,0,0];v</span></span>ar t=<span class="cstat-no" title="statement not covered" >e.vertices_coords[0].length,</span>n=<span class="cstat-no" title="statement not covered" >Array(t).fill(1/0),</span>r=<span class="cstat-no" title="statement not covered" >Array(t).fill(-1/0);<span class="cstat-no" title="statement not covered" ></span>return e.vertices_coords.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return e.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){<span class="cstat-no" title="statement not covered" >e&lt;n[t]&amp;&amp;(n[t]=e),e&gt;r[t]&amp;&amp;(r[t]=e)}</span>))}</span>)),isNaN(n[0])||isNaN(n[1])||isNaN(r[0])||isNaN(r[1])?[0,0,0,0]:[n[0],n[1],r[0]-n[0],r[1]-n[1]]}</span>,Ju="none",Ku="500px",Qu=function <span class="fstat-no" title="function not covered" >Options(</span>){var e=<span class="cstat-no" title="statement not covered" >arguments.length&gt;0&amp;&amp;void 0!==arguments[0]?arguments[0]:1;<span class="cstat-no" title="statement not covered" ></span>return $u({input:Su,output:Su,padding:null,file_frame:null,stylesheet:null,shadows:null,boundaries:!0,faces:!0,edges:!0,vertices:!1,attributes:{svg:{width:Ku,height:Ku,stroke:Nu,fill:Ju,"stroke-linejoin":"bevel","stroke-width":e/200},circle:{r:e/200},boundaries:{fill:zu},faces:{stroke:Ju,front:{fill:Iu},back:{fill:zu},foldedForm:{stroke:Nu}},edges:{boundary:{},mountain:{stroke:"red"},valley:{stroke:"blue"},mark:{stroke:Iu},unassigned:{stroke:Iu}},vertices:{stroke:Ju,fill:Nu}}})}</span>,es=function <span class="fstat-no" title="function not covered" >make_options(</span>){var e=<span class="cstat-no" title="statement not covered" >arguments.length&gt;0&amp;&amp;void 0!==arguments[0]?arguments[0]:{},</span>t=<span class="cstat-no" title="statement not covered" >arguments.length&gt;1&amp;&amp;void 0!==arguments[1]?arguments[1]:{},</span>n=<span class="cstat-no" title="statement not covered" >Wu(e),</span>r=<span class="cstat-no" title="statement not covered" >Math.min(n[2],n[3]);<span class="cstat-no" title="statement not covered" ></span>return Hu(t,Qu(r)),t.shadows&amp;&amp;Hu(t,{attributes:{faces:{front:{filter:"url(#shadow)"},back:{filter:"url(#shadow)"}}}}),t}</span>,ts=function <span class="fstat-no" title="function not covered" >boundaries_polygon(</span>e){<span class="cstat-no" title="statement not covered" >if(qu in e==!1||Tu in e==!1||Gu in e==!1)<span class="cstat-no" title="statement not covered" >return[];v</span></span>ar t=<span class="cstat-no" title="statement not covered" >function <span class="fstat-no" title="function not covered" >get_boundary(</span>e){<span class="cstat-no" title="statement not covered" >if(null==e.edges_assignment)<span class="cstat-no" title="statement not covered" >return{vertices:[],edges:[]};<span class="cstat-no" title="statement not covered" >f</span></span>or(var t=<span class="cstat-no" title="statement not covered" >e.edges_assignment.map((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return"B"===e||"b"===e}</span>)),</span>n=<span class="cstat-no" title="statement not covered" >function <span class="fstat-no" title="function not covered" >make_vertices_edges(</span>e){<span class="cstat-no" title="statement not covered" >if(e.edges_vertices){var t=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>return e.edges_vertices.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(e,n){<span class="cstat-no" title="statement not covered" >return e.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >void 0===t[e]&amp;&amp;(t[e]=[]),t[e].push(n)}</span>))}</span>)),t}</span>}</span>(e),</span>r=<span class="cstat-no" title="statement not covered" >[],</span>o=<span class="cstat-no" title="statement not covered" >[],</span>i=<span class="cstat-no" title="statement not covered" >-1,</span>c=<span class="cstat-no" title="statement not covered" >0;</span>c&lt;t.length;c+=1)<span class="cstat-no" title="statement not covered" >if(t[c]){<span class="cstat-no" title="statement not covered" >i=c;<span class="cstat-no" title="statement not covered" >b</span>reak}<span class="cstat-no" title="statement not covered" ></span>i</span></span>f(-1===i)<span class="cstat-no" title="statement not covered" >return{vertices:[],edges:[]};<span class="cstat-no" title="statement not covered" >t</span></span>[i]=!1,r.push(i),o.push(e.edges_vertices[i][0]);<span class="cstat-no" title="statement not covered" >f</span>or(var a=<span class="cstat-no" title="statement not covered" >e.edges_vertices[i][1];</span>o[0]!==a;){<span class="cstat-no" title="statement not covered" >if(o.push(a),void 0===(i=n[a].filter((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return t[e]}</span>)).shift()))<span class="cstat-no" title="statement not covered" >return{vertices:[],edges:[]};<span class="cstat-no" title="statement not covered" >a</span></span>=e.edges_vertices[i][0]===a?_slicedToArray(e.edges_vertices[i],2)[1]:_slicedToArray(e.edges_vertices[i],1)[0],t[i]=!1,r.push(i)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn{vertices:o,edges:r}}</span>(e).vertices.map((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return[0,1].map((<span class="fstat-no" title="function not covered" >fu</span>nction(n){<span class="cstat-no" title="statement not covered" >return e.vertices_coords[t][n]}</span>))}</span>));<span class="cstat-no" title="statement not covered" ></span>if(0===t.length)<span class="cstat-no" title="statement not covered" >return[];v</span></span>ar n=<span class="cstat-no" title="statement not covered" >Xu.SVG.polygon(t);<span class="cstat-no" title="statement not covered" ></span>return n.setAttributeNS(null,Ou,yu),[n]}</span>,ns=function <span class="fstat-no" title="function not covered" >vertices_circle(</span>e,t){<span class="cstat-no" title="statement not covered" >if(qu in e==!1)<span class="cstat-no" title="statement not covered" >return[];v</span></span>ar n=<span class="cstat-no" title="statement not covered" >e.vertices_coords.map((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return Xu.SVG.circle(e[0],e[1],.01)}</span>));<span class="cstat-no" title="statement not covered" ></span>return n.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){<span class="cstat-no" title="statement not covered" >return e.setAttributeNS(null,ju,t)}</span>)),n}</span>,rs={B:yu,b:yu,M:bu,m:bu,V:xu,v:xu,F:Au,f:Au,U:ku,u:ku},os={B:"b",b:"b",M:"m",m:"m",V:"v",v:"v",F:"f",f:"f",U:"u",u:"u"},is=function <span class="fstat-no" title="function not covered" >edges_coords(</span>e){<span class="cstat-no" title="statement not covered" >return null==e.edges_vertices||null==e.vertices_coords?[]:e.edges_vertices.map((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t.map((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return e.vertices_coords[t]}</span>))}</span>))}</span>,cs=function <span class="fstat-no" title="function not covered" >segment_to_path(</span>e){<span class="cstat-no" title="statement not covered" >return"M".concat(e[0][0]," ").concat(e[0][1],"L").concat(e[1][0]," ").concat(e[1][1])}</span>,as=function <span class="fstat-no" title="function not covered" >edges_path_data(</span>e){var t=<span class="cstat-no" title="statement not covered" >is(e).map((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return cs(e)}</span>)).join("");<span class="cstat-no" title="statement not covered" ></span>return""===t?void 0:t}</span>,us=function <span class="fstat-no" title="function not covered" >edges_by_assignment_paths_data(</span>e){<span class="cstat-no" title="statement not covered" >if(null==e.edges_vertices||null==e.vertices_coords||null==e.edges_assignment)<span class="cstat-no" title="statement not covered" >return[];v</span></span>ar t=<span class="cstat-no" title="statement not covered" >is(e),</span>n=<span class="cstat-no" title="statement not covered" >function <span class="fstat-no" title="function not covered" >edges_indices_classes(</span>e){var t=<span class="cstat-no" title="statement not covered" >{u:[],f:[],v:[],m:[],b:[]};<span class="cstat-no" title="statement not covered" ></span>return e.edges_assignment.map((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return os[e]}</span>)).forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(e,n){<span class="cstat-no" title="statement not covered" >return t[e].push(n)}</span>)),t}</span>(e),</span>r=<span class="cstat-no" title="statement not covered" >Object.keys(n).map((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return n[e].map((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return t[e]}</span>))}</span>)).map((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return e.map((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return cs(e)}</span>)).join("")}</span>)),</span>o=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" ></span>return Object.keys(n).map((<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){<span class="cstat-no" title="statement not covered" >""!==r[t]&amp;&amp;(o[e]=r[t])}</span>)),o}</span>,ss=function <span class="fstat-no" title="function not covered" >edges_path(</span>e){<span class="cstat-no" title="statement not covered" >if(null==e.edges_assignment){var t=<span class="cstat-no" title="statement not covered" >as(e);<span class="cstat-no" title="statement not covered" ></span>return void 0===t?[]:[Xu.SVG.path(t)]}</span>v</span>ar n=<span class="cstat-no" title="statement not covered" >us(e);<span class="cstat-no" title="statement not covered" ></span>return Object.keys(n).map((<span class="fstat-no" title="function not covered" >fu</span>nction(e){var t=<span class="cstat-no" title="statement not covered" >Xu.SVG.path(n[e]);<span class="cstat-no" title="statement not covered" ></span>return t.setAttributeNS(null,Ou,rs[e]),t}</span>))}</span>,fs={subtract:function <span class="fstat-no" title="function not covered" >subtract(</span>e,t){<span class="cstat-no" title="statement not covered" >return e.map((<span class="fstat-no" title="function not covered" >fu</span>nction(e,n){<span class="cstat-no" title="statement not covered" >return e-(t[n]||0)}</span>))}</span>,cross2:function <span class="fstat-no" title="function not covered" >cross2(</span>e,t){<span class="cstat-no" title="statement not covered" >return e[0]*t[1]-e[1]*t[0]}</span>},ls=function <span class="fstat-no" title="function not covered" >finalize_faces(</span>e,t){var n=<span class="cstat-no" title="statement not covered" >_typeof(e.frame_classes)===Cu&amp;&amp;null!==e.frame_classes&amp;&amp;!e.frame_classes.includes("creasePattern"),</span>r=<span class="cstat-no" title="statement not covered" >null!=e[Bu]&amp;&amp;e[Bu].length===e.faces_vertices.length,</span>o=<span class="cstat-no" title="statement not covered" >[[wu],[Eu]].map((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return n&amp;&amp;e.push("foldedForm"),e}</span>)).map((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return e.join(" ")}</span>));<span class="cstat-no" title="statement not covered" ></span>return function <span class="fstat-no" title="function not covered" >get_faces_winding(</span>e){<span class="cstat-no" title="statement not covered" >return e.faces_vertices.map((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t.map((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return e.vertices_coords[t]}</span>)).map((<span class="fstat-no" title="function not covered" >fu</span>nction(e,t,n){<span class="cstat-no" title="statement not covered" >return[e,n[(t+1)%n.length],n[(t+2)%n.length]]}</span>)).map((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return fs.cross2(fs.subtract(e[1],e[0]),fs.subtract(e[2],e[1]))}</span>)).reduce((<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){<span class="cstat-no" title="statement not covered" >return e+t}</span>),0)}</span>))}</span>(e).map((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return e&lt;0?o[0]:o[1]}</span>)).forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(e,n){<span class="cstat-no" title="statement not covered" >return t[n].setAttributeNS(null,Ou,e)}</span>)),r?function <span class="fstat-no" title="function not covered" >faces_sorted_by_layer(</span>e){<span class="cstat-no" title="statement not covered" >return e.map((<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){<span class="cstat-no" title="statement not covered" >return{layer:e,i:t}}</span>)).sort((<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){<span class="cstat-no" title="statement not covered" >return e.layer-t.layer}</span>)).map((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return e.i}</span>))}</span>(e[Bu]).map((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return t[e]}</span>)):t}</span>,vs=function <span class="fstat-no" title="function not covered" >faces_vertices_polygon(</span>e){<span class="cstat-no" title="statement not covered" >if(Fu in e==!1||qu in e==!1)<span class="cstat-no" title="statement not covered" >return[];v</span></span>ar t=<span class="cstat-no" title="statement not covered" >e.faces_vertices.map((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t.map((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return[0,1].map((<span class="fstat-no" title="function not covered" >fu</span>nction(n){<span class="cstat-no" title="statement not covered" >return e.vertices_coords[t][n]}</span>))}</span>))}</span>)).map((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return Xu.SVG.polygon(e)}</span>));<span class="cstat-no" title="statement not covered" ></span>return t.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){<span class="cstat-no" title="statement not covered" >return e.setAttributeNS(null,ju,t)}</span>)),ls(e,t)}</span>,ds=function <span class="fstat-no" title="function not covered" >faces_edges_polygon(</span>e){<span class="cstat-no" title="statement not covered" >if(Vu in e==!1||Tu in e==!1||qu in e==!1)<span class="cstat-no" title="statement not covered" >return[];v</span></span>ar t=<span class="cstat-no" title="statement not covered" >e.faces_edges.map((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t.map((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return e.edges_vertices[t]}</span>)).map((<span class="fstat-no" title="function not covered" >fu</span>nction(e,t,n){var r=<span class="cstat-no" title="statement not covered" >n[(t+1)%n.length];<span class="cstat-no" title="statement not covered" ></span>return e[1]===r[0]||e[1]===r[1]?e[0]:e[1]}</span>)).map((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return[0,1].map((<span class="fstat-no" title="function not covered" >fu</span>nction(n){<span class="cstat-no" title="statement not covered" >return e.vertices_coords[t][n]}</span>))}</span>))}</span>)).map((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return Xu.SVG.polygon(e)}</span>));<span class="cstat-no" title="statement not covered" ></span>return t.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){<span class="cstat-no" title="statement not covered" >return e.setAttributeNS(null,ju,t)}</span>)),ls(e,t)}</span>,ps={vertices:[],edges:[ku,Au,xu,bu,yu],faces:[wu,Eu,"foldedForm"],boundaries:[]},_s=function <span class="fstat-no" title="function not covered" >style_component(</span>e,t,n){var r=<span class="cstat-no" title="statement not covered" >t.attributes,</span>o=<span class="cstat-no" title="statement not covered" >ps[n]||[];<span class="cstat-no" title="statement not covered" ></span>Array.from(e.childNodes).filter((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return r[e.nodeName]}</span>)).forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return Object.keys(r[e.nodeName]).forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return e.setAttributeNS(null,t,r[e.nodeName][t])}</span>))}</span>)),Object.keys(r[n]).filter((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return!o.includes(e)}</span>)).forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return e.setAttributeNS(null,t,r[n][t])}</span>)),0!==o.length&amp;&amp;Array.from(e.childNodes).forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return Object.keys(r[n][e.getAttribute(Ou)]||{}).forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return e.setAttributeNS(null,t,r[n][e.getAttribute(Ou)][t])}</span>))}</span>))}</span>,gs={vertices:ns,edges:ss,faces:function <span class="fstat-no" title="function not covered" >faces_draw_function(</span>e){<span class="cstat-no" title="statement not covered" >return null!=e.faces_vertices?vs(e):ds(e)}</span>,boundaries:ts},hs=function <span class="fstat-no" title="function not covered" >render_components(</span>e){var t=<span class="cstat-no" title="statement not covered" >arguments.length&gt;1&amp;&amp;void 0!==arguments[1]?arguments[1]:{};<span class="cstat-no" title="statement not covered" ></span>return t.attributes||(t.attributes={}),[mu,hu,gu,_u].filter((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return!0===t[e]}</span>)).map((<span class="fstat-no" title="function not covered" >fu</span>nction(n){var r=<span class="cstat-no" title="statement not covered" >Xu.SVG.g();<span class="cstat-no" title="statement not covered" ></span>return r.setAttributeNS(null,Ou,n),gs[n](e,t).forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return r.appendChild(e)}</span>)),_s(r,t,n),r}</span>)).filter((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return e.childNodes.length&gt;0}</span>))}</span>,ms=Uu.document,ys=Object.freeze({blur:.005,opacity:.3,color:Nu}),bs="result",xs="in",As="blur",ks="offsetColor",ws="offsetBlur",Es="feMergeNode",Ms="200%",Os=function <span class="fstat-no" title="function not covered" >make_defs(</span>e,t){var n=<span class="cstat-no" title="statement not covered" >Wu(e),</span>r=<span class="cstat-no" title="statement not covered" >Math.min(n[2],n[3]),</span>o=<span class="cstat-no" title="statement not covered" >Xu.SVG.defs();<span class="cstat-no" title="statement not covered" ></span>if(null!=t.stylesheet){var i=<span class="cstat-no" title="statement not covered" >Xu.SVG.style();<span class="cstat-no" title="statement not covered" ></span>o.appendChild(i);v</span>ar c=<span class="cstat-no" title="statement not covered" >t.attributes.svg[Lu]?t.attributes.svg[Lu]:r/200,</span>a=<span class="cstat-no" title="statement not covered" >(new Uu.DOMParser).parseFromString("&lt;xml&gt;&lt;/xml&gt;","application/xml").createCDATASection("\n* { --".concat(Lu,": ").concat(c,"; }\n").concat(t.stylesheet));<span class="cstat-no" title="statement not covered" ></span>i.appendChild(a)}<span class="cstat-no" title="statement not covered" ></span>i</span>f(null!=t.shadows){var u=<span class="cstat-no" title="statement not covered" >_typeof(t.shadows)===Cu&amp;&amp;null!==t.shadows?t.shadows:{blur:r/200};<span class="cstat-no" title="statement not covered" ></span>o.appendChild(function <span class="fstat-no" title="function not covered" >shadowFilter(</span>){var e=<span class="cstat-no" title="statement not covered" >arguments.length&gt;0&amp;&amp;void 0!==arguments[0]?arguments[0]:ys,</span>t=<span class="cstat-no" title="statement not covered" >"shadow";<span class="cstat-no" title="statement not covered" ></span>_typeof(e)===Cu&amp;&amp;null!==e||(e={}),Object.keys(ys).filter((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return!(t in e)}</span>)).forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >e[t]=ys[t]}</span>));v</span>ar n=<span class="cstat-no" title="statement not covered" >ms.createElementNS(Xu.SVG.NS,"filter");<span class="cstat-no" title="statement not covered" ></span>n.setAttributeNS(null,"width",Ms),n.setAttributeNS(null,"height",Ms),n.setAttributeNS(null,"id",t);v</span>ar r=<span class="cstat-no" title="statement not covered" >ms.createElementNS(Xu.SVG.NS,"feGaussianBlur");<span class="cstat-no" title="statement not covered" ></span>r.setAttributeNS(null,xs,"SourceAlpha"),r.setAttributeNS(null,"stdDeviation",e.blur),r.setAttributeNS(null,bs,As);v</span>ar o=<span class="cstat-no" title="statement not covered" >ms.createElementNS(Xu.SVG.NS,"feOffset");<span class="cstat-no" title="statement not covered" ></span>o.setAttributeNS(null,xs,As),o.setAttributeNS(null,bs,ws);v</span>ar i=<span class="cstat-no" title="statement not covered" >ms.createElementNS(Xu.SVG.NS,"feFlood");<span class="cstat-no" title="statement not covered" ></span>i.setAttributeNS(null,"flood-color",e.color),i.setAttributeNS(null,"flood-opacity",e.opacity),i.setAttributeNS(null,bs,ks);v</span>ar c=<span class="cstat-no" title="statement not covered" >ms.createElementNS(Xu.SVG.NS,"feComposite");<span class="cstat-no" title="statement not covered" ></span>c.setAttributeNS(null,xs,ks),c.setAttributeNS(null,"in2",ws),c.setAttributeNS(null,"operator",xs),c.setAttributeNS(null,bs,ws);v</span>ar a=<span class="cstat-no" title="statement not covered" >ms.createElementNS(Xu.SVG.NS,"feMerge"),</span>u=<span class="cstat-no" title="statement not covered" >ms.createElementNS(Xu.SVG.NS,Es),</span>s=<span class="cstat-no" title="statement not covered" >ms.createElementNS(Xu.SVG.NS,Es);<span class="cstat-no" title="statement not covered" ></span>return s.setAttributeNS(null,xs,"SourceGraphic"),a.appendChild(u),a.appendChild(s),n.appendChild(r),n.appendChild(o),n.appendChild(i),n.appendChild(c),n.appendChild(a),n}</span>(u))}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn null!=t.stylesheet||null!=t.shadows?o:void 0}</span>,js=function <span class="fstat-no" title="function not covered" >makeViewBox(</span>e,t,n,r){var o=<span class="cstat-no" title="statement not covered" >arguments.length&gt;4&amp;&amp;void 0!==arguments[4]?arguments[4]:0,</span>i=<span class="cstat-no" title="statement not covered" >1,</span>c=<span class="cstat-no" title="statement not covered" >n/i-n,</span>a=<span class="cstat-no" title="statement not covered" >e-c-o,</span>u=<span class="cstat-no" title="statement not covered" >t-c-o,</span>s=<span class="cstat-no" title="statement not covered" >n+2*c+2*o,</span>l=<span class="cstat-no" title="statement not covered" >r+2*c+2*o;<span class="cstat-no" title="statement not covered" ></span>return[a,u,s,l].join(" ")}</span>,Cs=function <span class="fstat-no" title="function not covered" >make_svg_attributes(</span>e,t){var n=<span class="cstat-no" title="statement not covered" >Wu(e),</span>r=(<span class="cstat-no" title="statement not covered" >Math.min(n[2],n[3]),{viewBox:js.apply(void 0,_toConsumableArray(n).concat([t.padding]))})</span>,o=<span class="cstat-no" title="statement not covered" >function <span class="fstat-no" title="function not covered" >graph_classes(</span>e){<span class="cstat-no" title="statement not covered" >return[(null!=e.file_classes?e.file_classes:[]).join(" "),(null!=e.frame_classes?e.frame_classes:[]).join(" ")].filter((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return""!==e}</span>)).join(" ")}</span>(e);<span class="cstat-no" title="statement not covered" ></span>return""!==o&amp;&amp;(r.class=o),Object.assign(r,t.attributes.svg),r}</span>,Ss=function <span class="fstat-no" title="function not covered" >render_into_svg(</span>e){var t=<span class="cstat-no" title="statement not covered" >arguments.length&gt;1&amp;&amp;void 0!==arguments[1]?arguments[1]:{},</span>n=<span class="cstat-no" title="statement not covered" >arguments.length&gt;2&amp;&amp;void 0!==arguments[2]?arguments[2]:{};<span class="cstat-no" title="statement not covered" ></span>es(t,n);v</span>ar r=<span class="cstat-no" title="statement not covered" >Os(t,n);<span class="cstat-no" title="statement not covered" ></span>r&amp;&amp;e.appendChild(r),hs(t,n).forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return e.appendChild(t)}</span>));v</span>ar o=<span class="cstat-no" title="statement not covered" >Cs(t,n);<span class="cstat-no" title="statement not covered" ></span>return Object.keys(o).forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return e.setAttributeNS(null,t,o[t])}</span>)),e}</span>,Ps=function <span class="fstat-no" title="function not covered" >svg$1$1(</span>){var e=<span class="cstat-no" title="statement not covered" >Uu.document.createElementNS(Xu.SVG.NS,Mu);<span class="cstat-no" title="statement not covered" ></span>return e.setAttribute("version","1.1"),e.setAttribute("xmlns",Xu.SVG.NS),e}</span>,Ns=function <span class="fstat-no" title="function not covered" >FoldToSvg(</span>e){var t=<span class="cstat-no" title="statement not covered" >arguments.length&gt;1&amp;&amp;void 0!==arguments[1]?arguments[1]:{},</span>n=<span class="cstat-no" title="statement not covered" >Yu(e);<span class="cstat-no" title="statement not covered" ></span>es(n,t);v</span>ar r=<span class="cstat-no" title="statement not covered" >Ss(Ps(),n,t);<span class="cstat-no" title="statement not covered" ></span>if(t.output===Mu)<span class="cstat-no" title="statement not covered" >return r;v</span></span>ar o=<span class="cstat-no" title="statement not covered" >(new Uu.XMLSerializer).serializeToString(r),</span>i=<span class="cstat-no" title="statement not covered" >vkXML$1(o);<span class="cstat-no" title="statement not covered" ></span>return i}</span>;Object.assign(Ns,{render_into_svg:Ss,render_components:hs,options:es,boundaries_polygon:ts,vertices_circle:ns,edges_path_data:as,edges_by_assignment_paths_data:us,edges_path:ss,edges_line:function <span class="fstat-no" title="function not covered" >edges_line(</span>e){var t=<span class="cstat-no" title="statement not covered" >is(e).map((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return Xu.SVG.line(e[0][0],e[0][1],e[1][0],e[1][1])}</span>));<span class="cstat-no" title="statement not covered" ></span>return t.forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(e,t){<span class="cstat-no" title="statement not covered" >return e.setAttributeNS(null,ju,t)}</span>)),function <span class="fstat-no" title="function not covered" >make_edges_assignment_names(</span>e){<span class="cstat-no" title="statement not covered" >return null==e.edges_vertices||null==e.edges_assignment||e.edges_vertices.length!==e.edges_assignment.length?[]:e.edges_assignment.map((<span class="fstat-no" title="function not covered" >fu</span>nction(e){<span class="cstat-no" title="statement not covered" >return rs[e]}</span>))}</span>(e).forEach((<span class="fstat-no" title="function not covered" >fu</span>nction(e,n){<span class="cstat-no" title="statement not covered" >return t[n].setAttributeNS(null,Ou,e)}</span>)),t}</span>,faces_vertices_polygon:vs,faces_edges_polygon:ds,linker:function linker(e){}.bind(Ns),use:function use(e){e.NS&amp;&amp;(Xu.SVG=e)}});var zs={graph:Ni,cp:Ii,origami:qi},Is={graph:{},cp:Fi.square(),origami:Fi.square()};Object.keys(zs).forEach((function(e){bi[e]=function(){var t=Array.from(arguments).filter((function(e){return yr(e)})).map((function(e){return JSON.parse(JSON.stringify(e))}));return Object.assign.apply(Object,[Object.create(zs[e]),t.length?{}:Is[e]].concat(_toConsumableArray(t),[{file_spec:Qn,file_creator:er}]))},bi[e].prototype=zs[e],bi[e].prototype.constructor=bi[e],Object.keys(Fi).forEach((function(t){bi[e][t]=function(){return bi[e](Fi[t].apply(Fi,arguments))}}))})),Object.assign(bi.graph,li);var Ls=Object.assign(Kn,bi,{math:Jn.core,axiom:Di,diagram:yi,text:Ui,webgl:$i});return Object.defineProperty(Ls,"use",{enumerable:!1,value:function use(e){null!=e&amp;&amp;"function"==typeof e.linker&amp;&amp;e.linker(this)}.bind(Ls)}),Object.keys(Jn).filter((function(e){return"core"!==e})).forEach((function(e){Ls[e]=Jn[e]})),pu.use(Ns),pu.use(Ls),Ns.use(pu),Ls.use(pu),Ls.use(Ns),Ls}));
&nbsp;</pre></td></tr></table></pre>

                <div class='push'></div><!-- for sticky footer -->
            </div><!-- /wrapper -->
            <div class='footer quiet pad2 space-top1 center small'>
                Code coverage generated by
                <a href="https://istanbul.js.org/" target="_blank">istanbul</a>
                at Thu Dec 31 2020 18:49:23 GMT+0000 (Coordinated Universal Time)
            </div>
        </div>
        <script src="prettify.js"></script>
        <script>
            window.onload = function () {
                prettyPrint();
            };
        </script>
        <script src="sorter.js"></script>
        <script src="block-navigation.js"></script>
    </body>
</html>
    